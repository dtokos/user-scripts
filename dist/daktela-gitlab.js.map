{"version":3,"file":"daktela-gitlab.js","sources":["../node_modules/svelte/src/version.js","../node_modules/svelte/src/internal/disclose-version.js","../node_modules/svelte/src/constants.js","../node_modules/esm-env/prod-browser.js","../node_modules/svelte/src/internal/shared/utils.js","../node_modules/svelte/src/internal/client/constants.js","../node_modules/svelte/src/internal/client/reactivity/equality.js","../node_modules/svelte/src/internal/client/errors.js","../node_modules/svelte/src/internal/client/reactivity/sources.js","../node_modules/svelte/src/internal/client/reactivity/deriveds.js","../node_modules/svelte/src/internal/client/reactivity/effects.js","../node_modules/svelte/src/internal/client/dom/task.js","../node_modules/svelte/src/internal/shared/errors.js","../node_modules/svelte/src/internal/client/runtime.js","../node_modules/svelte/src/internal/client/proxy.js","../node_modules/svelte/src/internal/client/dom/operations.js","../node_modules/svelte/src/internal/client/dom/hydration.js","../node_modules/svelte/src/internal/client/dom/elements/events.js","../node_modules/svelte/src/internal/client/dom/reconciler.js","../node_modules/svelte/src/internal/client/dom/template.js","../node_modules/svelte/src/utils.js","../node_modules/svelte/src/internal/client/render.js","../node_modules/svelte/src/internal/client/dom/blocks/if.js","../node_modules/svelte/src/internal/client/dom/blocks/each.js","../node_modules/svelte/src/internal/client/dom/blocks/slot.js","../node_modules/svelte/src/internal/client/dom/blocks/snippet.js","../node_modules/svelte/src/internal/client/dom/blocks/svelte-component.js","../node_modules/svelte/src/internal/client/dom/blocks/svelte-element.js","../node_modules/svelte/src/internal/client/dom/elements/actions.js","../node_modules/svelte/src/internal/client/dom/elements/misc.js","../node_modules/svelte/src/internal/client/dom/elements/attributes.js","../node_modules/svelte/src/internal/client/dom/elements/class.js","../node_modules/svelte/src/internal/client/timing.js","../node_modules/svelte/src/internal/client/loop.js","../node_modules/svelte/src/internal/client/dom/elements/transitions.js","../node_modules/svelte/src/internal/client/dom/elements/bindings/this.js","../node_modules/svelte/src/internal/client/dom/legacy/lifecycle.js","../node_modules/svelte/src/internal/client/dom/legacy/misc.js","../node_modules/svelte/src/internal/client/reactivity/props.js","../node_modules/svelte/src/store/utils.js","../node_modules/svelte/src/internal/client/reactivity/store.js","../node_modules/bits-ui/node_modules/@melt-ui/svelte/dist/internal/helpers/array.js","../node_modules/bits-ui/node_modules/@melt-ui/svelte/dist/internal/helpers/style.js","../node_modules/bits-ui/node_modules/@melt-ui/svelte/dist/internal/helpers/attr.js","../node_modules/svelte/src/store/shared/index.js","../node_modules/bits-ui/node_modules/@melt-ui/svelte/dist/internal/helpers/store/lightable.js","../node_modules/bits-ui/node_modules/@melt-ui/svelte/dist/internal/helpers/makeElement.js","../node_modules/bits-ui/node_modules/@melt-ui/svelte/dist/internal/helpers/is.js","../node_modules/bits-ui/node_modules/@melt-ui/svelte/dist/internal/helpers/callbacks.js","../node_modules/bits-ui/node_modules/@melt-ui/svelte/dist/internal/helpers/event.js","../node_modules/bits-ui/node_modules/@melt-ui/svelte/dist/internal/helpers/highlight.js","../node_modules/svelte/src/index-client.js","../node_modules/bits-ui/node_modules/@melt-ui/svelte/dist/internal/helpers/lifecycle.js","../node_modules/bits-ui/node_modules/@melt-ui/svelte/dist/internal/helpers/object.js","../node_modules/bits-ui/node_modules/@melt-ui/svelte/dist/internal/helpers/withGet.js","../node_modules/bits-ui/node_modules/@melt-ui/svelte/dist/internal/helpers/overridable.js","../node_modules/bits-ui/node_modules/@melt-ui/svelte/dist/internal/helpers/sleep.js","../node_modules/nanoid/non-secure/index.js","../node_modules/bits-ui/node_modules/@melt-ui/svelte/dist/internal/helpers/id.js","../node_modules/bits-ui/node_modules/@melt-ui/svelte/dist/internal/helpers/keyboard.js","../node_modules/bits-ui/node_modules/@melt-ui/svelte/dist/internal/helpers/debounce.js","../node_modules/bits-ui/node_modules/@melt-ui/svelte/dist/internal/helpers/platform.js","../node_modules/bits-ui/node_modules/@melt-ui/svelte/dist/internal/helpers/scroll.js","../node_modules/bits-ui/node_modules/@melt-ui/svelte/dist/internal/helpers/store/derivedVisible.js","../node_modules/bits-ui/node_modules/@melt-ui/svelte/dist/internal/helpers/store/effect.js","../node_modules/bits-ui/node_modules/@melt-ui/svelte/dist/internal/helpers/store/toWritableStores.js","../node_modules/bits-ui/node_modules/@melt-ui/svelte/dist/internal/helpers/rovingFocus.js","../node_modules/bits-ui/node_modules/@melt-ui/svelte/dist/internal/helpers/typeahead.js","../node_modules/bits-ui/node_modules/@melt-ui/svelte/dist/internal/helpers/elements.js","../node_modules/bits-ui/node_modules/@melt-ui/svelte/dist/internal/helpers/focus.js","../node_modules/bits-ui/node_modules/@melt-ui/svelte/dist/internal/actions/click-outside/action.js","../node_modules/bits-ui/node_modules/@melt-ui/svelte/dist/internal/actions/escape-keydown/action.js","../node_modules/@floating-ui/utils/dist/floating-ui.utils.mjs","../node_modules/@floating-ui/core/dist/floating-ui.core.mjs","../node_modules/@floating-ui/utils/dist/floating-ui.utils.dom.mjs","../node_modules/@floating-ui/dom/dist/floating-ui.dom.mjs","../node_modules/bits-ui/node_modules/@melt-ui/svelte/dist/internal/actions/floating/action.js","../node_modules/tabbable/dist/index.esm.js","../node_modules/focus-trap/dist/focus-trap.esm.js","../node_modules/bits-ui/node_modules/@melt-ui/svelte/dist/internal/actions/focus-trap/action.js","../node_modules/bits-ui/node_modules/@melt-ui/svelte/dist/internal/actions/modal/action.js","../node_modules/bits-ui/node_modules/@melt-ui/svelte/dist/internal/actions/popper/action.js","../node_modules/bits-ui/node_modules/@melt-ui/svelte/dist/internal/actions/portal.js","../node_modules/bits-ui/node_modules/@melt-ui/svelte/dist/internal/actions/interact-outside/action.js","../node_modules/bits-ui/node_modules/@melt-ui/svelte/dist/builders/hidden-input/create.js","../node_modules/bits-ui/node_modules/@melt-ui/svelte/dist/builders/menu/create.js","../node_modules/bits-ui/node_modules/@melt-ui/svelte/dist/builders/calendar/create.js","../node_modules/bits-ui/node_modules/@melt-ui/svelte/dist/builders/date-picker/create.js","../node_modules/bits-ui/node_modules/@melt-ui/svelte/dist/builders/dialog/create.js","../node_modules/bits-ui/node_modules/@melt-ui/svelte/dist/builders/dropdown-menu/create.js","../node_modules/bits-ui/node_modules/@melt-ui/svelte/dist/builders/separator/create.js","../node_modules/bits-ui/dist/internal/attrs.js","../node_modules/bits-ui/dist/internal/events.js","../node_modules/bits-ui/dist/internal/object.js","../node_modules/bits-ui/dist/internal/updater.js","../node_modules/bits-ui/dist/bits/floating/helpers.js","../node_modules/bits-ui/dist/bits/menu/ctx.js","../node_modules/bits-ui/dist/bits/menu/components/menu-item.svelte","../node_modules/bits-ui/dist/bits/dialog/ctx.js","../node_modules/bits-ui/dist/bits/dialog/components/dialog.svelte","../node_modules/bits-ui/dist/bits/dialog/components/dialog-title.svelte","../node_modules/bits-ui/dist/bits/dialog/components/dialog-close.svelte","../node_modules/bits-ui/dist/bits/dialog/components/dialog-portal.svelte","../node_modules/bits-ui/dist/bits/dialog/components/dialog-content.svelte","../node_modules/bits-ui/dist/bits/dialog/components/dialog-overlay.svelte","../node_modules/bits-ui/dist/bits/menu/components/menu.svelte","../node_modules/bits-ui/dist/bits/menu/components/menu-content.svelte","../node_modules/bits-ui/dist/bits/menu/components/menu-trigger.svelte","../src/services/gitlab/ui/Icon.svelte","../src/services/gitlab/ui/dropdown/Trigger.svelte","../src/services/gitlab/ui/dropdown/Content.svelte","../src/services/gitlab/ui/dropdown/index.ts","../src/services/gitlab/ui/DaktelaIcon.svelte","../src/daktela/gitlab/features/FeatureDropdown.svelte","../src/daktela/gitlab/current.ts","../src/services/gitlab/ui/modal/Content.svelte","../src/services/gitlab/ui/modal/index.ts","../src/daktela/gitlab/render.ts","../src/daktela/gitlab/features/generate-ticket-comment/Steps/Result.svelte","../src/services/gitlab/gitlab.ts","../src/daktela/gitlab/cherry-picks.ts","../src/daktela/gitlab/parse.ts","../src/daktela/gitlab/comments.ts","../src/daktela/gitlab/features/generate-ticket-comment/GenerateTicketCommentModal.svelte","../src/daktela/gitlab/features/Modals.svelte","../src/daktela/gitlab/features/generate-ticket-comment/controls.svelte.ts","../src/daktela/gitlab/features/inject.ts","../src/daktela/gitlab/main.ts"],"sourcesContent":["// generated during release, do not modify\n\n/**\n * The current version, as set in package.json.\n *\n * https://svelte.dev/docs/svelte-compiler#svelte-version\n * @type {string}\n */\nexport const VERSION = '5.0.5';\nexport const PUBLIC_VERSION = '5';\n","import { PUBLIC_VERSION } from '../version.js';\n\nif (typeof window !== 'undefined')\n\t// @ts-ignore\n\t(window.__svelte ||= { v: new Set() }).v.add(PUBLIC_VERSION);\n","export const EACH_ITEM_REACTIVE = 1;\nexport const EACH_INDEX_REACTIVE = 1 << 1;\n/** See EachBlock interface metadata.is_controlled for an explanation what this is */\nexport const EACH_IS_CONTROLLED = 1 << 2;\nexport const EACH_IS_ANIMATED = 1 << 3;\nexport const EACH_ITEM_IMMUTABLE = 1 << 4;\n\nexport const PROPS_IS_IMMUTABLE = 1;\nexport const PROPS_IS_RUNES = 1 << 1;\nexport const PROPS_IS_UPDATED = 1 << 2;\nexport const PROPS_IS_BINDABLE = 1 << 3;\nexport const PROPS_IS_LAZY_INITIAL = 1 << 4;\n\nexport const TRANSITION_IN = 1;\nexport const TRANSITION_OUT = 1 << 1;\nexport const TRANSITION_GLOBAL = 1 << 2;\n\nexport const TEMPLATE_FRAGMENT = 1;\nexport const TEMPLATE_USE_IMPORT_NODE = 1 << 1;\n\nexport const HYDRATION_START = '[';\n/** used to indicate that an `{:else}...` block was rendered */\nexport const HYDRATION_START_ELSE = '[!';\nexport const HYDRATION_END = ']';\nexport const HYDRATION_ERROR = {};\n\nexport const ELEMENT_IS_NAMESPACED = 1;\nexport const ELEMENT_PRESERVE_ATTRIBUTE_CASE = 1 << 1;\n\nexport const UNINITIALIZED = Symbol();\n\n// Dev-time component properties\nexport const FILENAME = Symbol('filename');\nexport const HMR = Symbol('hmr');\n\nexport const NAMESPACE_SVG = 'http://www.w3.org/2000/svg';\nexport const NAMESPACE_MATHML = 'http://www.w3.org/1998/Math/MathML';\n\n// we use a list of ignorable runtime warnings because not every runtime warning\n// can be ignored and we want to keep the validation for svelte-ignore in place\nexport const IGNORABLE_RUNTIME_WARNINGS = /** @type {const} */ ([\n\t'state_snapshot_uncloneable',\n\t'binding_property_non_reactive',\n\t'hydration_attribute_changed',\n\t'hydration_html_changed',\n\t'ownership_invalid_binding',\n\t'ownership_invalid_mutation'\n]);\n\n/**\n * Whitespace inside one of these elements will not result in\n * a whitespace node being created in any circumstances. (This\n * list is almost certainly very incomplete)\n * TODO this is currently unused\n */\nexport const ELEMENTS_WITHOUT_TEXT = ['audio', 'datalist', 'dl', 'optgroup', 'select', 'video'];\n","export const BROWSER = true;\nexport const DEV = false;\n","// Store the references to globals in case someone tries to monkey patch these, causing the below\n// to de-opt (this occurs often when using popular extensions).\nexport var is_array = Array.isArray;\nexport var array_from = Array.from;\nexport var object_keys = Object.keys;\nexport var define_property = Object.defineProperty;\nexport var get_descriptor = Object.getOwnPropertyDescriptor;\nexport var get_descriptors = Object.getOwnPropertyDescriptors;\nexport var object_prototype = Object.prototype;\nexport var array_prototype = Array.prototype;\nexport var get_prototype_of = Object.getPrototypeOf;\n\n/**\n * @param {any} thing\n * @returns {thing is Function}\n */\nexport function is_function(thing) {\n\treturn typeof thing === 'function';\n}\n\nexport const noop = () => {};\n\n// Adapted from https://github.com/then/is-promise/blob/master/index.js\n// Distributed under MIT License https://github.com/then/is-promise/blob/master/LICENSE\n\n/**\n * @template [T=any]\n * @param {any} value\n * @returns {value is PromiseLike<T>}\n */\nexport function is_promise(value) {\n\treturn typeof value?.then === 'function';\n}\n\n/** @param {Function} fn */\nexport function run(fn) {\n\treturn fn();\n}\n\n/** @param {Array<() => void>} arr */\nexport function run_all(arr) {\n\tfor (var i = 0; i < arr.length; i++) {\n\t\tarr[i]();\n\t}\n}\n\n/**\n * @template V\n * @param {V} value\n * @param {V | (() => V)} fallback\n * @param {boolean} [lazy]\n * @returns {V}\n */\nexport function fallback(value, fallback, lazy = false) {\n\treturn value === undefined\n\t\t? lazy\n\t\t\t? /** @type {() => V} */ (fallback)()\n\t\t\t: /** @type {V} */ (fallback)\n\t\t: value;\n}\n","export const DERIVED = 1 << 1;\nexport const EFFECT = 1 << 2;\nexport const RENDER_EFFECT = 1 << 3;\nexport const BLOCK_EFFECT = 1 << 4;\nexport const BRANCH_EFFECT = 1 << 5;\nexport const ROOT_EFFECT = 1 << 6;\nexport const UNOWNED = 1 << 7;\nexport const DISCONNECTED = 1 << 8;\nexport const CLEAN = 1 << 9;\nexport const DIRTY = 1 << 10;\nexport const MAYBE_DIRTY = 1 << 11;\nexport const INERT = 1 << 12;\nexport const DESTROYED = 1 << 13;\nexport const EFFECT_RAN = 1 << 14;\n/** 'Transparent' effects do not create a transition boundary */\nexport const EFFECT_TRANSPARENT = 1 << 15;\n/** Svelte 4 legacy mode props need to be handled with deriveds and be recognized elsewhere, hence the dedicated flag */\nexport const LEGACY_DERIVED_PROP = 1 << 16;\nexport const INSPECT_EFFECT = 1 << 17;\nexport const HEAD_EFFECT = 1 << 18;\nexport const EFFECT_HAS_DERIVED = 1 << 19;\n\nexport const STATE_SYMBOL = Symbol('$state');\nexport const STATE_SYMBOL_METADATA = Symbol('$state metadata');\nexport const LOADING_ATTR_SYMBOL = Symbol('');\n","/** @import { Equals } from '#client' */\n/** @type {Equals} */\nexport function equals(value) {\n\treturn value === this.v;\n}\n\n/**\n * @param {unknown} a\n * @param {unknown} b\n * @returns {boolean}\n */\nexport function safe_not_equal(a, b) {\n\treturn a != a\n\t\t? b == b\n\t\t: a !== b || (a !== null && typeof a === 'object') || typeof a === 'function';\n}\n\n/** @type {Equals} */\nexport function safe_equals(value) {\n\treturn !safe_not_equal(value, this.v);\n}\n","/* This file is generated by scripts/process-messages/index.js. Do not edit! */\n\nimport { DEV } from 'esm-env';\n\n/**\n * Using `bind:value` together with a checkbox input is not allowed. Use `bind:checked` instead\n * @returns {never}\n */\nexport function bind_invalid_checkbox_value() {\n\tif (DEV) {\n\t\tconst error = new Error(`bind_invalid_checkbox_value\\nUsing \\`bind:value\\` together with a checkbox input is not allowed. Use \\`bind:checked\\` instead`);\n\n\t\terror.name = 'Svelte error';\n\t\tthrow error;\n\t} else {\n\t\t// TODO print a link to the documentation\n\t\tthrow new Error(\"bind_invalid_checkbox_value\");\n\t}\n}\n\n/**\n * Component %component% has an export named `%key%` that a consumer component is trying to access using `bind:%key%`, which is disallowed. Instead, use `bind:this` (e.g. `<%name% bind:this={component} />`) and then access the property on the bound component instance (e.g. `component.%key%`)\n * @param {string} component\n * @param {string} key\n * @param {string} name\n * @returns {never}\n */\nexport function bind_invalid_export(component, key, name) {\n\tif (DEV) {\n\t\tconst error = new Error(`bind_invalid_export\\nComponent ${component} has an export named \\`${key}\\` that a consumer component is trying to access using \\`bind:${key}\\`, which is disallowed. Instead, use \\`bind:this\\` (e.g. \\`<${name} bind:this={component} />\\`) and then access the property on the bound component instance (e.g. \\`component.${key}\\`)`);\n\n\t\terror.name = 'Svelte error';\n\t\tthrow error;\n\t} else {\n\t\t// TODO print a link to the documentation\n\t\tthrow new Error(\"bind_invalid_export\");\n\t}\n}\n\n/**\n * A component is attempting to bind to a non-bindable property `%key%` belonging to %component% (i.e. `<%name% bind:%key%={...}>`). To mark a property as bindable: `let { %key% = $bindable() } = $props()`\n * @param {string} key\n * @param {string} component\n * @param {string} name\n * @returns {never}\n */\nexport function bind_not_bindable(key, component, name) {\n\tif (DEV) {\n\t\tconst error = new Error(`bind_not_bindable\\nA component is attempting to bind to a non-bindable property \\`${key}\\` belonging to ${component} (i.e. \\`<${name} bind:${key}={...}>\\`). To mark a property as bindable: \\`let { ${key} = $bindable() } = $props()\\``);\n\n\t\terror.name = 'Svelte error';\n\t\tthrow error;\n\t} else {\n\t\t// TODO print a link to the documentation\n\t\tthrow new Error(\"bind_not_bindable\");\n\t}\n}\n\n/**\n * %parent% called `%method%` on an instance of %component%, which is no longer valid in Svelte 5. See https://svelte-5-preview.vercel.app/docs/breaking-changes#components-are-no-longer-classes for more information\n * @param {string} parent\n * @param {string} method\n * @param {string} component\n * @returns {never}\n */\nexport function component_api_changed(parent, method, component) {\n\tif (DEV) {\n\t\tconst error = new Error(`component_api_changed\\n${parent} called \\`${method}\\` on an instance of ${component}, which is no longer valid in Svelte 5. See https://svelte-5-preview.vercel.app/docs/breaking-changes#components-are-no-longer-classes for more information`);\n\n\t\terror.name = 'Svelte error';\n\t\tthrow error;\n\t} else {\n\t\t// TODO print a link to the documentation\n\t\tthrow new Error(\"component_api_changed\");\n\t}\n}\n\n/**\n * Attempted to instantiate %component% with `new %name%`, which is no longer valid in Svelte 5. If this component is not under your control, set the `compatibility.componentApi` compiler option to `4` to keep it working. See https://svelte-5-preview.vercel.app/docs/breaking-changes#components-are-no-longer-classes for more information\n * @param {string} component\n * @param {string} name\n * @returns {never}\n */\nexport function component_api_invalid_new(component, name) {\n\tif (DEV) {\n\t\tconst error = new Error(`component_api_invalid_new\\nAttempted to instantiate ${component} with \\`new ${name}\\`, which is no longer valid in Svelte 5. If this component is not under your control, set the \\`compatibility.componentApi\\` compiler option to \\`4\\` to keep it working. See https://svelte-5-preview.vercel.app/docs/breaking-changes#components-are-no-longer-classes for more information`);\n\n\t\terror.name = 'Svelte error';\n\t\tthrow error;\n\t} else {\n\t\t// TODO print a link to the documentation\n\t\tthrow new Error(\"component_api_invalid_new\");\n\t}\n}\n\n/**\n * A derived value cannot reference itself recursively\n * @returns {never}\n */\nexport function derived_references_self() {\n\tif (DEV) {\n\t\tconst error = new Error(`derived_references_self\\nA derived value cannot reference itself recursively`);\n\n\t\terror.name = 'Svelte error';\n\t\tthrow error;\n\t} else {\n\t\t// TODO print a link to the documentation\n\t\tthrow new Error(\"derived_references_self\");\n\t}\n}\n\n/**\n * Keyed each block has duplicate key `%value%` at indexes %a% and %b%\n * @param {string} a\n * @param {string} b\n * @param {string | undefined | null} [value]\n * @returns {never}\n */\nexport function each_key_duplicate(a, b, value) {\n\tif (DEV) {\n\t\tconst error = new Error(`each_key_duplicate\\n${value ? `Keyed each block has duplicate key \\`${value}\\` at indexes ${a} and ${b}` : `Keyed each block has duplicate key at indexes ${a} and ${b}`}`);\n\n\t\terror.name = 'Svelte error';\n\t\tthrow error;\n\t} else {\n\t\t// TODO print a link to the documentation\n\t\tthrow new Error(\"each_key_duplicate\");\n\t}\n}\n\n/**\n * `%rune%` cannot be used inside an effect cleanup function\n * @param {string} rune\n * @returns {never}\n */\nexport function effect_in_teardown(rune) {\n\tif (DEV) {\n\t\tconst error = new Error(`effect_in_teardown\\n\\`${rune}\\` cannot be used inside an effect cleanup function`);\n\n\t\terror.name = 'Svelte error';\n\t\tthrow error;\n\t} else {\n\t\t// TODO print a link to the documentation\n\t\tthrow new Error(\"effect_in_teardown\");\n\t}\n}\n\n/**\n * Effect cannot be created inside a `$derived` value that was not itself created inside an effect\n * @returns {never}\n */\nexport function effect_in_unowned_derived() {\n\tif (DEV) {\n\t\tconst error = new Error(`effect_in_unowned_derived\\nEffect cannot be created inside a \\`$derived\\` value that was not itself created inside an effect`);\n\n\t\terror.name = 'Svelte error';\n\t\tthrow error;\n\t} else {\n\t\t// TODO print a link to the documentation\n\t\tthrow new Error(\"effect_in_unowned_derived\");\n\t}\n}\n\n/**\n * `%rune%` can only be used inside an effect (e.g. during component initialisation)\n * @param {string} rune\n * @returns {never}\n */\nexport function effect_orphan(rune) {\n\tif (DEV) {\n\t\tconst error = new Error(`effect_orphan\\n\\`${rune}\\` can only be used inside an effect (e.g. during component initialisation)`);\n\n\t\terror.name = 'Svelte error';\n\t\tthrow error;\n\t} else {\n\t\t// TODO print a link to the documentation\n\t\tthrow new Error(\"effect_orphan\");\n\t}\n}\n\n/**\n * Maximum update depth exceeded. This can happen when a reactive block or effect repeatedly sets a new value. Svelte limits the number of nested updates to prevent infinite loops\n * @returns {never}\n */\nexport function effect_update_depth_exceeded() {\n\tif (DEV) {\n\t\tconst error = new Error(`effect_update_depth_exceeded\\nMaximum update depth exceeded. This can happen when a reactive block or effect repeatedly sets a new value. Svelte limits the number of nested updates to prevent infinite loops`);\n\n\t\terror.name = 'Svelte error';\n\t\tthrow error;\n\t} else {\n\t\t// TODO print a link to the documentation\n\t\tthrow new Error(\"effect_update_depth_exceeded\");\n\t}\n}\n\n/**\n * Failed to hydrate the application\n * @returns {never}\n */\nexport function hydration_failed() {\n\tif (DEV) {\n\t\tconst error = new Error(`hydration_failed\\nFailed to hydrate the application`);\n\n\t\terror.name = 'Svelte error';\n\t\tthrow error;\n\t} else {\n\t\t// TODO print a link to the documentation\n\t\tthrow new Error(\"hydration_failed\");\n\t}\n}\n\n/**\n * Could not `{@render}` snippet due to the expression being `null` or `undefined`. Consider using optional chaining `{@render snippet?.()}`\n * @returns {never}\n */\nexport function invalid_snippet() {\n\tif (DEV) {\n\t\tconst error = new Error(`invalid_snippet\\nCould not \\`{@render}\\` snippet due to the expression being \\`null\\` or \\`undefined\\`. Consider using optional chaining \\`{@render snippet?.()}\\``);\n\n\t\terror.name = 'Svelte error';\n\t\tthrow error;\n\t} else {\n\t\t// TODO print a link to the documentation\n\t\tthrow new Error(\"invalid_snippet\");\n\t}\n}\n\n/**\n * `%name%(...)` cannot be used in runes mode\n * @param {string} name\n * @returns {never}\n */\nexport function lifecycle_legacy_only(name) {\n\tif (DEV) {\n\t\tconst error = new Error(`lifecycle_legacy_only\\n\\`${name}(...)\\` cannot be used in runes mode`);\n\n\t\terror.name = 'Svelte error';\n\t\tthrow error;\n\t} else {\n\t\t// TODO print a link to the documentation\n\t\tthrow new Error(\"lifecycle_legacy_only\");\n\t}\n}\n\n/**\n * Cannot do `bind:%key%={undefined}` when `%key%` has a fallback value\n * @param {string} key\n * @returns {never}\n */\nexport function props_invalid_value(key) {\n\tif (DEV) {\n\t\tconst error = new Error(`props_invalid_value\\nCannot do \\`bind:${key}={undefined}\\` when \\`${key}\\` has a fallback value`);\n\n\t\terror.name = 'Svelte error';\n\t\tthrow error;\n\t} else {\n\t\t// TODO print a link to the documentation\n\t\tthrow new Error(\"props_invalid_value\");\n\t}\n}\n\n/**\n * Rest element properties of `$props()` such as `%property%` are readonly\n * @param {string} property\n * @returns {never}\n */\nexport function props_rest_readonly(property) {\n\tif (DEV) {\n\t\tconst error = new Error(`props_rest_readonly\\nRest element properties of \\`$props()\\` such as \\`${property}\\` are readonly`);\n\n\t\terror.name = 'Svelte error';\n\t\tthrow error;\n\t} else {\n\t\t// TODO print a link to the documentation\n\t\tthrow new Error(\"props_rest_readonly\");\n\t}\n}\n\n/**\n * The `%rune%` rune is only available inside `.svelte` and `.svelte.js/ts` files\n * @param {string} rune\n * @returns {never}\n */\nexport function rune_outside_svelte(rune) {\n\tif (DEV) {\n\t\tconst error = new Error(`rune_outside_svelte\\nThe \\`${rune}\\` rune is only available inside \\`.svelte\\` and \\`.svelte.js/ts\\` files`);\n\n\t\terror.name = 'Svelte error';\n\t\tthrow error;\n\t} else {\n\t\t// TODO print a link to the documentation\n\t\tthrow new Error(\"rune_outside_svelte\");\n\t}\n}\n\n/**\n * Property descriptors defined on `$state` objects must contain `value` and always be `enumerable`, `configurable` and `writable`.\n * @returns {never}\n */\nexport function state_descriptors_fixed() {\n\tif (DEV) {\n\t\tconst error = new Error(`state_descriptors_fixed\\nProperty descriptors defined on \\`$state\\` objects must contain \\`value\\` and always be \\`enumerable\\`, \\`configurable\\` and \\`writable\\`.`);\n\n\t\terror.name = 'Svelte error';\n\t\tthrow error;\n\t} else {\n\t\t// TODO print a link to the documentation\n\t\tthrow new Error(\"state_descriptors_fixed\");\n\t}\n}\n\n/**\n * Cannot set prototype of `$state` object\n * @returns {never}\n */\nexport function state_prototype_fixed() {\n\tif (DEV) {\n\t\tconst error = new Error(`state_prototype_fixed\\nCannot set prototype of \\`$state\\` object`);\n\n\t\terror.name = 'Svelte error';\n\t\tthrow error;\n\t} else {\n\t\t// TODO print a link to the documentation\n\t\tthrow new Error(\"state_prototype_fixed\");\n\t}\n}\n\n/**\n * Reading state that was created inside the same derived is forbidden. Consider using `untrack` to read locally created state\n * @returns {never}\n */\nexport function state_unsafe_local_read() {\n\tif (DEV) {\n\t\tconst error = new Error(`state_unsafe_local_read\\nReading state that was created inside the same derived is forbidden. Consider using \\`untrack\\` to read locally created state`);\n\n\t\terror.name = 'Svelte error';\n\t\tthrow error;\n\t} else {\n\t\t// TODO print a link to the documentation\n\t\tthrow new Error(\"state_unsafe_local_read\");\n\t}\n}\n\n/**\n * Updating state inside a derived or a template expression is forbidden. If the value should not be reactive, declare it without `$state`\n * @returns {never}\n */\nexport function state_unsafe_mutation() {\n\tif (DEV) {\n\t\tconst error = new Error(`state_unsafe_mutation\\nUpdating state inside a derived or a template expression is forbidden. If the value should not be reactive, declare it without \\`$state\\``);\n\n\t\terror.name = 'Svelte error';\n\t\tthrow error;\n\t} else {\n\t\t// TODO print a link to the documentation\n\t\tthrow new Error(\"state_unsafe_mutation\");\n\t}\n}","/** @import { Derived, Effect, Reaction, Source, Value } from '#client' */\nimport { DEV } from 'esm-env';\nimport {\n\tcomponent_context,\n\tactive_reaction,\n\tnew_deps,\n\tactive_effect,\n\tuntracked_writes,\n\tget,\n\tis_runes,\n\tschedule_effect,\n\tset_untracked_writes,\n\tset_signal_status,\n\tuntrack,\n\tincrement_version,\n\tupdate_effect,\n\tderived_sources,\n\tset_derived_sources,\n\tcheck_dirtiness,\n\tset_is_flushing_effect,\n\tis_flushing_effect\n} from '../runtime.js';\nimport { equals, safe_equals } from './equality.js';\nimport {\n\tCLEAN,\n\tDERIVED,\n\tDIRTY,\n\tBRANCH_EFFECT,\n\tINSPECT_EFFECT,\n\tUNOWNED,\n\tMAYBE_DIRTY,\n\tBLOCK_EFFECT\n} from '../constants.js';\nimport * as e from '../errors.js';\n\nexport let inspect_effects = new Set();\n\n/**\n * @param {Set<any>} v\n */\nexport function set_inspect_effects(v) {\n\tinspect_effects = v;\n}\n\n/**\n * @template V\n * @param {V} v\n * @returns {Source<V>}\n */\nexport function source(v) {\n\treturn {\n\t\tf: 0, // TODO ideally we could skip this altogether, but it causes type errors\n\t\tv,\n\t\treactions: null,\n\t\tequals,\n\t\tversion: 0\n\t};\n}\n\n/**\n * @template V\n * @param {V} v\n */\nexport function state(v) {\n\treturn push_derived_source(source(v));\n}\n\n/**\n * @template V\n * @param {V} initial_value\n * @param {boolean} [immutable]\n * @returns {Source<V>}\n */\n/*#__NO_SIDE_EFFECTS__*/\nexport function mutable_source(initial_value, immutable = false) {\n\tconst s = source(initial_value);\n\tif (!immutable) {\n\t\ts.equals = safe_equals;\n\t}\n\n\t// bind the signal to the component context, in case we need to\n\t// track updates to trigger beforeUpdate/afterUpdate callbacks\n\tif (component_context !== null && component_context.l !== null) {\n\t\t(component_context.l.s ??= []).push(s);\n\t}\n\n\treturn s;\n}\n\n/**\n * @template V\n * @param {V} v\n * @param {boolean} [immutable]\n * @returns {Source<V>}\n */\nexport function mutable_state(v, immutable = false) {\n\treturn push_derived_source(mutable_source(v, immutable));\n}\n\n/**\n * @template V\n * @param {Source<V>} source\n */\n/*#__NO_SIDE_EFFECTS__*/\nfunction push_derived_source(source) {\n\tif (active_reaction !== null && (active_reaction.f & DERIVED) !== 0) {\n\t\tif (derived_sources === null) {\n\t\t\tset_derived_sources([source]);\n\t\t} else {\n\t\t\tderived_sources.push(source);\n\t\t}\n\t}\n\n\treturn source;\n}\n\n/**\n * @template V\n * @param {Value<V>} source\n * @param {V} value\n */\nexport function mutate(source, value) {\n\tset(\n\t\tsource,\n\t\tuntrack(() => get(source))\n\t);\n\treturn value;\n}\n\n/**\n * @template V\n * @param {Source<V>} source\n * @param {V} value\n * @returns {V}\n */\nexport function set(source, value) {\n\tif (\n\t\tactive_reaction !== null &&\n\t\tis_runes() &&\n\t\t(active_reaction.f & (DERIVED | BLOCK_EFFECT)) !== 0 &&\n\t\t// If the source was created locally within the current derived, then\n\t\t// we allow the mutation.\n\t\t(derived_sources === null || !derived_sources.includes(source))\n\t) {\n\t\te.state_unsafe_mutation();\n\t}\n\n\treturn internal_set(source, value);\n}\n\n/**\n * @template V\n * @param {Source<V>} source\n * @param {V} value\n * @returns {V}\n */\nexport function internal_set(source, value) {\n\tif (!source.equals(value)) {\n\t\tsource.v = value;\n\t\tsource.version = increment_version();\n\n\t\tmark_reactions(source, DIRTY);\n\n\t\t// If the current signal is running for the first time, it won't have any\n\t\t// reactions as we only allocate and assign the reactions after the signal\n\t\t// has fully executed. So in the case of ensuring it registers the reaction\n\t\t// properly for itself, we need to ensure the current effect actually gets\n\t\t// scheduled. i.e: `$effect(() => x++)`\n\t\tif (\n\t\t\tis_runes() &&\n\t\t\tactive_effect !== null &&\n\t\t\t(active_effect.f & CLEAN) !== 0 &&\n\t\t\t(active_effect.f & BRANCH_EFFECT) === 0\n\t\t) {\n\t\t\tif (new_deps !== null && new_deps.includes(source)) {\n\t\t\t\tset_signal_status(active_effect, DIRTY);\n\t\t\t\tschedule_effect(active_effect);\n\t\t\t} else {\n\t\t\t\tif (untracked_writes === null) {\n\t\t\t\t\tset_untracked_writes([source]);\n\t\t\t\t} else {\n\t\t\t\t\tuntracked_writes.push(source);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (DEV && inspect_effects.size > 0) {\n\t\t\tconst inspects = Array.from(inspect_effects);\n\t\t\tvar previously_flushing_effect = is_flushing_effect;\n\t\t\tset_is_flushing_effect(true);\n\t\t\ttry {\n\t\t\t\tfor (const effect of inspects) {\n\t\t\t\t\t// Mark clean inspect-effects as maybe dirty and then check their dirtiness\n\t\t\t\t\t// instead of just updating the effects - this way we avoid overfiring.\n\t\t\t\t\tif ((effect.f & CLEAN) !== 0) {\n\t\t\t\t\t\tset_signal_status(effect, MAYBE_DIRTY);\n\t\t\t\t\t}\n\t\t\t\t\tif (check_dirtiness(effect)) {\n\t\t\t\t\t\tupdate_effect(effect);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} finally {\n\t\t\t\tset_is_flushing_effect(previously_flushing_effect);\n\t\t\t}\n\t\t\tinspect_effects.clear();\n\t\t}\n\t}\n\n\treturn value;\n}\n\n/**\n * @param {Value} signal\n * @param {number} status should be DIRTY or MAYBE_DIRTY\n * @returns {void}\n */\nfunction mark_reactions(signal, status) {\n\tvar reactions = signal.reactions;\n\tif (reactions === null) return;\n\n\tvar runes = is_runes();\n\tvar length = reactions.length;\n\n\tfor (var i = 0; i < length; i++) {\n\t\tvar reaction = reactions[i];\n\t\tvar flags = reaction.f;\n\n\t\t// Skip any effects that are already dirty\n\t\tif ((flags & DIRTY) !== 0) continue;\n\n\t\t// In legacy mode, skip the current effect to prevent infinite loops\n\t\tif (!runes && reaction === active_effect) continue;\n\n\t\t// Inspect effects need to run immediately, so that the stack trace makes sense\n\t\tif (DEV && (flags & INSPECT_EFFECT) !== 0) {\n\t\t\tinspect_effects.add(reaction);\n\t\t\tcontinue;\n\t\t}\n\n\t\tset_signal_status(reaction, status);\n\n\t\t// If the signal a) was previously clean or b) is an unowned derived, then mark it\n\t\tif ((flags & (CLEAN | UNOWNED)) !== 0) {\n\t\t\tif ((flags & DERIVED) !== 0) {\n\t\t\t\tmark_reactions(/** @type {Derived} */ (reaction), MAYBE_DIRTY);\n\t\t\t} else {\n\t\t\t\tschedule_effect(/** @type {Effect} */ (reaction));\n\t\t\t}\n\t\t}\n\t}\n}\n","/** @import { Derived, Effect } from '#client' */\nimport { DEV } from 'esm-env';\nimport {\n\tCLEAN,\n\tDERIVED,\n\tDESTROYED,\n\tDIRTY,\n\tEFFECT_HAS_DERIVED,\n\tMAYBE_DIRTY,\n\tUNOWNED\n} from '../constants.js';\nimport {\n\tactive_reaction,\n\tactive_effect,\n\tremove_reactions,\n\tset_signal_status,\n\tskip_reaction,\n\tupdate_reaction,\n\tincrement_version,\n\tset_active_effect\n} from '../runtime.js';\nimport { equals, safe_equals } from './equality.js';\nimport * as e from '../errors.js';\nimport { destroy_effect } from './effects.js';\nimport { inspect_effects, set_inspect_effects } from './sources.js';\n\n/**\n * @template V\n * @param {() => V} fn\n * @returns {Derived<V>}\n */\n/*#__NO_SIDE_EFFECTS__*/\nexport function derived(fn) {\n\tvar flags = DERIVED | DIRTY;\n\n\tif (active_effect === null) {\n\t\tflags |= UNOWNED;\n\t} else {\n\t\t// Since deriveds are evaluated lazily, any effects created inside them are\n\t\t// created too late to ensure that the parent effect is added to the tree\n\t\tactive_effect.f |= EFFECT_HAS_DERIVED;\n\t}\n\n\t/** @type {Derived<V>} */\n\tconst signal = {\n\t\tchildren: null,\n\t\tdeps: null,\n\t\tequals,\n\t\tf: flags,\n\t\tfn,\n\t\treactions: null,\n\t\tv: /** @type {V} */ (null),\n\t\tversion: 0,\n\t\tparent: active_effect\n\t};\n\n\tif (active_reaction !== null && (active_reaction.f & DERIVED) !== 0) {\n\t\tvar derived = /** @type {Derived} */ (active_reaction);\n\t\t(derived.children ??= []).push(signal);\n\t}\n\n\treturn signal;\n}\n\n/**\n * @template V\n * @param {() => V} fn\n * @returns {Derived<V>}\n */\n/*#__NO_SIDE_EFFECTS__*/\nexport function derived_safe_equal(fn) {\n\tconst signal = derived(fn);\n\tsignal.equals = safe_equals;\n\treturn signal;\n}\n\n/**\n * @param {Derived} derived\n * @returns {void}\n */\nfunction destroy_derived_children(derived) {\n\tvar children = derived.children;\n\n\tif (children !== null) {\n\t\tderived.children = null;\n\n\t\tfor (var i = 0; i < children.length; i += 1) {\n\t\t\tvar child = children[i];\n\t\t\tif ((child.f & DERIVED) !== 0) {\n\t\t\t\tdestroy_derived(/** @type {Derived} */ (child));\n\t\t\t} else {\n\t\t\t\tdestroy_effect(/** @type {Effect} */ (child));\n\t\t\t}\n\t\t}\n\t}\n}\n\n/**\n * The currently updating deriveds, used to detect infinite recursion\n * in dev mode and provide a nicer error than 'too much recursion'\n * @type {Derived[]}\n */\nlet stack = [];\n\n/**\n * @template T\n * @param {Derived} derived\n * @returns {T}\n */\nexport function execute_derived(derived) {\n\tvar value;\n\tvar prev_active_effect = active_effect;\n\n\tset_active_effect(derived.parent);\n\n\tif (DEV) {\n\t\tlet prev_inspect_effects = inspect_effects;\n\t\tset_inspect_effects(new Set());\n\t\ttry {\n\t\t\tif (stack.includes(derived)) {\n\t\t\t\te.derived_references_self();\n\t\t\t}\n\n\t\t\tstack.push(derived);\n\n\t\t\tdestroy_derived_children(derived);\n\t\t\tvalue = update_reaction(derived);\n\t\t} finally {\n\t\t\tset_active_effect(prev_active_effect);\n\t\t\tset_inspect_effects(prev_inspect_effects);\n\t\t\tstack.pop();\n\t\t}\n\t} else {\n\t\ttry {\n\t\t\tdestroy_derived_children(derived);\n\t\t\tvalue = update_reaction(derived);\n\t\t} finally {\n\t\t\tset_active_effect(prev_active_effect);\n\t\t}\n\t}\n\n\treturn value;\n}\n\n/**\n * @param {Derived} derived\n * @returns {void}\n */\nexport function update_derived(derived) {\n\tvar value = execute_derived(derived);\n\tvar status =\n\t\t(skip_reaction || (derived.f & UNOWNED) !== 0) && derived.deps !== null ? MAYBE_DIRTY : CLEAN;\n\n\tset_signal_status(derived, status);\n\n\tif (!derived.equals(value)) {\n\t\tderived.v = value;\n\t\tderived.version = increment_version();\n\t}\n}\n\n/**\n * @param {Derived} signal\n * @returns {void}\n */\nexport function destroy_derived(signal) {\n\tdestroy_derived_children(signal);\n\tremove_reactions(signal, 0);\n\tset_signal_status(signal, DESTROYED);\n\n\t// TODO we need to ensure we remove the derived from any parent derives\n\tsignal.v = signal.children = signal.deps = signal.reactions = null;\n}\n","/** @import { ComponentContext, ComponentContextLegacy, Derived, Effect, Reaction, TemplateNode, TransitionManager } from '#client' */\nimport {\n\tcheck_dirtiness,\n\tcomponent_context,\n\tactive_effect,\n\tactive_reaction,\n\tdev_current_component_function,\n\tupdate_effect,\n\tget,\n\tis_destroying_effect,\n\tis_flushing_effect,\n\tremove_reactions,\n\tschedule_effect,\n\tset_active_reaction,\n\tset_is_destroying_effect,\n\tset_is_flushing_effect,\n\tset_signal_status,\n\tuntrack\n} from '../runtime.js';\nimport {\n\tDIRTY,\n\tBRANCH_EFFECT,\n\tRENDER_EFFECT,\n\tEFFECT,\n\tDESTROYED,\n\tINERT,\n\tEFFECT_RAN,\n\tBLOCK_EFFECT,\n\tROOT_EFFECT,\n\tEFFECT_TRANSPARENT,\n\tDERIVED,\n\tUNOWNED,\n\tCLEAN,\n\tINSPECT_EFFECT,\n\tHEAD_EFFECT,\n\tMAYBE_DIRTY,\n\tEFFECT_HAS_DERIVED\n} from '../constants.js';\nimport { set } from './sources.js';\nimport * as e from '../errors.js';\nimport { DEV } from 'esm-env';\nimport { define_property } from '../../shared/utils.js';\nimport { get_next_sibling } from '../dom/operations.js';\nimport { destroy_derived } from './deriveds.js';\n\n/**\n * @param {'$effect' | '$effect.pre' | '$inspect'} rune\n */\nexport function validate_effect(rune) {\n\tif (active_effect === null && active_reaction === null) {\n\t\te.effect_orphan(rune);\n\t}\n\n\tif (active_reaction !== null && (active_reaction.f & UNOWNED) !== 0) {\n\t\te.effect_in_unowned_derived();\n\t}\n\n\tif (is_destroying_effect) {\n\t\te.effect_in_teardown(rune);\n\t}\n}\n\n/**\n * @param {Effect} effect\n * @param {Effect} parent_effect\n */\nfunction push_effect(effect, parent_effect) {\n\tvar parent_last = parent_effect.last;\n\tif (parent_last === null) {\n\t\tparent_effect.last = parent_effect.first = effect;\n\t} else {\n\t\tparent_last.next = effect;\n\t\teffect.prev = parent_last;\n\t\tparent_effect.last = effect;\n\t}\n}\n\n/**\n * @param {number} type\n * @param {null | (() => void | (() => void))} fn\n * @param {boolean} sync\n * @param {boolean} push\n * @returns {Effect}\n */\nfunction create_effect(type, fn, sync, push = true) {\n\tvar is_root = (type & ROOT_EFFECT) !== 0;\n\tvar parent_effect = active_effect;\n\n\tif (DEV) {\n\t\t// Ensure the parent is never an inspect effect\n\t\twhile (parent_effect !== null && (parent_effect.f & INSPECT_EFFECT) !== 0) {\n\t\t\tparent_effect = parent_effect.parent;\n\t\t}\n\t}\n\n\t/** @type {Effect} */\n\tvar effect = {\n\t\tctx: component_context,\n\t\tdeps: null,\n\t\tderiveds: null,\n\t\tnodes_start: null,\n\t\tnodes_end: null,\n\t\tf: type | DIRTY,\n\t\tfirst: null,\n\t\tfn,\n\t\tlast: null,\n\t\tnext: null,\n\t\tparent: is_root ? null : parent_effect,\n\t\tprev: null,\n\t\tteardown: null,\n\t\ttransitions: null,\n\t\tversion: 0\n\t};\n\n\tif (DEV) {\n\t\teffect.component_function = dev_current_component_function;\n\t}\n\n\tif (sync) {\n\t\tvar previously_flushing_effect = is_flushing_effect;\n\n\t\ttry {\n\t\t\tset_is_flushing_effect(true);\n\t\t\tupdate_effect(effect);\n\t\t\teffect.f |= EFFECT_RAN;\n\t\t} catch (e) {\n\t\t\tdestroy_effect(effect);\n\t\t\tthrow e;\n\t\t} finally {\n\t\t\tset_is_flushing_effect(previously_flushing_effect);\n\t\t}\n\t} else if (fn !== null) {\n\t\tschedule_effect(effect);\n\t}\n\n\t// if an effect has no dependencies, no DOM and no teardown function,\n\t// don't bother adding it to the effect tree\n\tvar inert =\n\t\tsync &&\n\t\teffect.deps === null &&\n\t\teffect.first === null &&\n\t\teffect.nodes_start === null &&\n\t\teffect.teardown === null &&\n\t\t(effect.f & EFFECT_HAS_DERIVED) === 0;\n\n\tif (!inert && !is_root && push) {\n\t\tif (parent_effect !== null) {\n\t\t\tpush_effect(effect, parent_effect);\n\t\t}\n\n\t\t// if we're in a derived, add the effect there too\n\t\tif (active_reaction !== null && (active_reaction.f & DERIVED) !== 0) {\n\t\t\tvar derived = /** @type {Derived} */ (active_reaction);\n\t\t\t(derived.children ??= []).push(effect);\n\t\t}\n\t}\n\n\treturn effect;\n}\n\n/**\n * Internal representation of `$effect.tracking()`\n * @returns {boolean}\n */\nexport function effect_tracking() {\n\tif (active_reaction === null) {\n\t\treturn false;\n\t}\n\n\treturn (active_reaction.f & UNOWNED) === 0;\n}\n\n/**\n * @param {() => void} fn\n */\nexport function teardown(fn) {\n\tconst effect = create_effect(RENDER_EFFECT, null, false);\n\tset_signal_status(effect, CLEAN);\n\teffect.teardown = fn;\n\treturn effect;\n}\n\n/**\n * Internal representation of `$effect(...)`\n * @param {() => void | (() => void)} fn\n */\nexport function user_effect(fn) {\n\tvalidate_effect('$effect');\n\n\t// Non-nested `$effect(...)` in a component should be deferred\n\t// until the component is mounted\n\tvar defer =\n\t\tactive_effect !== null &&\n\t\t(active_effect.f & BRANCH_EFFECT) !== 0 &&\n\t\tcomponent_context !== null &&\n\t\t!component_context.m;\n\n\tif (DEV) {\n\t\tdefine_property(fn, 'name', {\n\t\t\tvalue: '$effect'\n\t\t});\n\t}\n\n\tif (defer) {\n\t\tvar context = /** @type {ComponentContext} */ (component_context);\n\t\t(context.e ??= []).push({\n\t\t\tfn,\n\t\t\teffect: active_effect,\n\t\t\treaction: active_reaction\n\t\t});\n\t} else {\n\t\tvar signal = effect(fn);\n\t\treturn signal;\n\t}\n}\n\n/**\n * Internal representation of `$effect.pre(...)`\n * @param {() => void | (() => void)} fn\n * @returns {Effect}\n */\nexport function user_pre_effect(fn) {\n\tvalidate_effect('$effect.pre');\n\tif (DEV) {\n\t\tdefine_property(fn, 'name', {\n\t\t\tvalue: '$effect.pre'\n\t\t});\n\t}\n\treturn render_effect(fn);\n}\n\n/** @param {() => void | (() => void)} fn */\nexport function inspect_effect(fn) {\n\treturn create_effect(INSPECT_EFFECT, fn, true);\n}\n\n/**\n * Internal representation of `$effect.root(...)`\n * @param {() => void | (() => void)} fn\n * @returns {() => void}\n */\nexport function effect_root(fn) {\n\tconst effect = create_effect(ROOT_EFFECT, fn, true);\n\treturn () => {\n\t\tdestroy_effect(effect);\n\t};\n}\n\n/**\n * @param {() => void | (() => void)} fn\n * @returns {Effect}\n */\nexport function effect(fn) {\n\treturn create_effect(EFFECT, fn, false);\n}\n\n/**\n * Internal representation of `$: ..`\n * @param {() => any} deps\n * @param {() => void | (() => void)} fn\n */\nexport function legacy_pre_effect(deps, fn) {\n\tvar context = /** @type {ComponentContextLegacy} */ (component_context);\n\n\t/** @type {{ effect: null | Effect, ran: boolean }} */\n\tvar token = { effect: null, ran: false };\n\tcontext.l.r1.push(token);\n\n\ttoken.effect = render_effect(() => {\n\t\tdeps();\n\n\t\t// If this legacy pre effect has already run before the end of the reset, then\n\t\t// bail out to emulate the same behavior.\n\t\tif (token.ran) return;\n\n\t\ttoken.ran = true;\n\t\tset(context.l.r2, true);\n\t\tuntrack(fn);\n\t});\n}\n\nexport function legacy_pre_effect_reset() {\n\tvar context = /** @type {ComponentContextLegacy} */ (component_context);\n\n\trender_effect(() => {\n\t\tif (!get(context.l.r2)) return;\n\n\t\t// Run dirty `$:` statements\n\t\tfor (var token of context.l.r1) {\n\t\t\tvar effect = token.effect;\n\n\t\t\t// If the effect is CLEAN, then make it MAYBE_DIRTY. This ensures we traverse through\n\t\t\t// the effects dependencies and correctly ensure each dependency is up-to-date.\n\t\t\tif ((effect.f & CLEAN) !== 0) {\n\t\t\t\tset_signal_status(effect, MAYBE_DIRTY);\n\t\t\t}\n\n\t\t\tif (check_dirtiness(effect)) {\n\t\t\t\tupdate_effect(effect);\n\t\t\t}\n\n\t\t\ttoken.ran = false;\n\t\t}\n\n\t\tcontext.l.r2.v = false; // set directly to avoid rerunning this effect\n\t});\n}\n\n/**\n * @param {() => void | (() => void)} fn\n * @returns {Effect}\n */\nexport function render_effect(fn) {\n\treturn create_effect(RENDER_EFFECT, fn, true);\n}\n\n/**\n * @param {() => void | (() => void)} fn\n * @returns {Effect}\n */\nexport function template_effect(fn) {\n\tif (DEV) {\n\t\tdefine_property(fn, 'name', {\n\t\t\tvalue: '{expression}'\n\t\t});\n\t}\n\treturn block(fn);\n}\n\n/**\n * @param {(() => void)} fn\n * @param {number} flags\n */\nexport function block(fn, flags = 0) {\n\treturn create_effect(RENDER_EFFECT | BLOCK_EFFECT | flags, fn, true);\n}\n\n/**\n * @param {(() => void)} fn\n * @param {boolean} [push]\n */\nexport function branch(fn, push = true) {\n\treturn create_effect(RENDER_EFFECT | BRANCH_EFFECT, fn, true, push);\n}\n\n/**\n * @param {Effect} effect\n */\nexport function execute_effect_teardown(effect) {\n\tvar teardown = effect.teardown;\n\tif (teardown !== null) {\n\t\tconst previously_destroying_effect = is_destroying_effect;\n\t\tconst previous_reaction = active_reaction;\n\t\tset_is_destroying_effect(true);\n\t\tset_active_reaction(null);\n\t\ttry {\n\t\t\tteardown.call(null);\n\t\t} finally {\n\t\t\tset_is_destroying_effect(previously_destroying_effect);\n\t\t\tset_active_reaction(previous_reaction);\n\t\t}\n\t}\n}\n\n/**\n * @param {Effect} signal\n * @returns {void}\n */\nexport function destroy_effect_deriveds(signal) {\n\tvar deriveds = signal.deriveds;\n\n\tif (deriveds !== null) {\n\t\tsignal.deriveds = null;\n\n\t\tfor (var i = 0; i < deriveds.length; i += 1) {\n\t\t\tdestroy_derived(deriveds[i]);\n\t\t}\n\t}\n}\n\n/**\n * @param {Effect} signal\n * @param {boolean} remove_dom\n * @returns {void}\n */\nexport function destroy_effect_children(signal, remove_dom = false) {\n\tvar effect = signal.first;\n\tsignal.first = signal.last = null;\n\n\twhile (effect !== null) {\n\t\tvar next = effect.next;\n\t\tdestroy_effect(effect, remove_dom);\n\t\teffect = next;\n\t}\n}\n\n/**\n * @param {Effect} signal\n * @returns {void}\n */\nexport function destroy_block_effect_children(signal) {\n\tvar effect = signal.first;\n\n\twhile (effect !== null) {\n\t\tvar next = effect.next;\n\t\tif ((effect.f & BRANCH_EFFECT) === 0) {\n\t\t\tdestroy_effect(effect);\n\t\t}\n\t\teffect = next;\n\t}\n}\n\n/**\n * @param {Effect} effect\n * @param {boolean} [remove_dom]\n * @returns {void}\n */\nexport function destroy_effect(effect, remove_dom = true) {\n\tvar removed = false;\n\n\tif ((remove_dom || (effect.f & HEAD_EFFECT) !== 0) && effect.nodes_start !== null) {\n\t\t/** @type {TemplateNode | null} */\n\t\tvar node = effect.nodes_start;\n\t\tvar end = effect.nodes_end;\n\n\t\twhile (node !== null) {\n\t\t\t/** @type {TemplateNode | null} */\n\t\t\tvar next = node === end ? null : /** @type {TemplateNode} */ (get_next_sibling(node));\n\n\t\t\tnode.remove();\n\t\t\tnode = next;\n\t\t}\n\n\t\tremoved = true;\n\t}\n\n\tdestroy_effect_deriveds(effect);\n\tdestroy_effect_children(effect, remove_dom && !removed);\n\tremove_reactions(effect, 0);\n\tset_signal_status(effect, DESTROYED);\n\n\tvar transitions = effect.transitions;\n\n\tif (transitions !== null) {\n\t\tfor (const transition of transitions) {\n\t\t\ttransition.stop();\n\t\t}\n\t}\n\n\texecute_effect_teardown(effect);\n\n\tvar parent = effect.parent;\n\n\t// If the parent doesn't have any children, then skip this work altogether\n\tif (parent !== null && parent.first !== null) {\n\t\tunlink_effect(effect);\n\t}\n\n\tif (DEV) {\n\t\teffect.component_function = null;\n\t}\n\n\t// `first` and `child` are nulled out in destroy_effect_children\n\teffect.next =\n\t\teffect.prev =\n\t\teffect.teardown =\n\t\teffect.ctx =\n\t\teffect.deps =\n\t\teffect.parent =\n\t\teffect.fn =\n\t\teffect.nodes_start =\n\t\teffect.nodes_end =\n\t\t\tnull;\n}\n\n/**\n * Detach an effect from the effect tree, freeing up memory and\n * reducing the amount of work that happens on subsequent traversals\n * @param {Effect} effect\n */\nexport function unlink_effect(effect) {\n\tvar parent = effect.parent;\n\tvar prev = effect.prev;\n\tvar next = effect.next;\n\n\tif (prev !== null) prev.next = next;\n\tif (next !== null) next.prev = prev;\n\n\tif (parent !== null) {\n\t\tif (parent.first === effect) parent.first = next;\n\t\tif (parent.last === effect) parent.last = prev;\n\t}\n}\n\n/**\n * When a block effect is removed, we don't immediately destroy it or yank it\n * out of the DOM, because it might have transitions. Instead, we 'pause' it.\n * It stays around (in memory, and in the DOM) until outro transitions have\n * completed, and if the state change is reversed then we _resume_ it.\n * A paused effect does not update, and the DOM subtree becomes inert.\n * @param {Effect} effect\n * @param {() => void} [callback]\n */\nexport function pause_effect(effect, callback) {\n\t/** @type {TransitionManager[]} */\n\tvar transitions = [];\n\n\tpause_children(effect, transitions, true);\n\n\trun_out_transitions(transitions, () => {\n\t\tdestroy_effect(effect);\n\t\tif (callback) callback();\n\t});\n}\n\n/**\n * @param {TransitionManager[]} transitions\n * @param {() => void} fn\n */\nexport function run_out_transitions(transitions, fn) {\n\tvar remaining = transitions.length;\n\tif (remaining > 0) {\n\t\tvar check = () => --remaining || fn();\n\t\tfor (var transition of transitions) {\n\t\t\ttransition.out(check);\n\t\t}\n\t} else {\n\t\tfn();\n\t}\n}\n\n/**\n * @param {Effect} effect\n * @param {TransitionManager[]} transitions\n * @param {boolean} local\n */\nexport function pause_children(effect, transitions, local) {\n\tif ((effect.f & INERT) !== 0) return;\n\teffect.f ^= INERT;\n\n\tif (effect.transitions !== null) {\n\t\tfor (const transition of effect.transitions) {\n\t\t\tif (transition.is_global || local) {\n\t\t\t\ttransitions.push(transition);\n\t\t\t}\n\t\t}\n\t}\n\n\tvar child = effect.first;\n\n\twhile (child !== null) {\n\t\tvar sibling = child.next;\n\t\tvar transparent = (child.f & EFFECT_TRANSPARENT) !== 0 || (child.f & BRANCH_EFFECT) !== 0;\n\t\t// TODO we don't need to call pause_children recursively with a linked list in place\n\t\t// it's slightly more involved though as we have to account for `transparent` changing\n\t\t// through the tree.\n\t\tpause_children(child, transitions, transparent ? local : false);\n\t\tchild = sibling;\n\t}\n}\n\n/**\n * The opposite of `pause_effect`. We call this if (for example)\n * `x` becomes falsy then truthy: `{#if x}...{/if}`\n * @param {Effect} effect\n */\nexport function resume_effect(effect) {\n\tresume_children(effect, true);\n}\n\n/**\n * @param {Effect} effect\n * @param {boolean} local\n */\nfunction resume_children(effect, local) {\n\tif ((effect.f & INERT) === 0) return;\n\teffect.f ^= INERT;\n\n\t// If a dependency of this effect changed while it was paused,\n\t// apply the change now\n\tif (check_dirtiness(effect)) {\n\t\tupdate_effect(effect);\n\t}\n\n\tvar child = effect.first;\n\n\twhile (child !== null) {\n\t\tvar sibling = child.next;\n\t\tvar transparent = (child.f & EFFECT_TRANSPARENT) !== 0 || (child.f & BRANCH_EFFECT) !== 0;\n\t\t// TODO we don't need to call resume_children recursively with a linked list in place\n\t\t// it's slightly more involved though as we have to account for `transparent` changing\n\t\t// through the tree.\n\t\tresume_children(child, transparent ? local : false);\n\t\tchild = sibling;\n\t}\n\n\tif (effect.transitions !== null) {\n\t\tfor (const transition of effect.transitions) {\n\t\t\tif (transition.is_global || local) {\n\t\t\t\ttransition.in();\n\t\t\t}\n\t\t}\n\t}\n}\n","import { run_all } from '../../shared/utils.js';\n\n// Fallback for when requestIdleCallback is not available\nconst request_idle_callback =\n\ttypeof requestIdleCallback === 'undefined'\n\t\t? (/** @type {() => void} */ cb) => setTimeout(cb, 1)\n\t\t: requestIdleCallback;\n\nlet is_micro_task_queued = false;\nlet is_idle_task_queued = false;\n\n/** @type {Array<() => void>} */\nlet current_queued_micro_tasks = [];\n/** @type {Array<() => void>} */\nlet current_queued_idle_tasks = [];\n\nfunction process_micro_tasks() {\n\tis_micro_task_queued = false;\n\tconst tasks = current_queued_micro_tasks.slice();\n\tcurrent_queued_micro_tasks = [];\n\trun_all(tasks);\n}\n\nfunction process_idle_tasks() {\n\tis_idle_task_queued = false;\n\tconst tasks = current_queued_idle_tasks.slice();\n\tcurrent_queued_idle_tasks = [];\n\trun_all(tasks);\n}\n\n/**\n * @param {() => void} fn\n */\nexport function queue_micro_task(fn) {\n\tif (!is_micro_task_queued) {\n\t\tis_micro_task_queued = true;\n\t\tqueueMicrotask(process_micro_tasks);\n\t}\n\tcurrent_queued_micro_tasks.push(fn);\n}\n\n/**\n * @param {() => void} fn\n */\nexport function queue_idle_task(fn) {\n\tif (!is_idle_task_queued) {\n\t\tis_idle_task_queued = true;\n\t\trequest_idle_callback(process_idle_tasks);\n\t}\n\tcurrent_queued_idle_tasks.push(fn);\n}\n\n/**\n * Synchronously run any queued tasks.\n */\nexport function flush_tasks() {\n\tif (is_micro_task_queued) {\n\t\tprocess_micro_tasks();\n\t}\n\tif (is_idle_task_queued) {\n\t\tprocess_idle_tasks();\n\t}\n}\n","/* This file is generated by scripts/process-messages/index.js. Do not edit! */\n\nimport { DEV } from 'esm-env';\n\n/**\n * Cannot use `{@render children(...)}` if the parent component uses `let:` directives. Consider using a named snippet instead\n * @returns {never}\n */\nexport function invalid_default_snippet() {\n\tif (DEV) {\n\t\tconst error = new Error(`invalid_default_snippet\\nCannot use \\`{@render children(...)}\\` if the parent component uses \\`let:\\` directives. Consider using a named snippet instead`);\n\n\t\terror.name = 'Svelte error';\n\t\tthrow error;\n\t} else {\n\t\t// TODO print a link to the documentation\n\t\tthrow new Error(\"invalid_default_snippet\");\n\t}\n}\n\n/**\n * `%name%(...)` can only be used during component initialisation\n * @param {string} name\n * @returns {never}\n */\nexport function lifecycle_outside_component(name) {\n\tif (DEV) {\n\t\tconst error = new Error(`lifecycle_outside_component\\n\\`${name}(...)\\` can only be used during component initialisation`);\n\n\t\terror.name = 'Svelte error';\n\t\tthrow error;\n\t} else {\n\t\t// TODO print a link to the documentation\n\t\tthrow new Error(\"lifecycle_outside_component\");\n\t}\n}\n\n/**\n * `%name%` is not a store with a `subscribe` method\n * @param {string} name\n * @returns {never}\n */\nexport function store_invalid_shape(name) {\n\tif (DEV) {\n\t\tconst error = new Error(`store_invalid_shape\\n\\`${name}\\` is not a store with a \\`subscribe\\` method`);\n\n\t\terror.name = 'Svelte error';\n\t\tthrow error;\n\t} else {\n\t\t// TODO print a link to the documentation\n\t\tthrow new Error(\"store_invalid_shape\");\n\t}\n}\n\n/**\n * The `this` prop on `<svelte:element>` must be a string, if defined\n * @returns {never}\n */\nexport function svelte_element_invalid_this_value() {\n\tif (DEV) {\n\t\tconst error = new Error(`svelte_element_invalid_this_value\\nThe \\`this\\` prop on \\`<svelte:element>\\` must be a string, if defined`);\n\n\t\terror.name = 'Svelte error';\n\t\tthrow error;\n\t} else {\n\t\t// TODO print a link to the documentation\n\t\tthrow new Error(\"svelte_element_invalid_this_value\");\n\t}\n}","/** @import { ComponentContext, Derived, Effect, Reaction, Signal, Source, Value } from '#client' */\nimport { DEV } from 'esm-env';\nimport { define_property, get_descriptors, get_prototype_of } from '../shared/utils.js';\nimport {\n\tdestroy_block_effect_children,\n\tdestroy_effect_children,\n\tdestroy_effect_deriveds,\n\teffect,\n\texecute_effect_teardown,\n\tunlink_effect\n} from './reactivity/effects.js';\nimport {\n\tEFFECT,\n\tRENDER_EFFECT,\n\tDIRTY,\n\tMAYBE_DIRTY,\n\tCLEAN,\n\tDERIVED,\n\tUNOWNED,\n\tDESTROYED,\n\tINERT,\n\tBRANCH_EFFECT,\n\tSTATE_SYMBOL,\n\tBLOCK_EFFECT,\n\tROOT_EFFECT,\n\tLEGACY_DERIVED_PROP,\n\tDISCONNECTED\n} from './constants.js';\nimport { flush_tasks } from './dom/task.js';\nimport { add_owner } from './dev/ownership.js';\nimport { mutate, set, source } from './reactivity/sources.js';\nimport { destroy_derived, execute_derived, update_derived } from './reactivity/deriveds.js';\nimport * as e from './errors.js';\nimport { lifecycle_outside_component } from '../shared/errors.js';\nimport { FILENAME } from '../../constants.js';\n\nconst FLUSH_MICROTASK = 0;\nconst FLUSH_SYNC = 1;\n\n// Used for DEV time error handling\n/** @param {WeakSet<Error>} value */\nconst handled_errors = new WeakSet();\n// Used for controlling the flush of effects.\nlet scheduler_mode = FLUSH_MICROTASK;\n// Used for handling scheduling\nlet is_micro_task_queued = false;\n\nexport let is_flushing_effect = false;\nexport let is_destroying_effect = false;\n\n/** @param {boolean} value */\nexport function set_is_flushing_effect(value) {\n\tis_flushing_effect = value;\n}\n\n/** @param {boolean} value */\nexport function set_is_destroying_effect(value) {\n\tis_destroying_effect = value;\n}\n\n// Handle effect queues\n\n/** @type {Effect[]} */\nlet queued_root_effects = [];\n\nlet flush_count = 0;\n/** @type {Effect[]} Stack of effects, dev only */\nlet dev_effect_stack = [];\n// Handle signal reactivity tree dependencies and reactions\n\n/** @type {null | Reaction} */\nexport let active_reaction = null;\n\n/** @param {null | Reaction} reaction */\nexport function set_active_reaction(reaction) {\n\tactive_reaction = reaction;\n}\n\n/** @type {null | Effect} */\nexport let active_effect = null;\n\n/** @param {null | Effect} effect */\nexport function set_active_effect(effect) {\n\tactive_effect = effect;\n}\n\n/**\n * When sources are created within a derived, we record them so that we can safely allow\n * local mutations to these sources without the side-effect error being invoked unnecessarily.\n * @type {null | Source[]}\n */\nexport let derived_sources = null;\n\n/**\n * @param {Source[] | null} sources\n */\nexport function set_derived_sources(sources) {\n\tderived_sources = sources;\n}\n\n/**\n * The dependencies of the reaction that is currently being executed. In many cases,\n * the dependencies are unchanged between runs, and so this will be `null` unless\n * and until a new dependency is accessed  we track this via `skipped_deps`\n * @type {null | Value[]}\n */\nexport let new_deps = null;\n\nlet skipped_deps = 0;\n\n/**\n * Tracks writes that the effect it's executed in doesn't listen to yet,\n * so that the dependency can be added to the effect later on if it then reads it\n * @type {null | Source[]}\n */\nexport let untracked_writes = null;\n\n/** @param {null | Source[]} value */\nexport function set_untracked_writes(value) {\n\tuntracked_writes = value;\n}\n\n/** @type {number} Used by sources and deriveds for handling updates to unowned deriveds */\nlet current_version = 0;\n\n// If we are working with a get() chain that has no active container,\n// to prevent memory leaks, we skip adding the reaction.\nexport let skip_reaction = false;\n// Handle collecting all signals which are read during a specific time frame\nexport let is_signals_recorded = false;\nlet captured_signals = new Set();\n\n// Handling runtime component context\n/** @type {ComponentContext | null} */\nexport let component_context = null;\n\n/** @param {ComponentContext | null} context */\nexport function set_component_context(context) {\n\tcomponent_context = context;\n}\n\n/**\n * The current component function. Different from current component context:\n * ```html\n * <!-- App.svelte -->\n * <Foo>\n *   <Bar /> <!-- context == Foo.svelte, function == App.svelte -->\n * </Foo>\n * ```\n * @type {ComponentContext['function']}\n */\nexport let dev_current_component_function = null;\n\n/** @param {ComponentContext['function']} fn */\nexport function set_dev_current_component_function(fn) {\n\tdev_current_component_function = fn;\n}\n\nexport function increment_version() {\n\treturn ++current_version;\n}\n\n/** @returns {boolean} */\nexport function is_runes() {\n\treturn component_context !== null && component_context.l === null;\n}\n\n/**\n * Determines whether a derived or effect is dirty.\n * If it is MAYBE_DIRTY, will set the status to CLEAN\n * @param {Reaction} reaction\n * @returns {boolean}\n */\nexport function check_dirtiness(reaction) {\n\tvar flags = reaction.f;\n\n\tif ((flags & DIRTY) !== 0) {\n\t\treturn true;\n\t}\n\n\tif ((flags & MAYBE_DIRTY) !== 0) {\n\t\tvar dependencies = reaction.deps;\n\t\tvar is_unowned = (flags & UNOWNED) !== 0;\n\n\t\tif (dependencies !== null) {\n\t\t\tvar i;\n\n\t\t\tif ((flags & DISCONNECTED) !== 0) {\n\t\t\t\tfor (i = 0; i < dependencies.length; i++) {\n\t\t\t\t\t(dependencies[i].reactions ??= []).push(reaction);\n\t\t\t\t}\n\n\t\t\t\treaction.f ^= DISCONNECTED;\n\t\t\t}\n\n\t\t\tfor (i = 0; i < dependencies.length; i++) {\n\t\t\t\tvar dependency = dependencies[i];\n\n\t\t\t\tif (check_dirtiness(/** @type {Derived} */ (dependency))) {\n\t\t\t\t\tupdate_derived(/** @type {Derived} */ (dependency));\n\t\t\t\t}\n\n\t\t\t\t// If we are working with an unowned signal as part of an effect (due to !skip_reaction)\n\t\t\t\t// and the version hasn't changed, we still need to check that this reaction\n\t\t\t\t// is linked to the dependency source  otherwise future updates will not be caught.\n\t\t\t\tif (\n\t\t\t\t\tis_unowned &&\n\t\t\t\t\tactive_effect !== null &&\n\t\t\t\t\t!skip_reaction &&\n\t\t\t\t\t!dependency?.reactions?.includes(reaction)\n\t\t\t\t) {\n\t\t\t\t\t(dependency.reactions ??= []).push(reaction);\n\t\t\t\t}\n\n\t\t\t\tif (dependency.version > reaction.version) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Unowned signals should never be marked as clean.\n\t\tif (!is_unowned) {\n\t\t\tset_signal_status(reaction, CLEAN);\n\t\t}\n\t}\n\n\treturn false;\n}\n\n/**\n * @param {Error} error\n * @param {Effect} effect\n * @param {ComponentContext | null} component_context\n */\nfunction handle_error(error, effect, component_context) {\n\t// Given we don't yet have error boundaries, we will just always throw.\n\tif (!DEV || handled_errors.has(error) || component_context === null) {\n\t\tthrow error;\n\t}\n\n\tconst component_stack = [];\n\n\tconst effect_name = effect.fn?.name;\n\n\tif (effect_name) {\n\t\tcomponent_stack.push(effect_name);\n\t}\n\n\t/** @type {ComponentContext | null} */\n\tlet current_context = component_context;\n\n\twhile (current_context !== null) {\n\t\tif (DEV) {\n\t\t\t/** @type {string} */\n\t\t\tvar filename = current_context.function?.[FILENAME];\n\n\t\t\tif (filename) {\n\t\t\t\tconst file = filename.split('/').pop();\n\t\t\t\tcomponent_stack.push(file);\n\t\t\t}\n\t\t}\n\n\t\tcurrent_context = current_context.p;\n\t}\n\n\tconst indent = /Firefox/.test(navigator.userAgent) ? '  ' : '\\t';\n\tdefine_property(error, 'message', {\n\t\tvalue: error.message + `\\n${component_stack.map((name) => `\\n${indent}in ${name}`).join('')}\\n`\n\t});\n\n\tconst stack = error.stack;\n\n\t// Filter out internal files from callstack\n\tif (stack) {\n\t\tconst lines = stack.split('\\n');\n\t\tconst new_lines = [];\n\t\tfor (let i = 0; i < lines.length; i++) {\n\t\t\tconst line = lines[i];\n\t\t\tif (line.includes('svelte/src/internal')) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tnew_lines.push(line);\n\t\t}\n\t\tdefine_property(error, 'stack', {\n\t\t\tvalue: error.stack + new_lines.join('\\n')\n\t\t});\n\t}\n\n\thandled_errors.add(error);\n\tthrow error;\n}\n\n/**\n * @template V\n * @param {Reaction} reaction\n * @returns {V}\n */\nexport function update_reaction(reaction) {\n\tvar previous_deps = new_deps;\n\tvar previous_skipped_deps = skipped_deps;\n\tvar previous_untracked_writes = untracked_writes;\n\tvar previous_reaction = active_reaction;\n\tvar previous_skip_reaction = skip_reaction;\n\tvar prev_derived_sources = derived_sources;\n\tvar flags = reaction.f;\n\n\tnew_deps = /** @type {null | Value[]} */ (null);\n\tskipped_deps = 0;\n\tuntracked_writes = null;\n\tactive_reaction = (flags & (BRANCH_EFFECT | ROOT_EFFECT)) === 0 ? reaction : null;\n\tskip_reaction = !is_flushing_effect && (flags & UNOWNED) !== 0;\n\tderived_sources = null;\n\n\ttry {\n\t\tvar result = /** @type {Function} */ (0, reaction.fn)();\n\t\tvar deps = reaction.deps;\n\n\t\tif (new_deps !== null) {\n\t\t\tvar i;\n\n\t\t\tremove_reactions(reaction, skipped_deps);\n\n\t\t\tif (deps !== null && skipped_deps > 0) {\n\t\t\t\tdeps.length = skipped_deps + new_deps.length;\n\t\t\t\tfor (i = 0; i < new_deps.length; i++) {\n\t\t\t\t\tdeps[skipped_deps + i] = new_deps[i];\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\treaction.deps = deps = new_deps;\n\t\t\t}\n\n\t\t\tif (!skip_reaction) {\n\t\t\t\tfor (i = skipped_deps; i < deps.length; i++) {\n\t\t\t\t\t(deps[i].reactions ??= []).push(reaction);\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (deps !== null && skipped_deps < deps.length) {\n\t\t\tremove_reactions(reaction, skipped_deps);\n\t\t\tdeps.length = skipped_deps;\n\t\t}\n\n\t\treturn result;\n\t} finally {\n\t\tnew_deps = previous_deps;\n\t\tskipped_deps = previous_skipped_deps;\n\t\tuntracked_writes = previous_untracked_writes;\n\t\tactive_reaction = previous_reaction;\n\t\tskip_reaction = previous_skip_reaction;\n\t\tderived_sources = prev_derived_sources;\n\t}\n}\n\n/**\n * @template V\n * @param {Reaction} signal\n * @param {Value<V>} dependency\n * @returns {void}\n */\nfunction remove_reaction(signal, dependency) {\n\tlet reactions = dependency.reactions;\n\tif (reactions !== null) {\n\t\tvar index = reactions.indexOf(signal);\n\t\tif (index !== -1) {\n\t\t\tvar new_length = reactions.length - 1;\n\t\t\tif (new_length === 0) {\n\t\t\t\treactions = dependency.reactions = null;\n\t\t\t} else {\n\t\t\t\t// Swap with last element and then remove.\n\t\t\t\treactions[index] = reactions[new_length];\n\t\t\t\treactions.pop();\n\t\t\t}\n\t\t}\n\t}\n\t// If the derived has no reactions, then we can disconnect it from the graph,\n\t// allowing it to either reconnect in the future, or be GC'd by the VM.\n\tif (\n\t\treactions === null &&\n\t\t(dependency.f & DERIVED) !== 0 &&\n\t\t// Destroying a child effect while updating a parent effect can cause a dependency to appear\n\t\t// to be unused, when in fact it is used by the currently-updating parent. Checking `new_deps`\n\t\t// allows us to skip the expensive work of disconnecting and immediately reconnecting it\n\t\t(new_deps === null || !new_deps.includes(dependency))\n\t) {\n\t\tset_signal_status(dependency, MAYBE_DIRTY);\n\t\t// If we are working with a derived that is owned by an effect, then mark it as being\n\t\t// disconnected.\n\t\tif ((dependency.f & (UNOWNED | DISCONNECTED)) === 0) {\n\t\t\tdependency.f ^= DISCONNECTED;\n\t\t}\n\t\tremove_reactions(/** @type {Derived} **/ (dependency), 0);\n\t}\n}\n\n/**\n * @param {Reaction} signal\n * @param {number} start_index\n * @returns {void}\n */\nexport function remove_reactions(signal, start_index) {\n\tvar dependencies = signal.deps;\n\tif (dependencies === null) return;\n\n\tfor (var i = start_index; i < dependencies.length; i++) {\n\t\tremove_reaction(signal, dependencies[i]);\n\t}\n}\n\n/**\n * @param {Effect} effect\n * @returns {void}\n */\nexport function update_effect(effect) {\n\tvar flags = effect.f;\n\n\tif ((flags & DESTROYED) !== 0) {\n\t\treturn;\n\t}\n\n\tset_signal_status(effect, CLEAN);\n\n\tvar previous_effect = active_effect;\n\tvar previous_component_context = component_context;\n\n\tactive_effect = effect;\n\tcomponent_context = effect.ctx;\n\n\tif (DEV) {\n\t\tvar previous_component_fn = dev_current_component_function;\n\t\tdev_current_component_function = effect.component_function;\n\t}\n\n\ttry {\n\t\tdestroy_effect_deriveds(effect);\n\t\tif ((flags & BLOCK_EFFECT) !== 0) {\n\t\t\tdestroy_block_effect_children(effect);\n\t\t} else {\n\t\t\tdestroy_effect_children(effect);\n\t\t}\n\n\t\texecute_effect_teardown(effect);\n\t\tvar teardown = update_reaction(effect);\n\t\teffect.teardown = typeof teardown === 'function' ? teardown : null;\n\t\teffect.version = current_version;\n\n\t\tif (DEV) {\n\t\t\tdev_effect_stack.push(effect);\n\t\t}\n\t} catch (error) {\n\t\thandle_error(/** @type {Error} */ (error), effect, previous_component_context);\n\t} finally {\n\t\tactive_effect = previous_effect;\n\t\tcomponent_context = previous_component_context;\n\n\t\tif (DEV) {\n\t\t\tdev_current_component_function = previous_component_fn;\n\t\t}\n\t}\n}\n\nfunction infinite_loop_guard() {\n\tif (flush_count > 1000) {\n\t\tflush_count = 0;\n\t\tif (DEV) {\n\t\t\ttry {\n\t\t\t\te.effect_update_depth_exceeded();\n\t\t\t} catch (error) {\n\t\t\t\t// stack is garbage, ignore. Instead add a console.error message.\n\t\t\t\tdefine_property(error, 'stack', {\n\t\t\t\t\tvalue: ''\n\t\t\t\t});\n\t\t\t\t// eslint-disable-next-line no-console\n\t\t\t\tconsole.error(\n\t\t\t\t\t'Last ten effects were: ',\n\t\t\t\t\tdev_effect_stack.slice(-10).map((d) => d.fn)\n\t\t\t\t);\n\t\t\t\tdev_effect_stack = [];\n\t\t\t\tthrow error;\n\t\t\t}\n\t\t} else {\n\t\t\te.effect_update_depth_exceeded();\n\t\t}\n\t}\n\tflush_count++;\n}\n\n/**\n * @param {Array<Effect>} root_effects\n * @returns {void}\n */\nfunction flush_queued_root_effects(root_effects) {\n\tvar length = root_effects.length;\n\tif (length === 0) {\n\t\treturn;\n\t}\n\tinfinite_loop_guard();\n\n\tvar previously_flushing_effect = is_flushing_effect;\n\tis_flushing_effect = true;\n\n\ttry {\n\t\tfor (var i = 0; i < length; i++) {\n\t\t\tvar effect = root_effects[i];\n\n\t\t\tif ((effect.f & CLEAN) === 0) {\n\t\t\t\teffect.f ^= CLEAN;\n\t\t\t}\n\n\t\t\t/** @type {Effect[]} */\n\t\t\tvar collected_effects = [];\n\n\t\t\tprocess_effects(effect, collected_effects);\n\t\t\tflush_queued_effects(collected_effects);\n\t\t}\n\t} finally {\n\t\tis_flushing_effect = previously_flushing_effect;\n\t}\n}\n\n/**\n * @param {Array<Effect>} effects\n * @returns {void}\n */\nfunction flush_queued_effects(effects) {\n\tvar length = effects.length;\n\tif (length === 0) return;\n\n\tfor (var i = 0; i < length; i++) {\n\t\tvar effect = effects[i];\n\n\t\tif ((effect.f & (DESTROYED | INERT)) === 0 && check_dirtiness(effect)) {\n\t\t\tupdate_effect(effect);\n\n\t\t\t// Effects with no dependencies or teardown do not get added to the effect tree.\n\t\t\t// Deferred effects (e.g. `$effect(...)`) _are_ added to the tree because we\n\t\t\t// don't know if we need to keep them until they are executed. Doing the check\n\t\t\t// here (rather than in `update_effect`) allows us to skip the work for\n\t\t\t// immediate effects.\n\t\t\tif (effect.deps === null && effect.first === null && effect.nodes_start === null) {\n\t\t\t\tif (effect.teardown === null) {\n\t\t\t\t\t// remove this effect from the graph\n\t\t\t\t\tunlink_effect(effect);\n\t\t\t\t} else {\n\t\t\t\t\t// keep the effect in the graph, but free up some memory\n\t\t\t\t\teffect.fn = null;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunction process_deferred() {\n\tis_micro_task_queued = false;\n\tif (flush_count > 1001) {\n\t\treturn;\n\t}\n\tconst previous_queued_root_effects = queued_root_effects;\n\tqueued_root_effects = [];\n\tflush_queued_root_effects(previous_queued_root_effects);\n\tif (!is_micro_task_queued) {\n\t\tflush_count = 0;\n\t\tif (DEV) {\n\t\t\tdev_effect_stack = [];\n\t\t}\n\t}\n}\n\n/**\n * @param {Effect} signal\n * @returns {void}\n */\nexport function schedule_effect(signal) {\n\tif (scheduler_mode === FLUSH_MICROTASK) {\n\t\tif (!is_micro_task_queued) {\n\t\t\tis_micro_task_queued = true;\n\t\t\tqueueMicrotask(process_deferred);\n\t\t}\n\t}\n\n\tvar effect = signal;\n\n\twhile (effect.parent !== null) {\n\t\teffect = effect.parent;\n\t\tvar flags = effect.f;\n\n\t\tif ((flags & (ROOT_EFFECT | BRANCH_EFFECT)) !== 0) {\n\t\t\tif ((flags & CLEAN) === 0) return;\n\t\t\teffect.f ^= CLEAN;\n\t\t}\n\t}\n\n\tqueued_root_effects.push(effect);\n}\n\n/**\n *\n * This function both runs render effects and collects user effects in topological order\n * from the starting effect passed in. Effects will be collected when they match the filtered\n * bitwise flag passed in only. The collected effects array will be populated with all the user\n * effects to be flushed.\n *\n * @param {Effect} effect\n * @param {Effect[]} collected_effects\n * @returns {void}\n */\nfunction process_effects(effect, collected_effects) {\n\tvar current_effect = effect.first;\n\tvar effects = [];\n\n\tmain_loop: while (current_effect !== null) {\n\t\tvar flags = current_effect.f;\n\t\tvar is_branch = (flags & BRANCH_EFFECT) !== 0;\n\t\tvar is_skippable_branch = is_branch && (flags & CLEAN) !== 0;\n\n\t\tif (!is_skippable_branch && (flags & INERT) === 0) {\n\t\t\tif ((flags & RENDER_EFFECT) !== 0) {\n\t\t\t\tif (is_branch) {\n\t\t\t\t\tcurrent_effect.f ^= CLEAN;\n\t\t\t\t} else if (check_dirtiness(current_effect)) {\n\t\t\t\t\tupdate_effect(current_effect);\n\t\t\t\t}\n\n\t\t\t\tvar child = current_effect.first;\n\n\t\t\t\tif (child !== null) {\n\t\t\t\t\tcurrent_effect = child;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t} else if ((flags & EFFECT) !== 0) {\n\t\t\t\teffects.push(current_effect);\n\t\t\t}\n\t\t}\n\n\t\tvar sibling = current_effect.next;\n\n\t\tif (sibling === null) {\n\t\t\tlet parent = current_effect.parent;\n\n\t\t\twhile (parent !== null) {\n\t\t\t\tif (effect === parent) {\n\t\t\t\t\tbreak main_loop;\n\t\t\t\t}\n\t\t\t\tvar parent_sibling = parent.next;\n\t\t\t\tif (parent_sibling !== null) {\n\t\t\t\t\tcurrent_effect = parent_sibling;\n\t\t\t\t\tcontinue main_loop;\n\t\t\t\t}\n\t\t\t\tparent = parent.parent;\n\t\t\t}\n\t\t}\n\n\t\tcurrent_effect = sibling;\n\t}\n\n\t// We might be dealing with many effects here, far more than can be spread into\n\t// an array push call (callstack overflow). So let's deal with each effect in a loop.\n\tfor (var i = 0; i < effects.length; i++) {\n\t\tchild = effects[i];\n\t\tcollected_effects.push(child);\n\t\tprocess_effects(child, collected_effects);\n\t}\n}\n\n/**\n * Internal version of `flushSync` with the option to not flush previous effects.\n * Returns the result of the passed function, if given.\n * @param {() => any} [fn]\n * @returns {any}\n */\nexport function flush_sync(fn) {\n\tvar previous_scheduler_mode = scheduler_mode;\n\tvar previous_queued_root_effects = queued_root_effects;\n\n\ttry {\n\t\tinfinite_loop_guard();\n\n\t\t/** @type {Effect[]} */\n\t\tconst root_effects = [];\n\n\t\tscheduler_mode = FLUSH_SYNC;\n\t\tqueued_root_effects = root_effects;\n\t\tis_micro_task_queued = false;\n\n\t\tflush_queued_root_effects(previous_queued_root_effects);\n\n\t\tvar result = fn?.();\n\n\t\tflush_tasks();\n\t\tif (queued_root_effects.length > 0 || root_effects.length > 0) {\n\t\t\tflush_sync();\n\t\t}\n\n\t\tflush_count = 0;\n\t\tif (DEV) {\n\t\t\tdev_effect_stack = [];\n\t\t}\n\n\t\treturn result;\n\t} finally {\n\t\tscheduler_mode = previous_scheduler_mode;\n\t\tqueued_root_effects = previous_queued_root_effects;\n\t}\n}\n\n/**\n * Returns a promise that resolves once any pending state changes have been applied.\n * @returns {Promise<void>}\n */\nexport async function tick() {\n\tawait Promise.resolve();\n\t// By calling flush_sync we guarantee that any pending state changes are applied after one tick.\n\t// TODO look into whether we can make flushing subsequent updates synchronously in the future.\n\tflush_sync();\n}\n\n/**\n * @template V\n * @param {Value<V>} signal\n * @returns {V}\n */\nexport function get(signal) {\n\tvar flags = signal.f;\n\tvar is_derived = (flags & DERIVED) !== 0;\n\n\t// If the derived is destroyed, just execute it again without retaining\n\t// its memoisation properties as the derived is stale\n\tif (is_derived && (flags & DESTROYED) !== 0) {\n\t\tvar value = execute_derived(/** @type {Derived} */ (signal));\n\t\t// Ensure the derived remains destroyed\n\t\tdestroy_derived(/** @type {Derived} */ (signal));\n\t\treturn value;\n\t}\n\n\tif (is_signals_recorded) {\n\t\tcaptured_signals.add(signal);\n\t}\n\n\t// Register the dependency on the current reaction signal.\n\tif (active_reaction !== null) {\n\t\tif (derived_sources !== null && derived_sources.includes(signal)) {\n\t\t\te.state_unsafe_local_read();\n\t\t}\n\t\tvar deps = active_reaction.deps;\n\n\t\t// If the signal is accessing the same dependencies in the same\n\t\t// order as it did last time, increment `skipped_deps`\n\t\t// rather than updating `new_deps`, which creates GC cost\n\t\tif (new_deps === null && deps !== null && deps[skipped_deps] === signal) {\n\t\t\tskipped_deps++;\n\t\t} else if (new_deps === null) {\n\t\t\tnew_deps = [signal];\n\t\t} else {\n\t\t\tnew_deps.push(signal);\n\t\t}\n\n\t\tif (\n\t\t\tuntracked_writes !== null &&\n\t\t\tactive_effect !== null &&\n\t\t\t(active_effect.f & CLEAN) !== 0 &&\n\t\t\t(active_effect.f & BRANCH_EFFECT) === 0 &&\n\t\t\tuntracked_writes.includes(signal)\n\t\t) {\n\t\t\tset_signal_status(active_effect, DIRTY);\n\t\t\tschedule_effect(active_effect);\n\t\t}\n\t} else if (is_derived && /** @type {Derived} */ (signal).deps === null) {\n\t\tvar derived = /** @type {Derived} */ (signal);\n\t\tvar parent = derived.parent;\n\n\t\tif (parent !== null && !parent.deriveds?.includes(derived)) {\n\t\t\t(parent.deriveds ??= []).push(derived);\n\t\t}\n\t}\n\n\tif (is_derived) {\n\t\tderived = /** @type {Derived} */ (signal);\n\n\t\tif (check_dirtiness(derived)) {\n\t\t\tupdate_derived(derived);\n\t\t}\n\t}\n\n\treturn signal.v;\n}\n\n/**\n * Like `get`, but checks for `undefined`. Used for `var` declarations because they can be accessed before being declared\n * @template V\n * @param {Value<V> | undefined} signal\n * @returns {V | undefined}\n */\nexport function safe_get(signal) {\n\treturn signal && get(signal);\n}\n\n/**\n * Invokes a function and captures all signals that are read during the invocation,\n * then invalidates them.\n * @param {() => any} fn\n */\nexport function invalidate_inner_signals(fn) {\n\tvar previous_is_signals_recorded = is_signals_recorded;\n\tvar previous_captured_signals = captured_signals;\n\tis_signals_recorded = true;\n\tcaptured_signals = new Set();\n\tvar captured = captured_signals;\n\tvar signal;\n\ttry {\n\t\tuntrack(fn);\n\t} finally {\n\t\tis_signals_recorded = previous_is_signals_recorded;\n\t\tif (is_signals_recorded) {\n\t\t\tfor (signal of captured_signals) {\n\t\t\t\tprevious_captured_signals.add(signal);\n\t\t\t}\n\t\t}\n\t\tcaptured_signals = previous_captured_signals;\n\t}\n\tfor (signal of captured) {\n\t\t// Go one level up because derived signals created as part of props in legacy mode\n\t\tif ((signal.f & LEGACY_DERIVED_PROP) !== 0) {\n\t\t\tfor (const dep of /** @type {Derived} */ (signal).deps || []) {\n\t\t\t\tif ((dep.f & DERIVED) === 0) {\n\t\t\t\t\tmutate(dep, null /* doesnt matter */);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tmutate(signal, null /* doesnt matter */);\n\t\t}\n\t}\n}\n\n/**\n * Use `untrack` to prevent something from being treated as an `$effect`/`$derived` dependency.\n *\n * https://svelte-5-preview.vercel.app/docs/functions#untrack\n * @template T\n * @param {() => T} fn\n * @returns {T}\n */\nexport function untrack(fn) {\n\tconst previous_reaction = active_reaction;\n\ttry {\n\t\tactive_reaction = null;\n\t\treturn fn();\n\t} finally {\n\t\tactive_reaction = previous_reaction;\n\t}\n}\n\nconst STATUS_MASK = ~(DIRTY | MAYBE_DIRTY | CLEAN);\n\n/**\n * @param {Signal} signal\n * @param {number} status\n * @returns {void}\n */\nexport function set_signal_status(signal, status) {\n\tsignal.f = (signal.f & STATUS_MASK) | status;\n}\n\n/**\n * Retrieves the context that belongs to the closest parent component with the specified `key`.\n * Must be called during component initialisation.\n *\n * @template T\n * @param {any} key\n * @returns {T}\n */\nexport function getContext(key) {\n\tconst context_map = get_or_init_context_map('getContext');\n\tconst result = /** @type {T} */ (context_map.get(key));\n\n\tif (DEV) {\n\t\tconst fn = /** @type {ComponentContext} */ (component_context).function;\n\t\tif (fn) {\n\t\t\tadd_owner(result, fn, true);\n\t\t}\n\t}\n\n\treturn result;\n}\n\n/**\n * Associates an arbitrary `context` object with the current component and the specified `key`\n * and returns that object. The context is then available to children of the component\n * (including slotted content) with `getContext`.\n *\n * Like lifecycle functions, this must be called during component initialisation.\n *\n * @template T\n * @param {any} key\n * @param {T} context\n * @returns {T}\n */\nexport function setContext(key, context) {\n\tconst context_map = get_or_init_context_map('setContext');\n\tcontext_map.set(key, context);\n\treturn context;\n}\n\n/**\n * Checks whether a given `key` has been set in the context of a parent component.\n * Must be called during component initialisation.\n *\n * @param {any} key\n * @returns {boolean}\n */\nexport function hasContext(key) {\n\tconst context_map = get_or_init_context_map('hasContext');\n\treturn context_map.has(key);\n}\n\n/**\n * Retrieves the whole context map that belongs to the closest parent component.\n * Must be called during component initialisation. Useful, for example, if you\n * programmatically create a component and want to pass the existing context to it.\n *\n * @template {Map<any, any>} [T=Map<any, any>]\n * @returns {T}\n */\nexport function getAllContexts() {\n\tconst context_map = get_or_init_context_map('getAllContexts');\n\n\tif (DEV) {\n\t\tconst fn = component_context?.function;\n\t\tif (fn) {\n\t\t\tfor (const value of context_map.values()) {\n\t\t\t\tadd_owner(value, fn, true);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn /** @type {T} */ (context_map);\n}\n\n/**\n * @param {string} name\n * @returns {Map<unknown, unknown>}\n */\nfunction get_or_init_context_map(name) {\n\tif (component_context === null) {\n\t\tlifecycle_outside_component(name);\n\t}\n\n\treturn (component_context.c ??= new Map(get_parent_context(component_context) || undefined));\n}\n\n/**\n * @param {ComponentContext} component_context\n * @returns {Map<unknown, unknown> | null}\n */\nfunction get_parent_context(component_context) {\n\tlet parent = component_context.p;\n\twhile (parent !== null) {\n\t\tconst context_map = parent.c;\n\t\tif (context_map !== null) {\n\t\t\treturn context_map;\n\t\t}\n\t\tparent = parent.p;\n\t}\n\treturn null;\n}\n\n/**\n * @param {Value<number>} signal\n * @param {1 | -1} [d]\n * @returns {number}\n */\nexport function update(signal, d = 1) {\n\tvar value = +get(signal);\n\tset(signal, value + d);\n\treturn value;\n}\n\n/**\n * @param {Value<number>} signal\n * @param {1 | -1} [d]\n * @returns {number}\n */\nexport function update_pre(signal, d = 1) {\n\treturn set(signal, +get(signal) + d);\n}\n\n/**\n * @param {Record<string, unknown>} obj\n * @param {string[]} keys\n * @returns {Record<string, unknown>}\n */\nexport function exclude_from_object(obj, keys) {\n\t/** @type {Record<string, unknown>} */\n\tvar result = {};\n\n\tfor (var key in obj) {\n\t\tif (!keys.includes(key)) {\n\t\t\tresult[key] = obj[key];\n\t\t}\n\t}\n\n\treturn result;\n}\n\n/**\n * @param {Record<string, unknown>} props\n * @param {any} runes\n * @param {Function} [fn]\n * @returns {void}\n */\nexport function push(props, runes = false, fn) {\n\tcomponent_context = {\n\t\tp: component_context,\n\t\tc: null,\n\t\te: null,\n\t\tm: false,\n\t\ts: props,\n\t\tx: null,\n\t\tl: null\n\t};\n\n\tif (!runes) {\n\t\tcomponent_context.l = {\n\t\t\ts: null,\n\t\t\tu: null,\n\t\t\tr1: [],\n\t\t\tr2: source(false)\n\t\t};\n\t}\n\n\tif (DEV) {\n\t\t// component function\n\t\tcomponent_context.function = fn;\n\t\tdev_current_component_function = fn;\n\t}\n}\n\n/**\n * @template {Record<string, any>} T\n * @param {T} [component]\n * @returns {T}\n */\nexport function pop(component) {\n\tconst context_stack_item = component_context;\n\tif (context_stack_item !== null) {\n\t\tif (component !== undefined) {\n\t\t\tcontext_stack_item.x = component;\n\t\t}\n\t\tconst component_effects = context_stack_item.e;\n\t\tif (component_effects !== null) {\n\t\t\tvar previous_effect = active_effect;\n\t\t\tvar previous_reaction = active_reaction;\n\t\t\tcontext_stack_item.e = null;\n\t\t\ttry {\n\t\t\t\tfor (var i = 0; i < component_effects.length; i++) {\n\t\t\t\t\tvar component_effect = component_effects[i];\n\t\t\t\t\tset_active_effect(component_effect.effect);\n\t\t\t\t\tset_active_reaction(component_effect.reaction);\n\t\t\t\t\teffect(component_effect.fn);\n\t\t\t\t}\n\t\t\t} finally {\n\t\t\t\tset_active_effect(previous_effect);\n\t\t\t\tset_active_reaction(previous_reaction);\n\t\t\t}\n\t\t}\n\t\tcomponent_context = context_stack_item.p;\n\t\tif (DEV) {\n\t\t\tdev_current_component_function = context_stack_item.p?.function ?? null;\n\t\t}\n\t\tcontext_stack_item.m = true;\n\t}\n\t// Micro-optimization: Don't set .a above to the empty object\n\t// so it can be garbage-collected when the return here is unused\n\treturn component || /** @type {T} */ ({});\n}\n\n/**\n * Possibly traverse an object and read all its properties so that they're all reactive in case this is `$state`.\n * Does only check first level of an object for performance reasons (heuristic should be good for 99% of all cases).\n * @param {any} value\n * @returns {void}\n */\nexport function deep_read_state(value) {\n\tif (typeof value !== 'object' || !value || value instanceof EventTarget) {\n\t\treturn;\n\t}\n\n\tif (STATE_SYMBOL in value) {\n\t\tdeep_read(value);\n\t} else if (!Array.isArray(value)) {\n\t\tfor (let key in value) {\n\t\t\tconst prop = value[key];\n\t\t\tif (typeof prop === 'object' && prop && STATE_SYMBOL in prop) {\n\t\t\t\tdeep_read(prop);\n\t\t\t}\n\t\t}\n\t}\n}\n\n/**\n * Deeply traverse an object and read all its properties\n * so that they're all reactive in case this is `$state`\n * @param {any} value\n * @param {Set<any>} visited\n * @returns {void}\n */\nexport function deep_read(value, visited = new Set()) {\n\tif (\n\t\ttypeof value === 'object' &&\n\t\tvalue !== null &&\n\t\t// We don't want to traverse DOM elements\n\t\t!(value instanceof EventTarget) &&\n\t\t!visited.has(value)\n\t) {\n\t\tvisited.add(value);\n\t\t// When working with a possible SvelteDate, this\n\t\t// will ensure we capture changes to it.\n\t\tif (value instanceof Date) {\n\t\t\tvalue.getTime();\n\t\t}\n\t\tfor (let key in value) {\n\t\t\ttry {\n\t\t\t\tdeep_read(value[key], visited);\n\t\t\t} catch (e) {\n\t\t\t\t// continue\n\t\t\t}\n\t\t}\n\t\tconst proto = get_prototype_of(value);\n\t\tif (\n\t\t\tproto !== Object.prototype &&\n\t\t\tproto !== Array.prototype &&\n\t\t\tproto !== Map.prototype &&\n\t\t\tproto !== Set.prototype &&\n\t\t\tproto !== Date.prototype\n\t\t) {\n\t\t\tconst descriptors = get_descriptors(proto);\n\t\t\tfor (let key in descriptors) {\n\t\t\t\tconst get = descriptors[key].get;\n\t\t\t\tif (get) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tget.call(value);\n\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\t// continue\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nif (DEV) {\n\t/**\n\t * @param {string} rune\n\t */\n\tfunction throw_rune_error(rune) {\n\t\tif (!(rune in globalThis)) {\n\t\t\t// TODO if people start adjusting the \"this can contain runes\" config through v-p-s more, adjust this message\n\t\t\t/** @type {any} */\n\t\t\tlet value; // let's hope noone modifies this global, but belts and braces\n\t\t\tObject.defineProperty(globalThis, rune, {\n\t\t\t\tconfigurable: true,\n\t\t\t\t// eslint-disable-next-line getter-return\n\t\t\t\tget: () => {\n\t\t\t\t\tif (value !== undefined) {\n\t\t\t\t\t\treturn value;\n\t\t\t\t\t}\n\n\t\t\t\t\te.rune_outside_svelte(rune);\n\t\t\t\t},\n\t\t\t\tset: (v) => {\n\t\t\t\t\tvalue = v;\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t}\n\n\tthrow_rune_error('$state');\n\tthrow_rune_error('$effect');\n\tthrow_rune_error('$derived');\n\tthrow_rune_error('$inspect');\n\tthrow_rune_error('$props');\n\tthrow_rune_error('$bindable');\n}\n","/** @import { ProxyMetadata, ProxyStateObject, Source } from '#client' */\nimport { DEV } from 'esm-env';\nimport { get, component_context, active_effect } from './runtime.js';\nimport {\n\tarray_prototype,\n\tget_descriptor,\n\tget_prototype_of,\n\tis_array,\n\tobject_prototype\n} from '../shared/utils.js';\nimport { check_ownership, widen_ownership } from './dev/ownership.js';\nimport { source, set } from './reactivity/sources.js';\nimport { STATE_SYMBOL, STATE_SYMBOL_METADATA } from './constants.js';\nimport { UNINITIALIZED } from '../../constants.js';\nimport * as e from './errors.js';\n\n/**\n * @template T\n * @param {T} value\n * @param {ProxyMetadata | null} [parent]\n * @param {Source<T>} [prev] dev mode only\n * @returns {T}\n */\nexport function proxy(value, parent = null, prev) {\n\t// if non-proxyable, or is already a proxy, return `value`\n\tif (typeof value !== 'object' || value === null || STATE_SYMBOL in value) {\n\t\treturn value;\n\t}\n\n\tconst prototype = get_prototype_of(value);\n\n\tif (prototype !== object_prototype && prototype !== array_prototype) {\n\t\treturn value;\n\t}\n\n\t/** @type {Map<any, Source<any>>} */\n\tvar sources = new Map();\n\tvar is_proxied_array = is_array(value);\n\tvar version = source(0);\n\n\tif (is_proxied_array) {\n\t\t// We need to create the length source eagerly to ensure that\n\t\t// mutations to the array are properly synced with our proxy\n\t\tsources.set('length', source(/** @type {any[]} */ (value).length));\n\t}\n\n\t/** @type {ProxyMetadata} */\n\tvar metadata;\n\n\tif (DEV) {\n\t\tmetadata = {\n\t\t\tparent,\n\t\t\towners: null\n\t\t};\n\n\t\tif (prev) {\n\t\t\t// Reuse owners from previous state; necessary because reassignment is not guaranteed to have correct component context.\n\t\t\t// If no previous proxy exists we play it safe and assume ownerless state\n\t\t\t// @ts-expect-error\n\t\t\tconst prev_owners = prev.v?.[STATE_SYMBOL_METADATA]?.owners;\n\t\t\tmetadata.owners = prev_owners ? new Set(prev_owners) : null;\n\t\t} else {\n\t\t\tmetadata.owners =\n\t\t\t\tparent === null\n\t\t\t\t\t? component_context !== null\n\t\t\t\t\t\t? new Set([component_context.function])\n\t\t\t\t\t\t: null\n\t\t\t\t\t: new Set();\n\t\t}\n\t}\n\n\treturn new Proxy(/** @type {any} */ (value), {\n\t\tdefineProperty(_, prop, descriptor) {\n\t\t\tif (\n\t\t\t\t!('value' in descriptor) ||\n\t\t\t\tdescriptor.configurable === false ||\n\t\t\t\tdescriptor.enumerable === false ||\n\t\t\t\tdescriptor.writable === false\n\t\t\t) {\n\t\t\t\t// we disallow non-basic descriptors, because unless they are applied to the\n\t\t\t\t// target object  which we avoid, so that state can be forked  we will run\n\t\t\t\t// afoul of the various invariants\n\t\t\t\t// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy/Proxy/getOwnPropertyDescriptor#invariants\n\t\t\t\te.state_descriptors_fixed();\n\t\t\t}\n\n\t\t\tvar s = sources.get(prop);\n\n\t\t\tif (s === undefined) {\n\t\t\t\ts = source(descriptor.value);\n\t\t\t\tsources.set(prop, s);\n\t\t\t} else {\n\t\t\t\tset(s, proxy(descriptor.value, metadata));\n\t\t\t}\n\n\t\t\treturn true;\n\t\t},\n\n\t\tdeleteProperty(target, prop) {\n\t\t\tvar s = sources.get(prop);\n\n\t\t\tif (s === undefined) {\n\t\t\t\tif (prop in target) {\n\t\t\t\t\tsources.set(prop, source(UNINITIALIZED));\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// When working with arrays, we need to also ensure we update the length when removing\n\t\t\t\t// an indexed property\n\t\t\t\tif (is_proxied_array && typeof prop === 'string') {\n\t\t\t\t\tvar ls = /** @type {Source<number>} */ (sources.get('length'));\n\t\t\t\t\tvar n = Number(prop);\n\n\t\t\t\t\tif (Number.isInteger(n) && n < ls.v) {\n\t\t\t\t\t\tset(ls, n);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tset(s, UNINITIALIZED);\n\t\t\t\tupdate_version(version);\n\t\t\t}\n\n\t\t\treturn true;\n\t\t},\n\n\t\tget(target, prop, receiver) {\n\t\t\tif (DEV && prop === STATE_SYMBOL_METADATA) {\n\t\t\t\treturn metadata;\n\t\t\t}\n\n\t\t\tif (prop === STATE_SYMBOL) {\n\t\t\t\treturn value;\n\t\t\t}\n\n\t\t\tvar s = sources.get(prop);\n\t\t\tvar exists = prop in target;\n\n\t\t\t// create a source, but only if it's an own property and not a prototype property\n\t\t\tif (s === undefined && (!exists || get_descriptor(target, prop)?.writable)) {\n\t\t\t\ts = source(proxy(exists ? target[prop] : UNINITIALIZED, metadata));\n\t\t\t\tsources.set(prop, s);\n\t\t\t}\n\n\t\t\tif (s !== undefined) {\n\t\t\t\tvar v = get(s);\n\n\t\t\t\t// In case of something like `foo = bar.map(...)`, foo would have ownership\n\t\t\t\t// of the array itself, while the individual items would have ownership\n\t\t\t\t// of the component that created bar. That means if we later do `foo[0].baz = 42`,\n\t\t\t\t// we could get a false-positive ownership violation, since the two proxies\n\t\t\t\t// are not connected to each other via the parent metadata relationship.\n\t\t\t\t// For this reason, we need to widen the ownership of the children\n\t\t\t\t// upon access when we detect they are not connected.\n\t\t\t\tif (DEV) {\n\t\t\t\t\t/** @type {ProxyMetadata | undefined} */\n\t\t\t\t\tvar prop_metadata = v?.[STATE_SYMBOL_METADATA];\n\t\t\t\t\tif (prop_metadata && prop_metadata?.parent !== metadata) {\n\t\t\t\t\t\twiden_ownership(metadata, prop_metadata);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn v === UNINITIALIZED ? undefined : v;\n\t\t\t}\n\n\t\t\treturn Reflect.get(target, prop, receiver);\n\t\t},\n\n\t\tgetOwnPropertyDescriptor(target, prop) {\n\t\t\tvar descriptor = Reflect.getOwnPropertyDescriptor(target, prop);\n\n\t\t\tif (descriptor && 'value' in descriptor) {\n\t\t\t\tvar s = sources.get(prop);\n\t\t\t\tif (s) descriptor.value = get(s);\n\t\t\t} else if (descriptor === undefined) {\n\t\t\t\tvar source = sources.get(prop);\n\t\t\t\tvar value = source?.v;\n\n\t\t\t\tif (source !== undefined && value !== UNINITIALIZED) {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tenumerable: true,\n\t\t\t\t\t\tconfigurable: true,\n\t\t\t\t\t\tvalue,\n\t\t\t\t\t\twritable: true\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn descriptor;\n\t\t},\n\n\t\thas(target, prop) {\n\t\t\tif (DEV && prop === STATE_SYMBOL_METADATA) {\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tif (prop === STATE_SYMBOL) {\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tvar s = sources.get(prop);\n\t\t\tvar has = (s !== undefined && s.v !== UNINITIALIZED) || Reflect.has(target, prop);\n\n\t\t\tif (\n\t\t\t\ts !== undefined ||\n\t\t\t\t(active_effect !== null && (!has || get_descriptor(target, prop)?.writable))\n\t\t\t) {\n\t\t\t\tif (s === undefined) {\n\t\t\t\t\ts = source(has ? proxy(target[prop], metadata) : UNINITIALIZED);\n\t\t\t\t\tsources.set(prop, s);\n\t\t\t\t}\n\n\t\t\t\tvar value = get(s);\n\t\t\t\tif (value === UNINITIALIZED) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn has;\n\t\t},\n\n\t\tset(target, prop, value, receiver) {\n\t\t\tvar s = sources.get(prop);\n\t\t\tvar has = prop in target;\n\n\t\t\t// variable.length = value -> clear all signals with index >= value\n\t\t\tif (is_proxied_array && prop === 'length') {\n\t\t\t\tfor (var i = value; i < /** @type {Source<number>} */ (s).v; i += 1) {\n\t\t\t\t\tvar other_s = sources.get(i + '');\n\t\t\t\t\tif (other_s !== undefined) {\n\t\t\t\t\t\tset(other_s, UNINITIALIZED);\n\t\t\t\t\t} else if (i in target) {\n\t\t\t\t\t\t// If the item exists in the original, we need to create a uninitialized source,\n\t\t\t\t\t\t// else a later read of the property would result in a source being created with\n\t\t\t\t\t\t// the value of the original item at that index.\n\t\t\t\t\t\tother_s = source(UNINITIALIZED);\n\t\t\t\t\t\tsources.set(i + '', other_s);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// If we haven't yet created a source for this property, we need to ensure\n\t\t\t// we do so otherwise if we read it later, then the write won't be tracked and\n\t\t\t// the heuristics of effects will be different vs if we had read the proxied\n\t\t\t// object property before writing to that property.\n\t\t\tif (s === undefined) {\n\t\t\t\tif (!has || get_descriptor(target, prop)?.writable) {\n\t\t\t\t\ts = source(undefined);\n\t\t\t\t\tset(s, proxy(value, metadata));\n\t\t\t\t\tsources.set(prop, s);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\thas = s.v !== UNINITIALIZED;\n\t\t\t\tset(s, proxy(value, metadata));\n\t\t\t}\n\n\t\t\tif (DEV) {\n\t\t\t\t/** @type {ProxyMetadata | undefined} */\n\t\t\t\tvar prop_metadata = value?.[STATE_SYMBOL_METADATA];\n\t\t\t\tif (prop_metadata && prop_metadata?.parent !== metadata) {\n\t\t\t\t\twiden_ownership(metadata, prop_metadata);\n\t\t\t\t}\n\t\t\t\tcheck_ownership(metadata);\n\t\t\t}\n\n\t\t\tvar descriptor = Reflect.getOwnPropertyDescriptor(target, prop);\n\n\t\t\t// Set the new value before updating any signals so that any listeners get the new value\n\t\t\tif (descriptor?.set) {\n\t\t\t\tdescriptor.set.call(receiver, value);\n\t\t\t}\n\n\t\t\tif (!has) {\n\t\t\t\t// If we have mutated an array directly, we might need to\n\t\t\t\t// signal that length has also changed. Do it before updating metadata\n\t\t\t\t// to ensure that iterating over the array as a result of a metadata update\n\t\t\t\t// will not cause the length to be out of sync.\n\t\t\t\tif (is_proxied_array && typeof prop === 'string') {\n\t\t\t\t\tvar ls = /** @type {Source<number>} */ (sources.get('length'));\n\t\t\t\t\tvar n = Number(prop);\n\n\t\t\t\t\tif (Number.isInteger(n) && n >= ls.v) {\n\t\t\t\t\t\tset(ls, n + 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tupdate_version(version);\n\t\t\t}\n\n\t\t\treturn true;\n\t\t},\n\n\t\townKeys(target) {\n\t\t\tget(version);\n\n\t\t\tvar own_keys = Reflect.ownKeys(target).filter((key) => {\n\t\t\t\tvar source = sources.get(key);\n\t\t\t\treturn source === undefined || source.v !== UNINITIALIZED;\n\t\t\t});\n\n\t\t\tfor (var [key, source] of sources) {\n\t\t\t\tif (source.v !== UNINITIALIZED && !(key in target)) {\n\t\t\t\t\town_keys.push(key);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn own_keys;\n\t\t},\n\n\t\tsetPrototypeOf() {\n\t\t\te.state_prototype_fixed();\n\t\t}\n\t});\n}\n\n/**\n * @param {Source<number>} signal\n * @param {1 | -1} [d]\n */\nfunction update_version(signal, d = 1) {\n\tset(signal, signal.v + d);\n}\n\n/**\n * @param {any} value\n */\nexport function get_proxied_value(value) {\n\tif (value !== null && typeof value === 'object' && STATE_SYMBOL in value) {\n\t\treturn value[STATE_SYMBOL];\n\t}\n\n\treturn value;\n}\n\n/**\n * @param {any} a\n * @param {any} b\n */\nexport function is(a, b) {\n\treturn Object.is(get_proxied_value(a), get_proxied_value(b));\n}\n","/** @import { TemplateNode } from '#client' */\nimport { hydrate_node, hydrating, set_hydrate_node } from './hydration.js';\nimport { DEV } from 'esm-env';\nimport { init_array_prototype_warnings } from '../dev/equality.js';\nimport { get_descriptor } from '../../shared/utils.js';\n\n// export these for reference in the compiled code, making global name deduplication unnecessary\n/** @type {Window} */\nexport var $window;\n\n/** @type {Document} */\nexport var $document;\n\n/** @type {() => Node | null} */\nvar first_child_getter;\n/** @type {() => Node | null} */\nvar next_sibling_getter;\n\n/**\n * Initialize these lazily to avoid issues when using the runtime in a server context\n * where these globals are not available while avoiding a separate server entry point\n */\nexport function init_operations() {\n\tif ($window !== undefined) {\n\t\treturn;\n\t}\n\n\t$window = window;\n\t$document = document;\n\n\tvar element_prototype = Element.prototype;\n\tvar node_prototype = Node.prototype;\n\n\t// @ts-ignore\n\tfirst_child_getter = get_descriptor(node_prototype, 'firstChild').get;\n\t// @ts-ignore\n\tnext_sibling_getter = get_descriptor(node_prototype, 'nextSibling').get;\n\n\t// the following assignments improve perf of lookups on DOM nodes\n\t// @ts-expect-error\n\telement_prototype.__click = undefined;\n\t// @ts-expect-error\n\telement_prototype.__className = '';\n\t// @ts-expect-error\n\telement_prototype.__attributes = null;\n\t// @ts-expect-error\n\telement_prototype.__e = undefined;\n\n\t// @ts-expect-error\n\tText.prototype.__t = undefined;\n\n\tif (DEV) {\n\t\t// @ts-expect-error\n\t\telement_prototype.__svelte_meta = null;\n\n\t\tinit_array_prototype_warnings();\n\t}\n}\n\n/**\n * @param {string} value\n * @returns {Text}\n */\nexport function create_text(value = '') {\n\treturn document.createTextNode(value);\n}\n\n/**\n * @template {Node} N\n * @param {N} node\n * @returns {Node | null}\n */\n/*@__NO_SIDE_EFFECTS__*/\nexport function get_first_child(node) {\n\treturn first_child_getter.call(node);\n}\n\n/**\n * @template {Node} N\n * @param {N} node\n * @returns {Node | null}\n */\n/*@__NO_SIDE_EFFECTS__*/\nexport function get_next_sibling(node) {\n\treturn next_sibling_getter.call(node);\n}\n\n/**\n * Don't mark this as side-effect-free, hydration needs to walk all nodes\n * @template {Node} N\n * @param {N} node\n * @returns {Node | null}\n */\nexport function child(node) {\n\tif (!hydrating) {\n\t\treturn get_first_child(node);\n\t}\n\n\tvar child = /** @type {TemplateNode} */ (get_first_child(hydrate_node));\n\n\t// Child can be null if we have an element with a single child, like `<p>{text}</p>`, where `text` is empty\n\tif (child === null) {\n\t\tchild = hydrate_node.appendChild(create_text());\n\t}\n\n\tset_hydrate_node(child);\n\treturn child;\n}\n\n/**\n * Don't mark this as side-effect-free, hydration needs to walk all nodes\n * @param {DocumentFragment | TemplateNode[]} fragment\n * @param {boolean} is_text\n * @returns {Node | null}\n */\nexport function first_child(fragment, is_text) {\n\tif (!hydrating) {\n\t\t// when not hydrating, `fragment` is a `DocumentFragment` (the result of calling `open_frag`)\n\t\tvar first = /** @type {DocumentFragment} */ (get_first_child(/** @type {Node} */ (fragment)));\n\n\t\t// TODO prevent user comments with the empty string when preserveComments is true\n\t\tif (first instanceof Comment && first.data === '') return get_next_sibling(first);\n\n\t\treturn first;\n\t}\n\n\t// if an {expression} is empty during SSR, there might be no\n\t// text node to hydrate  we must therefore create one\n\tif (is_text && hydrate_node?.nodeType !== 3) {\n\t\tvar text = create_text();\n\n\t\thydrate_node?.before(text);\n\t\tset_hydrate_node(text);\n\t\treturn text;\n\t}\n\n\treturn hydrate_node;\n}\n\n/**\n * Don't mark this as side-effect-free, hydration needs to walk all nodes\n * @param {TemplateNode} node\n * @param {number} count\n * @param {boolean} is_text\n * @returns {Node | null}\n */\nexport function sibling(node, count = 1, is_text = false) {\n\tlet next_sibling = hydrating ? hydrate_node : node;\n\n\twhile (count--) {\n\t\tnext_sibling = /** @type {TemplateNode} */ (get_next_sibling(next_sibling));\n\t}\n\n\tif (!hydrating) {\n\t\treturn next_sibling;\n\t}\n\n\tvar type = next_sibling.nodeType;\n\n\t// if a sibling {expression} is empty during SSR, there might be no\n\t// text node to hydrate  we must therefore create one\n\tif (is_text && type !== 3) {\n\t\tvar text = create_text();\n\t\tnext_sibling?.before(text);\n\t\tset_hydrate_node(text);\n\t\treturn text;\n\t}\n\n\tset_hydrate_node(next_sibling);\n\treturn /** @type {TemplateNode} */ (next_sibling);\n}\n\n/**\n * @template {Node} N\n * @param {N} node\n * @returns {void}\n */\nexport function clear_text_content(node) {\n\tnode.textContent = '';\n}\n","/** @import { TemplateNode } from '#client' */\n\nimport {\n\tHYDRATION_END,\n\tHYDRATION_ERROR,\n\tHYDRATION_START,\n\tHYDRATION_START_ELSE\n} from '../../../constants.js';\nimport * as w from '../warnings.js';\nimport { get_next_sibling } from './operations.js';\n\n/**\n * Use this variable to guard everything related to hydration code so it can be treeshaken out\n * if the user doesn't use the `hydrate` method and these code paths are therefore not needed.\n */\nexport let hydrating = false;\n\n/** @param {boolean} value */\nexport function set_hydrating(value) {\n\thydrating = value;\n}\n\n/**\n * The node that is currently being hydrated. This starts out as the first node inside the opening\n * <!--[--> comment, and updates each time a component calls `$.child(...)` or `$.sibling(...)`.\n * When entering a block (e.g. `{#if ...}`), `hydrate_node` is the block opening comment; by the\n * time we leave the block it is the closing comment, which serves as the block's anchor.\n * @type {TemplateNode}\n */\nexport let hydrate_node;\n\n/** @param {TemplateNode} node */\nexport function set_hydrate_node(node) {\n\tif (node === null) {\n\t\tw.hydration_mismatch();\n\t\tthrow HYDRATION_ERROR;\n\t}\n\n\treturn (hydrate_node = node);\n}\n\nexport function hydrate_next() {\n\treturn set_hydrate_node(/** @type {TemplateNode} */ (get_next_sibling(hydrate_node)));\n}\n\n/** @param {TemplateNode} node */\nexport function reset(node) {\n\tif (!hydrating) return;\n\n\t// If the node has remaining siblings, something has gone wrong\n\tif (get_next_sibling(hydrate_node) !== null) {\n\t\tw.hydration_mismatch();\n\t\tthrow HYDRATION_ERROR;\n\t}\n\n\thydrate_node = node;\n}\n\n/**\n * @param {HTMLTemplateElement} template\n */\nexport function hydrate_template(template) {\n\tif (hydrating) {\n\t\t// @ts-expect-error TemplateNode doesn't include DocumentFragment, but it's actually fine\n\t\thydrate_node = template.content;\n\t}\n}\n\nexport function next(count = 1) {\n\tif (hydrating) {\n\t\tvar i = count;\n\t\tvar node = hydrate_node;\n\n\t\twhile (i--) {\n\t\t\tnode = /** @type {TemplateNode} */ (get_next_sibling(node));\n\t\t}\n\n\t\thydrate_node = node;\n\t}\n}\n\n/**\n * Removes all nodes starting at `hydrate_node` up until the next hydration end comment\n */\nexport function remove_nodes() {\n\tvar depth = 0;\n\tvar node = hydrate_node;\n\n\twhile (true) {\n\t\tif (node.nodeType === 8) {\n\t\t\tvar data = /** @type {Comment} */ (node).data;\n\n\t\t\tif (data === HYDRATION_END) {\n\t\t\t\tif (depth === 0) return node;\n\t\t\t\tdepth -= 1;\n\t\t\t} else if (data === HYDRATION_START || data === HYDRATION_START_ELSE) {\n\t\t\t\tdepth += 1;\n\t\t\t}\n\t\t}\n\n\t\tvar next = /** @type {TemplateNode} */ (get_next_sibling(node));\n\t\tnode.remove();\n\t\tnode = next;\n\t}\n}\n","/** @import { Location } from 'locate-character' */\nimport { teardown } from '../../reactivity/effects.js';\nimport { define_property, is_array } from '../../../shared/utils.js';\nimport { hydrating } from '../hydration.js';\nimport { queue_micro_task } from '../task.js';\nimport { FILENAME } from '../../../../constants.js';\nimport * as w from '../../warnings.js';\nimport {\n\tactive_effect,\n\tactive_reaction,\n\tset_active_effect,\n\tset_active_reaction\n} from '../../runtime.js';\n\n/** @type {Set<string>} */\nexport const all_registered_events = new Set();\n\n/** @type {Set<(events: Array<string>) => void>} */\nexport const root_event_handles = new Set();\n\n/**\n * SSR adds onload and onerror attributes to catch those events before the hydration.\n * This function detects those cases, removes the attributes and replays the events.\n * @param {HTMLElement} dom\n */\nexport function replay_events(dom) {\n\tif (!hydrating) return;\n\n\tif (dom.onload) {\n\t\tdom.removeAttribute('onload');\n\t}\n\tif (dom.onerror) {\n\t\tdom.removeAttribute('onerror');\n\t}\n\t// @ts-expect-error\n\tconst event = dom.__e;\n\tif (event !== undefined) {\n\t\t// @ts-expect-error\n\t\tdom.__e = undefined;\n\t\tqueueMicrotask(() => {\n\t\t\tif (dom.isConnected) {\n\t\t\t\tdom.dispatchEvent(event);\n\t\t\t}\n\t\t});\n\t}\n}\n\n/**\n * @param {string} event_name\n * @param {EventTarget} dom\n * @param {EventListener} handler\n * @param {AddEventListenerOptions} options\n */\nexport function create_event(event_name, dom, handler, options) {\n\t/**\n\t * @this {EventTarget}\n\t */\n\tfunction target_handler(/** @type {Event} */ event) {\n\t\tif (!options.capture) {\n\t\t\t// Only call in the bubble phase, else delegated events would be called before the capturing events\n\t\t\thandle_event_propagation.call(dom, event);\n\t\t}\n\t\tif (!event.cancelBubble) {\n\t\t\tvar previous_reaction = active_reaction;\n\t\t\tvar previous_effect = active_effect;\n\n\t\t\tset_active_reaction(null);\n\t\t\tset_active_effect(null);\n\t\t\ttry {\n\t\t\t\treturn handler.call(this, event);\n\t\t\t} finally {\n\t\t\t\tset_active_reaction(previous_reaction);\n\t\t\t\tset_active_effect(previous_effect);\n\t\t\t}\n\t\t}\n\t}\n\n\t// Chrome has a bug where pointer events don't work when attached to a DOM element that has been cloned\n\t// with cloneNode() and the DOM element is disconnected from the document. To ensure the event works, we\n\t// defer the attachment till after it's been appended to the document. TODO: remove this once Chrome fixes\n\t// this bug. The same applies to wheel events and touch events.\n\tif (\n\t\tevent_name.startsWith('pointer') ||\n\t\tevent_name.startsWith('touch') ||\n\t\tevent_name === 'wheel'\n\t) {\n\t\tqueue_micro_task(() => {\n\t\t\tdom.addEventListener(event_name, target_handler, options);\n\t\t});\n\t} else {\n\t\tdom.addEventListener(event_name, target_handler, options);\n\t}\n\n\treturn target_handler;\n}\n\n/**\n * Attaches an event handler to an element and returns a function that removes the handler. Using this\n * rather than `addEventListener` will preserve the correct order relative to handlers added declaratively\n * (with attributes like `onclick`), which use event delegation for performance reasons\n *\n * @param {EventTarget} element\n * @param {string} type\n * @param {EventListener} handler\n * @param {AddEventListenerOptions} [options]\n */\nexport function on(element, type, handler, options = {}) {\n\tvar target_handler = create_event(type, element, handler, options);\n\n\treturn () => {\n\t\telement.removeEventListener(type, target_handler, options);\n\t};\n}\n\n/**\n * @param {string} event_name\n * @param {Element} dom\n * @param {EventListener} handler\n * @param {boolean} capture\n * @param {boolean} [passive]\n * @returns {void}\n */\nexport function event(event_name, dom, handler, capture, passive) {\n\tvar options = { capture, passive };\n\tvar target_handler = create_event(event_name, dom, handler, options);\n\n\t// @ts-ignore\n\tif (dom === document.body || dom === window || dom === document) {\n\t\tteardown(() => {\n\t\t\tdom.removeEventListener(event_name, target_handler, options);\n\t\t});\n\t}\n}\n\n/**\n * @param {Array<string>} events\n * @returns {void}\n */\nexport function delegate(events) {\n\tfor (var i = 0; i < events.length; i++) {\n\t\tall_registered_events.add(events[i]);\n\t}\n\n\tfor (var fn of root_event_handles) {\n\t\tfn(events);\n\t}\n}\n\n/**\n * @this {EventTarget}\n * @param {Event} event\n * @returns {void}\n */\nexport function handle_event_propagation(event) {\n\tvar handler_element = this;\n\tvar owner_document = /** @type {Node} */ (handler_element).ownerDocument;\n\tvar event_name = event.type;\n\tvar path = event.composedPath?.() || [];\n\tvar current_target = /** @type {null | Element} */ (path[0] || event.target);\n\n\t// composedPath contains list of nodes the event has propagated through.\n\t// We check __root to skip all nodes below it in case this is a\n\t// parent of the __root node, which indicates that there's nested\n\t// mounted apps. In this case we don't want to trigger events multiple times.\n\tvar path_idx = 0;\n\n\t// @ts-expect-error is added below\n\tvar handled_at = event.__root;\n\n\tif (handled_at) {\n\t\tvar at_idx = path.indexOf(handled_at);\n\t\tif (\n\t\t\tat_idx !== -1 &&\n\t\t\t(handler_element === document || handler_element === /** @type {any} */ (window))\n\t\t) {\n\t\t\t// This is the fallback document listener or a window listener, but the event was already handled\n\t\t\t// -> ignore, but set handle_at to document/window so that we're resetting the event\n\t\t\t// chain in case someone manually dispatches the same event object again.\n\t\t\t// @ts-expect-error\n\t\t\tevent.__root = handler_element;\n\t\t\treturn;\n\t\t}\n\n\t\t// We're deliberately not skipping if the index is higher, because\n\t\t// someone could create an event programmatically and emit it multiple times,\n\t\t// in which case we want to handle the whole propagation chain properly each time.\n\t\t// (this will only be a false negative if the event is dispatched multiple times and\n\t\t// the fallback document listener isn't reached in between, but that's super rare)\n\t\tvar handler_idx = path.indexOf(handler_element);\n\t\tif (handler_idx === -1) {\n\t\t\t// handle_idx can theoretically be -1 (happened in some JSDOM testing scenarios with an event listener on the window object)\n\t\t\t// so guard against that, too, and assume that everything was handled at this point.\n\t\t\treturn;\n\t\t}\n\n\t\tif (at_idx <= handler_idx) {\n\t\t\tpath_idx = at_idx;\n\t\t}\n\t}\n\n\tcurrent_target = /** @type {Element} */ (path[path_idx] || event.target);\n\t// there can only be one delegated event per element, and we either already handled the current target,\n\t// or this is the very first target in the chain which has a non-delegated listener, in which case it's safe\n\t// to handle a possible delegated event on it later (through the root delegation listener for example).\n\tif (current_target === handler_element) return;\n\n\t// Proxy currentTarget to correct target\n\tdefine_property(event, 'currentTarget', {\n\t\tconfigurable: true,\n\t\tget() {\n\t\t\treturn current_target || owner_document;\n\t\t}\n\t});\n\n\t// This started because of Chromium issue https://chromestatus.com/feature/5128696823545856,\n\t// where removal or moving of of the DOM can cause sync `blur` events to fire, which can cause logic\n\t// to run inside the current `active_reaction`, which isn't what we want at all. However, on reflection,\n\t// it's probably best that all event handled by Svelte have this behaviour, as we don't really want\n\t// an event handler to run in the context of another reaction or effect.\n\tvar previous_reaction = active_reaction;\n\tvar previous_effect = active_effect;\n\tset_active_reaction(null);\n\tset_active_effect(null);\n\n\ttry {\n\t\t/**\n\t\t * @type {unknown}\n\t\t */\n\t\tvar throw_error;\n\t\t/**\n\t\t * @type {unknown[]}\n\t\t */\n\t\tvar other_errors = [];\n\n\t\twhile (current_target !== null) {\n\t\t\t/** @type {null | Element} */\n\t\t\tvar parent_element =\n\t\t\t\tcurrent_target.assignedSlot ||\n\t\t\t\tcurrent_target.parentNode ||\n\t\t\t\t/** @type {any} */ (current_target).host ||\n\t\t\t\tnull;\n\n\t\t\ttry {\n\t\t\t\t// @ts-expect-error\n\t\t\t\tvar delegated = current_target['__' + event_name];\n\n\t\t\t\tif (delegated !== undefined && !(/** @type {any} */ (current_target).disabled)) {\n\t\t\t\t\tif (is_array(delegated)) {\n\t\t\t\t\t\tvar [fn, ...data] = delegated;\n\t\t\t\t\t\tfn.apply(current_target, [event, ...data]);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdelegated.call(current_target, event);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} catch (error) {\n\t\t\t\tif (throw_error) {\n\t\t\t\t\tother_errors.push(error);\n\t\t\t\t} else {\n\t\t\t\t\tthrow_error = error;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (event.cancelBubble || parent_element === handler_element || parent_element === null) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcurrent_target = parent_element;\n\t\t}\n\n\t\tif (throw_error) {\n\t\t\tfor (let error of other_errors) {\n\t\t\t\t// Throw the rest of the errors, one-by-one on a microtask\n\t\t\t\tqueueMicrotask(() => {\n\t\t\t\t\tthrow error;\n\t\t\t\t});\n\t\t\t}\n\t\t\tthrow throw_error;\n\t\t}\n\t} finally {\n\t\t// @ts-expect-error is used above\n\t\tevent.__root = handler_element;\n\t\t// @ts-ignore remove proxy on currentTarget\n\t\tdelete event.currentTarget;\n\t\tset_active_reaction(previous_reaction);\n\t\tset_active_effect(previous_effect);\n\t}\n}\n\n/**\n * In dev, warn if an event handler is not a function, as it means the\n * user probably called the handler or forgot to add a `() =>`\n * @param {() => (event: Event, ...args: any) => void} thunk\n * @param {EventTarget} element\n * @param {[Event, ...any]} args\n * @param {any} component\n * @param {[number, number]} [loc]\n * @param {boolean} [remove_parens]\n */\nexport function apply(\n\tthunk,\n\telement,\n\targs,\n\tcomponent,\n\tloc,\n\thas_side_effects = false,\n\tremove_parens = false\n) {\n\tlet handler;\n\tlet error;\n\n\ttry {\n\t\thandler = thunk();\n\t} catch (e) {\n\t\terror = e;\n\t}\n\n\tif (typeof handler === 'function') {\n\t\thandler.apply(element, args);\n\t} else if (has_side_effects || handler != null) {\n\t\tconst filename = component?.[FILENAME];\n\t\tconst location = loc ? ` at ${filename}:${loc[0]}:${loc[1]}` : ` in ${filename}`;\n\n\t\tconst event_name = args[0].type;\n\t\tconst description = `\\`${event_name}\\` handler${location}`;\n\t\tconst suggestion = remove_parens ? 'remove the trailing `()`' : 'add a leading `() =>`';\n\n\t\tw.event_handler_invalid(description, suggestion);\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\t}\n}\n","/** @param {string} html */\nexport function create_fragment_from_html(html) {\n\tvar elem = document.createElement('template');\n\telem.innerHTML = html;\n\treturn elem.content;\n}\n","/** @import { Effect, TemplateNode } from '#client' */\nimport { hydrate_next, hydrate_node, hydrating, set_hydrate_node } from './hydration.js';\nimport { create_text, get_first_child } from './operations.js';\nimport { create_fragment_from_html } from './reconciler.js';\nimport { active_effect } from '../runtime.js';\nimport { TEMPLATE_FRAGMENT, TEMPLATE_USE_IMPORT_NODE } from '../../../constants.js';\nimport { queue_micro_task } from './task.js';\n\n/**\n * @param {TemplateNode} start\n * @param {TemplateNode | null} end\n */\nexport function assign_nodes(start, end) {\n\tvar effect = /** @type {Effect} */ (active_effect);\n\tif (effect.nodes_start === null) {\n\t\teffect.nodes_start = start;\n\t\teffect.nodes_end = end;\n\t}\n}\n\n/**\n * @param {string} content\n * @param {number} flags\n * @returns {() => Node | Node[]}\n */\n/*#__NO_SIDE_EFFECTS__*/\nexport function template(content, flags) {\n\tvar is_fragment = (flags & TEMPLATE_FRAGMENT) !== 0;\n\tvar use_import_node = (flags & TEMPLATE_USE_IMPORT_NODE) !== 0;\n\n\t/** @type {Node} */\n\tvar node;\n\n\t/**\n\t * Whether or not the first item is a text/element node. If not, we need to\n\t * create an additional comment node to act as `effect.nodes.start`\n\t */\n\tvar has_start = !content.startsWith('<!>');\n\n\treturn () => {\n\t\tif (hydrating) {\n\t\t\tassign_nodes(hydrate_node, null);\n\t\t\treturn hydrate_node;\n\t\t}\n\n\t\tif (node === undefined) {\n\t\t\tnode = create_fragment_from_html(has_start ? content : '<!>' + content);\n\t\t\tif (!is_fragment) node = /** @type {Node} */ (get_first_child(node));\n\t\t}\n\n\t\tvar clone = /** @type {TemplateNode} */ (\n\t\t\tuse_import_node ? document.importNode(node, true) : node.cloneNode(true)\n\t\t);\n\n\t\tif (is_fragment) {\n\t\t\tvar start = /** @type {TemplateNode} */ (get_first_child(clone));\n\t\t\tvar end = /** @type {TemplateNode} */ (clone.lastChild);\n\n\t\t\tassign_nodes(start, end);\n\t\t} else {\n\t\t\tassign_nodes(clone, clone);\n\t\t}\n\n\t\treturn clone;\n\t};\n}\n\n/**\n * @param {string} content\n * @param {number} flags\n * @returns {() => Node | Node[]}\n */\n/*#__NO_SIDE_EFFECTS__*/\nexport function template_with_script(content, flags) {\n\tvar fn = template(content, flags);\n\treturn () => run_scripts(/** @type {Element | DocumentFragment} */ (fn()));\n}\n\n/**\n * @param {string} content\n * @param {number} flags\n * @param {'svg' | 'math'} ns\n * @returns {() => Node | Node[]}\n */\n/*#__NO_SIDE_EFFECTS__*/\nexport function ns_template(content, flags, ns = 'svg') {\n\t/**\n\t * Whether or not the first item is a text/element node. If not, we need to\n\t * create an additional comment node to act as `effect.nodes.start`\n\t */\n\tvar has_start = !content.startsWith('<!>');\n\n\tvar is_fragment = (flags & TEMPLATE_FRAGMENT) !== 0;\n\tvar wrapped = `<${ns}>${has_start ? content : '<!>' + content}</${ns}>`;\n\n\t/** @type {Element | DocumentFragment} */\n\tvar node;\n\n\treturn () => {\n\t\tif (hydrating) {\n\t\t\tassign_nodes(hydrate_node, null);\n\t\t\treturn hydrate_node;\n\t\t}\n\n\t\tif (!node) {\n\t\t\tvar fragment = /** @type {DocumentFragment} */ (create_fragment_from_html(wrapped));\n\t\t\tvar root = /** @type {Element} */ (get_first_child(fragment));\n\n\t\t\tif (is_fragment) {\n\t\t\t\tnode = document.createDocumentFragment();\n\t\t\t\twhile (get_first_child(root)) {\n\t\t\t\t\tnode.appendChild(/** @type {Node} */ (get_first_child(root)));\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tnode = /** @type {Element} */ (get_first_child(root));\n\t\t\t}\n\t\t}\n\n\t\tvar clone = /** @type {TemplateNode} */ (node.cloneNode(true));\n\n\t\tif (is_fragment) {\n\t\t\tvar start = /** @type {TemplateNode} */ (get_first_child(clone));\n\t\t\tvar end = /** @type {TemplateNode} */ (clone.lastChild);\n\n\t\t\tassign_nodes(start, end);\n\t\t} else {\n\t\t\tassign_nodes(clone, clone);\n\t\t}\n\n\t\treturn clone;\n\t};\n}\n\n/**\n * @param {string} content\n * @param {number} flags\n * @returns {() => Node | Node[]}\n */\n/*#__NO_SIDE_EFFECTS__*/\nexport function svg_template_with_script(content, flags) {\n\tvar fn = ns_template(content, flags);\n\treturn () => run_scripts(/** @type {Element | DocumentFragment} */ (fn()));\n}\n\n/**\n * @param {string} content\n * @param {number} flags\n * @returns {() => Node | Node[]}\n */\n/*#__NO_SIDE_EFFECTS__*/\nexport function mathml_template(content, flags) {\n\treturn ns_template(content, flags, 'math');\n}\n\n/**\n * Creating a document fragment from HTML that contains script tags will not execute\n * the scripts. We need to replace the script tags with new ones so that they are executed.\n * @param {Element | DocumentFragment} node\n * @returns {Node | Node[]}\n */\nfunction run_scripts(node) {\n\t// scripts were SSR'd, in which case they will run\n\tif (hydrating) return node;\n\n\tconst is_fragment = node.nodeType === 11;\n\tconst scripts =\n\t\t/** @type {HTMLElement} */ (node).tagName === 'SCRIPT'\n\t\t\t? [/** @type {HTMLScriptElement} */ (node)]\n\t\t\t: node.querySelectorAll('script');\n\tconst effect = /** @type {Effect} */ (active_effect);\n\n\tfor (const script of scripts) {\n\t\tconst clone = document.createElement('script');\n\t\tfor (var attribute of script.attributes) {\n\t\t\tclone.setAttribute(attribute.name, attribute.value);\n\t\t}\n\n\t\tclone.textContent = script.textContent;\n\n\t\t// The script has changed - if it's at the edges, the effect now points at dead nodes\n\t\tif (is_fragment ? node.firstChild === script : node === script) {\n\t\t\teffect.nodes_start = clone;\n\t\t}\n\t\tif (is_fragment ? node.lastChild === script : node === script) {\n\t\t\teffect.nodes_end = clone;\n\t\t}\n\n\t\tscript.replaceWith(clone);\n\t}\n\treturn node;\n}\n\n/**\n * Don't mark this as side-effect-free, hydration needs to walk all nodes\n * @param {any} value\n */\nexport function text(value = '') {\n\tif (!hydrating) {\n\t\tvar t = create_text(value + '');\n\t\tassign_nodes(t, t);\n\t\treturn t;\n\t}\n\n\tvar node = hydrate_node;\n\n\tif (node.nodeType !== 3) {\n\t\t// if an {expression} is empty during SSR, we need to insert an empty text node\n\t\tnode.before((node = create_text()));\n\t\tset_hydrate_node(node);\n\t}\n\n\tassign_nodes(node, node);\n\treturn node;\n}\n\nexport function comment() {\n\t// we're not delegating to `template` here for performance reasons\n\tif (hydrating) {\n\t\tassign_nodes(hydrate_node, null);\n\t\treturn hydrate_node;\n\t}\n\n\tvar frag = document.createDocumentFragment();\n\tvar start = document.createComment('');\n\tvar anchor = create_text();\n\tfrag.append(start, anchor);\n\n\tassign_nodes(start, anchor);\n\n\treturn frag;\n}\n\n/**\n * Assign the created (or in hydration mode, traversed) dom elements to the current block\n * and insert the elements into the dom (in client mode).\n * @param {Text | Comment | Element} anchor\n * @param {DocumentFragment | Element} dom\n */\nexport function append(anchor, dom) {\n\tif (hydrating) {\n\t\t/** @type {Effect} */ (active_effect).nodes_end = hydrate_node;\n\t\thydrate_next();\n\t\treturn;\n\t}\n\n\tif (anchor === null) {\n\t\t// edge case  void `<svelte:element>` with content\n\t\treturn;\n\t}\n\n\tanchor.before(/** @type {Node} */ (dom));\n}\n","const regex_return_characters = /\\r/g;\n\n/**\n * @param {string} str\n * @returns {string}\n */\nexport function hash(str) {\n\tstr = str.replace(regex_return_characters, '');\n\tlet hash = 5381;\n\tlet i = str.length;\n\n\twhile (i--) hash = ((hash << 5) - hash) ^ str.charCodeAt(i);\n\treturn (hash >>> 0).toString(36);\n}\n\nconst VOID_ELEMENT_NAMES = [\n\t'area',\n\t'base',\n\t'br',\n\t'col',\n\t'command',\n\t'embed',\n\t'hr',\n\t'img',\n\t'input',\n\t'keygen',\n\t'link',\n\t'meta',\n\t'param',\n\t'source',\n\t'track',\n\t'wbr'\n];\n\n/**\n * Returns `true` if `name` is of a void element\n * @param {string} name\n */\nexport function is_void(name) {\n\treturn VOID_ELEMENT_NAMES.includes(name) || name.toLowerCase() === '!doctype';\n}\n\nconst RESERVED_WORDS = [\n\t'arguments',\n\t'await',\n\t'break',\n\t'case',\n\t'catch',\n\t'class',\n\t'const',\n\t'continue',\n\t'debugger',\n\t'default',\n\t'delete',\n\t'do',\n\t'else',\n\t'enum',\n\t'eval',\n\t'export',\n\t'extends',\n\t'false',\n\t'finally',\n\t'for',\n\t'function',\n\t'if',\n\t'implements',\n\t'import',\n\t'in',\n\t'instanceof',\n\t'interface',\n\t'let',\n\t'new',\n\t'null',\n\t'package',\n\t'private',\n\t'protected',\n\t'public',\n\t'return',\n\t'static',\n\t'super',\n\t'switch',\n\t'this',\n\t'throw',\n\t'true',\n\t'try',\n\t'typeof',\n\t'var',\n\t'void',\n\t'while',\n\t'with',\n\t'yield'\n];\n\n/**\n * Returns `true` if `word` is a reserved JavaScript keyword\n * @param {string} word\n */\nexport function is_reserved(word) {\n\treturn RESERVED_WORDS.includes(word);\n}\n\n/**\n * @param {string} name\n */\nexport function is_capture_event(name) {\n\treturn name.endsWith('capture') && name !== 'gotpointercapture' && name !== 'lostpointercapture';\n}\n\n/** List of Element events that will be delegated */\nconst DELEGATED_EVENTS = [\n\t'beforeinput',\n\t'click',\n\t'change',\n\t'dblclick',\n\t'contextmenu',\n\t'focusin',\n\t'focusout',\n\t'input',\n\t'keydown',\n\t'keyup',\n\t'mousedown',\n\t'mousemove',\n\t'mouseout',\n\t'mouseover',\n\t'mouseup',\n\t'pointerdown',\n\t'pointermove',\n\t'pointerout',\n\t'pointerover',\n\t'pointerup',\n\t'touchend',\n\t'touchmove',\n\t'touchstart'\n];\n\n/**\n * Returns `true` if `event_name` is a delegated event\n * @param {string} event_name\n */\nexport function is_delegated(event_name) {\n\treturn DELEGATED_EVENTS.includes(event_name);\n}\n\n/**\n * Attributes that are boolean, i.e. they are present or not present.\n */\nconst DOM_BOOLEAN_ATTRIBUTES = [\n\t'allowfullscreen',\n\t'async',\n\t'autofocus',\n\t'autoplay',\n\t'checked',\n\t'controls',\n\t'default',\n\t'disabled',\n\t'formnovalidate',\n\t'hidden',\n\t'indeterminate',\n\t'ismap',\n\t'loop',\n\t'multiple',\n\t'muted',\n\t'nomodule',\n\t'novalidate',\n\t'open',\n\t'playsinline',\n\t'readonly',\n\t'required',\n\t'reversed',\n\t'seamless',\n\t'selected',\n\t'webkitdirectory'\n];\n\n/**\n * Returns `true` if `name` is a boolean attribute\n * @param {string} name\n */\nexport function is_boolean_attribute(name) {\n\treturn DOM_BOOLEAN_ATTRIBUTES.includes(name);\n}\n\n/**\n * @type {Record<string, string>}\n * List of attribute names that should be aliased to their property names\n * because they behave differently between setting them as an attribute and\n * setting them as a property.\n */\nconst ATTRIBUTE_ALIASES = {\n\t// no `class: 'className'` because we handle that separately\n\tformnovalidate: 'formNoValidate',\n\tismap: 'isMap',\n\tnomodule: 'noModule',\n\tplaysinline: 'playsInline',\n\treadonly: 'readOnly'\n};\n\n/**\n * @param {string} name\n */\nexport function normalize_attribute(name) {\n\tname = name.toLowerCase();\n\treturn ATTRIBUTE_ALIASES[name] ?? name;\n}\n\nconst DOM_PROPERTIES = [\n\t...DOM_BOOLEAN_ATTRIBUTES,\n\t'formNoValidate',\n\t'isMap',\n\t'noModule',\n\t'playsInline',\n\t'readOnly',\n\t'value',\n\t'inert',\n\t'volume'\n];\n\n/**\n * @param {string} name\n */\nexport function is_dom_property(name) {\n\treturn DOM_PROPERTIES.includes(name);\n}\n\n/**\n * Subset of delegated events which should be passive by default.\n * These two are already passive via browser defaults on window, document and body.\n * But since\n * - we're delegating them\n * - they happen often\n * - they apply to mobile which is generally less performant\n * we're marking them as passive by default for other elements, too.\n */\nconst PASSIVE_EVENTS = ['touchstart', 'touchmove'];\n\n/**\n * Returns `true` if `name` is a passive event\n * @param {string} name\n */\nexport function is_passive_event(name) {\n\treturn PASSIVE_EVENTS.includes(name);\n}\n\nconst CONTENT_EDITABLE_BINDINGS = ['textContent', 'innerHTML', 'innerText'];\n\n/** @param {string} name */\nexport function is_content_editable_binding(name) {\n\treturn CONTENT_EDITABLE_BINDINGS.includes(name);\n}\n\nconst LOAD_ERROR_ELEMENTS = [\n\t'body',\n\t'embed',\n\t'iframe',\n\t'img',\n\t'link',\n\t'object',\n\t'script',\n\t'style',\n\t'track'\n];\n\n/**\n * Returns `true` if the element emits `load` and `error` events\n * @param {string} name\n */\nexport function is_load_error_element(name) {\n\treturn LOAD_ERROR_ELEMENTS.includes(name);\n}\n\nconst SVG_ELEMENTS = [\n\t'altGlyph',\n\t'altGlyphDef',\n\t'altGlyphItem',\n\t'animate',\n\t'animateColor',\n\t'animateMotion',\n\t'animateTransform',\n\t'circle',\n\t'clipPath',\n\t'color-profile',\n\t'cursor',\n\t'defs',\n\t'desc',\n\t'discard',\n\t'ellipse',\n\t'feBlend',\n\t'feColorMatrix',\n\t'feComponentTransfer',\n\t'feComposite',\n\t'feConvolveMatrix',\n\t'feDiffuseLighting',\n\t'feDisplacementMap',\n\t'feDistantLight',\n\t'feDropShadow',\n\t'feFlood',\n\t'feFuncA',\n\t'feFuncB',\n\t'feFuncG',\n\t'feFuncR',\n\t'feGaussianBlur',\n\t'feImage',\n\t'feMerge',\n\t'feMergeNode',\n\t'feMorphology',\n\t'feOffset',\n\t'fePointLight',\n\t'feSpecularLighting',\n\t'feSpotLight',\n\t'feTile',\n\t'feTurbulence',\n\t'filter',\n\t'font',\n\t'font-face',\n\t'font-face-format',\n\t'font-face-name',\n\t'font-face-src',\n\t'font-face-uri',\n\t'foreignObject',\n\t'g',\n\t'glyph',\n\t'glyphRef',\n\t'hatch',\n\t'hatchpath',\n\t'hkern',\n\t'image',\n\t'line',\n\t'linearGradient',\n\t'marker',\n\t'mask',\n\t'mesh',\n\t'meshgradient',\n\t'meshpatch',\n\t'meshrow',\n\t'metadata',\n\t'missing-glyph',\n\t'mpath',\n\t'path',\n\t'pattern',\n\t'polygon',\n\t'polyline',\n\t'radialGradient',\n\t'rect',\n\t'set',\n\t'solidcolor',\n\t'stop',\n\t'svg',\n\t'switch',\n\t'symbol',\n\t'text',\n\t'textPath',\n\t'tref',\n\t'tspan',\n\t'unknown',\n\t'use',\n\t'view',\n\t'vkern'\n];\n\n/** @param {string} name */\nexport function is_svg(name) {\n\treturn SVG_ELEMENTS.includes(name);\n}\n\nconst MATHML_ELEMENTS = [\n\t'annotation',\n\t'annotation-xml',\n\t'maction',\n\t'math',\n\t'merror',\n\t'mfrac',\n\t'mi',\n\t'mmultiscripts',\n\t'mn',\n\t'mo',\n\t'mover',\n\t'mpadded',\n\t'mphantom',\n\t'mprescripts',\n\t'mroot',\n\t'mrow',\n\t'ms',\n\t'mspace',\n\t'msqrt',\n\t'mstyle',\n\t'msub',\n\t'msubsup',\n\t'msup',\n\t'mtable',\n\t'mtd',\n\t'mtext',\n\t'mtr',\n\t'munder',\n\t'munderover',\n\t'semantics'\n];\n\n/** @param {string} name */\nexport function is_mathml(name) {\n\treturn MATHML_ELEMENTS.includes(name);\n}\n\nconst RUNES = /** @type {const} */ ([\n\t'$state',\n\t'$state.raw',\n\t'$state.snapshot',\n\t'$props',\n\t'$bindable',\n\t'$derived',\n\t'$derived.by',\n\t'$effect',\n\t'$effect.pre',\n\t'$effect.tracking',\n\t'$effect.root',\n\t'$inspect',\n\t'$inspect().with',\n\t'$host'\n]);\n\n/**\n * @param {string} name\n * @returns {name is RUNES[number]}\n */\nexport function is_rune(name) {\n\treturn RUNES.includes(/** @type {RUNES[number]} */ (name));\n}\n","/** @import { ComponentContext, Effect, TemplateNode } from '#client' */\n/** @import { Component, ComponentType, SvelteComponent } from '../../index.js' */\nimport { DEV } from 'esm-env';\nimport {\n\tclear_text_content,\n\tcreate_text,\n\tget_first_child,\n\tget_next_sibling,\n\tinit_operations\n} from './dom/operations.js';\nimport { HYDRATION_END, HYDRATION_ERROR, HYDRATION_START } from '../../constants.js';\nimport { push, pop, component_context, active_effect } from './runtime.js';\nimport { effect_root, branch } from './reactivity/effects.js';\nimport {\n\thydrate_next,\n\thydrate_node,\n\thydrating,\n\tset_hydrate_node,\n\tset_hydrating\n} from './dom/hydration.js';\nimport { array_from } from '../shared/utils.js';\nimport {\n\tall_registered_events,\n\thandle_event_propagation,\n\troot_event_handles\n} from './dom/elements/events.js';\nimport { reset_head_anchor } from './dom/blocks/svelte-head.js';\nimport * as w from './warnings.js';\nimport * as e from './errors.js';\nimport { assign_nodes } from './dom/template.js';\nimport { is_passive_event } from '../../utils.js';\n\n/**\n * This is normally true  block effects should run their intro transitions \n * but is false during hydration (unless `options.intro` is `true`) and\n * when creating the children of a `<svelte:element>` that just changed tag\n */\nexport let should_intro = true;\n\n/** @param {boolean} value */\nexport function set_should_intro(value) {\n\tshould_intro = value;\n}\n\n/**\n * @param {Element} text\n * @param {string} value\n * @returns {void}\n */\nexport function set_text(text, value) {\n\t// For objects, we apply string coercion (which might make things like $state array references in the template reactive) before diffing\n\tvar str = value == null ? '' : typeof value === 'object' ? value + '' : value;\n\t// @ts-expect-error\n\tif (str !== (text.__t ??= text.nodeValue)) {\n\t\t// @ts-expect-error\n\t\ttext.__t = str;\n\t\ttext.nodeValue = str == null ? '' : str + '';\n\t}\n}\n\n/**\n * Mounts a component to the given target and returns the exports and potentially the props (if compiled with `accessors: true`) of the component.\n * Transitions will play during the initial render unless the `intro` option is set to `false`.\n *\n * @template {Record<string, any>} Props\n * @template {Record<string, any>} Exports\n * @param {ComponentType<SvelteComponent<Props>> | Component<Props, Exports, any>} component\n * @param {{} extends Props ? {\n * \t\ttarget: Document | Element | ShadowRoot;\n * \t\tanchor?: Node;\n * \t\tprops?: Props;\n * \t\tevents?: Record<string, (e: any) => any>;\n * \t\tcontext?: Map<any, any>;\n * \t\tintro?: boolean;\n * \t}: {\n * \t\ttarget: Document | Element | ShadowRoot;\n * \t\tprops: Props;\n * \t\tanchor?: Node;\n * \t\tevents?: Record<string, (e: any) => any>;\n * \t\tcontext?: Map<any, any>;\n * \t\tintro?: boolean;\n * \t}} options\n * @returns {Exports}\n */\nexport function mount(component, options) {\n\treturn _mount(component, options);\n}\n\n/**\n * Hydrates a component on the given target and returns the exports and potentially the props (if compiled with `accessors: true`) of the component\n *\n * @template {Record<string, any>} Props\n * @template {Record<string, any>} Exports\n * @param {ComponentType<SvelteComponent<Props>> | Component<Props, Exports, any>} component\n * @param {{} extends Props ? {\n * \t\ttarget: Document | Element | ShadowRoot;\n * \t\tprops?: Props;\n * \t\tevents?: Record<string, (e: any) => any>;\n *  \tcontext?: Map<any, any>;\n * \t\tintro?: boolean;\n * \t\trecover?: boolean;\n * \t} : {\n * \t\ttarget: Document | Element | ShadowRoot;\n * \t\tprops: Props;\n * \t\tevents?: Record<string, (e: any) => any>;\n *  \tcontext?: Map<any, any>;\n * \t\tintro?: boolean;\n * \t\trecover?: boolean;\n * \t}} options\n * @returns {Exports}\n */\nexport function hydrate(component, options) {\n\tinit_operations();\n\toptions.intro = options.intro ?? false;\n\tconst target = options.target;\n\tconst was_hydrating = hydrating;\n\tconst previous_hydrate_node = hydrate_node;\n\n\ttry {\n\t\tvar anchor = /** @type {TemplateNode} */ (get_first_child(target));\n\t\twhile (\n\t\t\tanchor &&\n\t\t\t(anchor.nodeType !== 8 || /** @type {Comment} */ (anchor).data !== HYDRATION_START)\n\t\t) {\n\t\t\tanchor = /** @type {TemplateNode} */ (get_next_sibling(anchor));\n\t\t}\n\n\t\tif (!anchor) {\n\t\t\tthrow HYDRATION_ERROR;\n\t\t}\n\n\t\tset_hydrating(true);\n\t\tset_hydrate_node(/** @type {Comment} */ (anchor));\n\t\thydrate_next();\n\n\t\tconst instance = _mount(component, { ...options, anchor });\n\n\t\tif (\n\t\t\thydrate_node === null ||\n\t\t\thydrate_node.nodeType !== 8 ||\n\t\t\t/** @type {Comment} */ (hydrate_node).data !== HYDRATION_END\n\t\t) {\n\t\t\tw.hydration_mismatch();\n\t\t\tthrow HYDRATION_ERROR;\n\t\t}\n\n\t\tset_hydrating(false);\n\n\t\treturn /**  @type {Exports} */ (instance);\n\t} catch (error) {\n\t\tif (error === HYDRATION_ERROR) {\n\t\t\tif (options.recover === false) {\n\t\t\t\te.hydration_failed();\n\t\t\t}\n\n\t\t\t// If an error occured above, the operations might not yet have been initialised.\n\t\t\tinit_operations();\n\t\t\tclear_text_content(target);\n\n\t\t\tset_hydrating(false);\n\t\t\treturn mount(component, options);\n\t\t}\n\n\t\tthrow error;\n\t} finally {\n\t\tset_hydrating(was_hydrating);\n\t\tset_hydrate_node(previous_hydrate_node);\n\t\treset_head_anchor();\n\t}\n}\n\n/** @type {Map<string, number>} */\nconst document_listeners = new Map();\n\n/**\n * @template {Record<string, any>} Exports\n * @param {ComponentType<SvelteComponent<any>> | Component<any>} Component\n * @param {{\n * \t\ttarget: Document | Element | ShadowRoot;\n * \t\tanchor?: Node;\n * \t\tprops?: any;\n * \t\tevents?: any;\n * \t\tcontext?: Map<any, any>;\n * \t\tintro?: boolean;\n * \t}} options\n * @returns {Exports}\n */\nfunction _mount(Component, { target, anchor, props = {}, events, context, intro = true }) {\n\tinit_operations();\n\n\tvar registered_events = new Set();\n\n\t/** @param {Array<string>} events */\n\tvar event_handle = (events) => {\n\t\tfor (var i = 0; i < events.length; i++) {\n\t\t\tvar event_name = events[i];\n\n\t\t\tif (registered_events.has(event_name)) continue;\n\t\t\tregistered_events.add(event_name);\n\n\t\t\tvar passive = is_passive_event(event_name);\n\n\t\t\t// Add the event listener to both the container and the document.\n\t\t\t// The container listener ensures we catch events from within in case\n\t\t\t// the outer content stops propagation of the event.\n\t\t\ttarget.addEventListener(event_name, handle_event_propagation, { passive });\n\n\t\t\tvar n = document_listeners.get(event_name);\n\n\t\t\tif (n === undefined) {\n\t\t\t\t// The document listener ensures we catch events that originate from elements that were\n\t\t\t\t// manually moved outside of the container (e.g. via manual portals).\n\t\t\t\tdocument.addEventListener(event_name, handle_event_propagation, { passive });\n\t\t\t\tdocument_listeners.set(event_name, 1);\n\t\t\t} else {\n\t\t\t\tdocument_listeners.set(event_name, n + 1);\n\t\t\t}\n\t\t}\n\t};\n\n\tevent_handle(array_from(all_registered_events));\n\troot_event_handles.add(event_handle);\n\n\t/** @type {Exports} */\n\t// @ts-expect-error will be defined because the render effect runs synchronously\n\tvar component = undefined;\n\n\tvar unmount = effect_root(() => {\n\t\tvar anchor_node = anchor ?? target.appendChild(create_text());\n\n\t\tbranch(() => {\n\t\t\tif (context) {\n\t\t\t\tpush({});\n\t\t\t\tvar ctx = /** @type {ComponentContext} */ (component_context);\n\t\t\t\tctx.c = context;\n\t\t\t}\n\n\t\t\tif (events) {\n\t\t\t\t// We can't spread the object or else we'd lose the state proxy stuff, if it is one\n\t\t\t\t/** @type {any} */ (props).$$events = events;\n\t\t\t}\n\n\t\t\tif (hydrating) {\n\t\t\t\tassign_nodes(/** @type {TemplateNode} */ (anchor_node), null);\n\t\t\t}\n\n\t\t\tshould_intro = intro;\n\t\t\t// @ts-expect-error the public typings are not what the actual function looks like\n\t\t\tcomponent = Component(anchor_node, props) || {};\n\t\t\tshould_intro = true;\n\n\t\t\tif (hydrating) {\n\t\t\t\t/** @type {Effect} */ (active_effect).nodes_end = hydrate_node;\n\t\t\t}\n\n\t\t\tif (context) {\n\t\t\t\tpop();\n\t\t\t}\n\t\t});\n\n\t\treturn () => {\n\t\t\tfor (var event_name of registered_events) {\n\t\t\t\ttarget.removeEventListener(event_name, handle_event_propagation);\n\n\t\t\t\tvar n = /** @type {number} */ (document_listeners.get(event_name));\n\n\t\t\t\tif (--n === 0) {\n\t\t\t\t\tdocument.removeEventListener(event_name, handle_event_propagation);\n\t\t\t\t\tdocument_listeners.delete(event_name);\n\t\t\t\t} else {\n\t\t\t\t\tdocument_listeners.set(event_name, n);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\troot_event_handles.delete(event_handle);\n\t\t\tmounted_components.delete(component);\n\t\t\tif (anchor_node !== anchor) {\n\t\t\t\tanchor_node.parentNode?.removeChild(anchor_node);\n\t\t\t}\n\t\t};\n\t});\n\n\tmounted_components.set(component, unmount);\n\treturn component;\n}\n\n/**\n * References of the components that were mounted or hydrated.\n * Uses a `WeakMap` to avoid memory leaks.\n */\nlet mounted_components = new WeakMap();\n\n/**\n * Unmounts a component that was previously mounted using `mount` or `hydrate`.\n * @param {Record<string, any>} component\n */\nexport function unmount(component) {\n\tconst fn = mounted_components.get(component);\n\n\tif (fn) {\n\t\tfn();\n\t} else if (DEV) {\n\t\tw.lifecycle_double_unmount();\n\t}\n}\n","/** @import { Effect, TemplateNode } from '#client' */\nimport { EFFECT_TRANSPARENT } from '../../constants.js';\nimport {\n\thydrate_next,\n\thydrate_node,\n\thydrating,\n\tremove_nodes,\n\tset_hydrate_node,\n\tset_hydrating\n} from '../hydration.js';\nimport { block, branch, pause_effect, resume_effect } from '../../reactivity/effects.js';\nimport { HYDRATION_START_ELSE } from '../../../../constants.js';\n\n/**\n * @param {TemplateNode} node\n * @param {() => boolean} get_condition\n * @param {(anchor: Node) => void} consequent_fn\n * @param {null | ((anchor: Node) => void)} [alternate_fn]\n * @param {boolean} [elseif] True if this is an `{:else if ...}` block rather than an `{#if ...}`, as that affects which transitions are considered 'local'\n * @returns {void}\n */\nexport function if_block(node, get_condition, consequent_fn, alternate_fn = null, elseif = false) {\n\tif (hydrating) {\n\t\thydrate_next();\n\t}\n\n\tvar anchor = node;\n\n\t/** @type {Effect | null} */\n\tvar consequent_effect = null;\n\n\t/** @type {Effect | null} */\n\tvar alternate_effect = null;\n\n\t/** @type {boolean | null} */\n\tvar condition = null;\n\n\tvar flags = elseif ? EFFECT_TRANSPARENT : 0;\n\n\tblock(() => {\n\t\tif (condition === (condition = !!get_condition())) return;\n\n\t\t/** Whether or not there was a hydration mismatch. Needs to be a `let` or else it isn't treeshaken out */\n\t\tlet mismatch = false;\n\n\t\tif (hydrating) {\n\t\t\tconst is_else = /** @type {Comment} */ (anchor).data === HYDRATION_START_ELSE;\n\n\t\t\tif (condition === is_else) {\n\t\t\t\t// Hydration mismatch: remove everything inside the anchor and start fresh.\n\t\t\t\t// This could happen with `{#if browser}...{/if}`, for example\n\t\t\t\tanchor = remove_nodes();\n\n\t\t\t\tset_hydrate_node(anchor);\n\t\t\t\tset_hydrating(false);\n\t\t\t\tmismatch = true;\n\t\t\t}\n\t\t}\n\n\t\tif (condition) {\n\t\t\tif (consequent_effect) {\n\t\t\t\tresume_effect(consequent_effect);\n\t\t\t} else {\n\t\t\t\tconsequent_effect = branch(() => consequent_fn(anchor));\n\t\t\t}\n\n\t\t\tif (alternate_effect) {\n\t\t\t\tpause_effect(alternate_effect, () => {\n\t\t\t\t\talternate_effect = null;\n\t\t\t\t});\n\t\t\t}\n\t\t} else {\n\t\t\tif (alternate_effect) {\n\t\t\t\tresume_effect(alternate_effect);\n\t\t\t} else if (alternate_fn) {\n\t\t\t\talternate_effect = branch(() => alternate_fn(anchor));\n\t\t\t}\n\n\t\t\tif (consequent_effect) {\n\t\t\t\tpause_effect(consequent_effect, () => {\n\t\t\t\t\tconsequent_effect = null;\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\tif (mismatch) {\n\t\t\t// continue in hydration mode\n\t\t\tset_hydrating(true);\n\t\t}\n\t}, flags);\n\n\tif (hydrating) {\n\t\tanchor = hydrate_node;\n\t}\n}\n","/** @import { EachItem, EachState, Effect, MaybeSource, Source, TemplateNode, TransitionManager, Value } from '#client' */\nimport {\n\tEACH_INDEX_REACTIVE,\n\tEACH_IS_ANIMATED,\n\tEACH_IS_CONTROLLED,\n\tEACH_ITEM_IMMUTABLE,\n\tEACH_ITEM_REACTIVE,\n\tHYDRATION_END,\n\tHYDRATION_START_ELSE\n} from '../../../../constants.js';\nimport {\n\thydrate_next,\n\thydrate_node,\n\thydrating,\n\tremove_nodes,\n\tset_hydrate_node,\n\tset_hydrating\n} from '../hydration.js';\nimport {\n\tclear_text_content,\n\tcreate_text,\n\tget_first_child,\n\tget_next_sibling\n} from '../operations.js';\nimport {\n\tblock,\n\tbranch,\n\tdestroy_effect,\n\trun_out_transitions,\n\tpause_children,\n\tpause_effect,\n\tresume_effect\n} from '../../reactivity/effects.js';\nimport { source, mutable_source, internal_set } from '../../reactivity/sources.js';\nimport { array_from, is_array } from '../../../shared/utils.js';\nimport { INERT } from '../../constants.js';\nimport { queue_micro_task } from '../task.js';\nimport { active_effect } from '../../runtime.js';\n\n/**\n * The row of a keyed each block that is currently updating. We track this\n * so that `animate:` directives have something to attach themselves to\n * @type {EachItem | null}\n */\nexport let current_each_item = null;\n\n/** @param {EachItem | null} item */\nexport function set_current_each_item(item) {\n\tcurrent_each_item = item;\n}\n\n/**\n * @param {any} _\n * @param {number} i\n */\nexport function index(_, i) {\n\treturn i;\n}\n\n/**\n * Pause multiple effects simultaneously, and coordinate their\n * subsequent destruction. Used in each blocks\n * @param {EachState} state\n * @param {EachItem[]} items\n * @param {null | Node} controlled_anchor\n * @param {Map<any, EachItem>} items_map\n */\nfunction pause_effects(state, items, controlled_anchor, items_map) {\n\t/** @type {TransitionManager[]} */\n\tvar transitions = [];\n\tvar length = items.length;\n\n\tfor (var i = 0; i < length; i++) {\n\t\tpause_children(items[i].e, transitions, true);\n\t}\n\n\tvar is_controlled = length > 0 && transitions.length === 0 && controlled_anchor !== null;\n\t// If we have a controlled anchor, it means that the each block is inside a single\n\t// DOM element, so we can apply a fast-path for clearing the contents of the element.\n\tif (is_controlled) {\n\t\tvar parent_node = /** @type {Element} */ (\n\t\t\t/** @type {Element} */ (controlled_anchor).parentNode\n\t\t);\n\t\tclear_text_content(parent_node);\n\t\tparent_node.append(/** @type {Element} */ (controlled_anchor));\n\t\titems_map.clear();\n\t\tlink(state, items[0].prev, items[length - 1].next);\n\t}\n\n\trun_out_transitions(transitions, () => {\n\t\tfor (var i = 0; i < length; i++) {\n\t\t\tvar item = items[i];\n\t\t\tif (!is_controlled) {\n\t\t\t\titems_map.delete(item.k);\n\t\t\t\tlink(state, item.prev, item.next);\n\t\t\t}\n\t\t\tdestroy_effect(item.e, !is_controlled);\n\t\t}\n\t});\n}\n\n/**\n * @template V\n * @param {Element | Comment} node The next sibling node, or the parent node if this is a 'controlled' block\n * @param {number} flags\n * @param {() => V[]} get_collection\n * @param {(value: V, index: number) => any} get_key\n * @param {(anchor: Node, item: MaybeSource<V>, index: MaybeSource<number>) => void} render_fn\n * @param {null | ((anchor: Node) => void)} fallback_fn\n * @returns {void}\n */\nexport function each(node, flags, get_collection, get_key, render_fn, fallback_fn = null) {\n\tvar anchor = node;\n\n\t/** @type {EachState} */\n\tvar state = { flags, items: new Map(), first: null };\n\n\tvar is_controlled = (flags & EACH_IS_CONTROLLED) !== 0;\n\n\tif (is_controlled) {\n\t\tvar parent_node = /** @type {Element} */ (node);\n\n\t\tanchor = hydrating\n\t\t\t? set_hydrate_node(/** @type {Comment | Text} */ (get_first_child(parent_node)))\n\t\t\t: parent_node.appendChild(create_text());\n\t}\n\n\tif (hydrating) {\n\t\thydrate_next();\n\t}\n\n\t/** @type {Effect | null} */\n\tvar fallback = null;\n\n\tvar was_empty = false;\n\n\tblock(() => {\n\t\tvar collection = get_collection();\n\n\t\tvar array = is_array(collection)\n\t\t\t? collection\n\t\t\t: collection == null\n\t\t\t\t? []\n\t\t\t\t: array_from(collection);\n\n\t\tvar length = array.length;\n\n\t\tif (was_empty && length === 0) {\n\t\t\t// ignore updates if the array is empty,\n\t\t\t// and it already was empty on previous run\n\t\t\treturn;\n\t\t}\n\t\twas_empty = length === 0;\n\n\t\t/** `true` if there was a hydration mismatch. Needs to be a `let` or else it isn't treeshaken out */\n\t\tlet mismatch = false;\n\n\t\tif (hydrating) {\n\t\t\tvar is_else = /** @type {Comment} */ (anchor).data === HYDRATION_START_ELSE;\n\n\t\t\tif (is_else !== (length === 0)) {\n\t\t\t\t// hydration mismatch  remove the server-rendered DOM and start over\n\t\t\t\tanchor = remove_nodes();\n\n\t\t\t\tset_hydrate_node(anchor);\n\t\t\t\tset_hydrating(false);\n\t\t\t\tmismatch = true;\n\t\t\t}\n\t\t}\n\n\t\t// this is separate to the previous block because `hydrating` might change\n\t\tif (hydrating) {\n\t\t\t/** @type {EachItem | null} */\n\t\t\tvar prev = null;\n\n\t\t\t/** @type {EachItem} */\n\t\t\tvar item;\n\n\t\t\tfor (var i = 0; i < length; i++) {\n\t\t\t\tif (\n\t\t\t\t\thydrate_node.nodeType === 8 &&\n\t\t\t\t\t/** @type {Comment} */ (hydrate_node).data === HYDRATION_END\n\t\t\t\t) {\n\t\t\t\t\t// The server rendered fewer items than expected,\n\t\t\t\t\t// so break out and continue appending non-hydrated items\n\t\t\t\t\tanchor = /** @type {Comment} */ (hydrate_node);\n\t\t\t\t\tmismatch = true;\n\t\t\t\t\tset_hydrating(false);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tvar value = array[i];\n\t\t\t\tvar key = get_key(value, i);\n\t\t\t\titem = create_item(hydrate_node, state, prev, null, value, key, i, render_fn, flags);\n\t\t\t\tstate.items.set(key, item);\n\n\t\t\t\tprev = item;\n\t\t\t}\n\n\t\t\t// remove excess nodes\n\t\t\tif (length > 0) {\n\t\t\t\tset_hydrate_node(remove_nodes());\n\t\t\t}\n\t\t}\n\n\t\tif (!hydrating) {\n\t\t\treconcile(array, state, anchor, render_fn, flags, get_key);\n\t\t}\n\n\t\tif (fallback_fn !== null) {\n\t\t\tif (length === 0) {\n\t\t\t\tif (fallback) {\n\t\t\t\t\tresume_effect(fallback);\n\t\t\t\t} else {\n\t\t\t\t\tfallback = branch(() => fallback_fn(anchor));\n\t\t\t\t}\n\t\t\t} else if (fallback !== null) {\n\t\t\t\tpause_effect(fallback, () => {\n\t\t\t\t\tfallback = null;\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\tif (mismatch) {\n\t\t\t// continue in hydration mode\n\t\t\tset_hydrating(true);\n\t\t}\n\n\t\t// When we mount the each block for the first time, the collection won't be\n\t\t// connected to this effect as the effect hasn't finished running yet and its deps\n\t\t// won't be assigned. However, it's possible that when reconciling the each block\n\t\t// that a mutation occurred and it's made the collection MAYBE_DIRTY, so reading the\n\t\t// collection again can provide consistency to the reactive graph again as the deriveds\n\t\t// will now be `CLEAN`.\n\t\tget_collection();\n\t});\n\n\tif (hydrating) {\n\t\tanchor = hydrate_node;\n\t}\n}\n\n/**\n * Add, remove, or reorder items output by an each block as its input changes\n * @template V\n * @param {Array<V>} array\n * @param {EachState} state\n * @param {Element | Comment | Text} anchor\n * @param {(anchor: Node, item: MaybeSource<V>, index: number | Source<number>) => void} render_fn\n * @param {number} flags\n * @param {(value: V, index: number) => any} get_key\n * @returns {void}\n */\nfunction reconcile(array, state, anchor, render_fn, flags, get_key) {\n\tvar is_animated = (flags & EACH_IS_ANIMATED) !== 0;\n\tvar should_update = (flags & (EACH_ITEM_REACTIVE | EACH_INDEX_REACTIVE)) !== 0;\n\n\tvar length = array.length;\n\tvar items = state.items;\n\tvar first = state.first;\n\tvar current = first;\n\n\t/** @type {undefined | Set<EachItem>} */\n\tvar seen;\n\n\t/** @type {EachItem | null} */\n\tvar prev = null;\n\n\t/** @type {undefined | Set<EachItem>} */\n\tvar to_animate;\n\n\t/** @type {EachItem[]} */\n\tvar matched = [];\n\n\t/** @type {EachItem[]} */\n\tvar stashed = [];\n\n\t/** @type {V} */\n\tvar value;\n\n\t/** @type {any} */\n\tvar key;\n\n\t/** @type {EachItem | undefined} */\n\tvar item;\n\n\t/** @type {number} */\n\tvar i;\n\n\tif (is_animated) {\n\t\tfor (i = 0; i < length; i += 1) {\n\t\t\tvalue = array[i];\n\t\t\tkey = get_key(value, i);\n\t\t\titem = items.get(key);\n\n\t\t\tif (item !== undefined) {\n\t\t\t\titem.a?.measure();\n\t\t\t\t(to_animate ??= new Set()).add(item);\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (i = 0; i < length; i += 1) {\n\t\tvalue = array[i];\n\t\tkey = get_key(value, i);\n\t\titem = items.get(key);\n\n\t\tif (item === undefined) {\n\t\t\tvar child_anchor = current ? /** @type {TemplateNode} */ (current.e.nodes_start) : anchor;\n\n\t\t\tprev = create_item(\n\t\t\t\tchild_anchor,\n\t\t\t\tstate,\n\t\t\t\tprev,\n\t\t\t\tprev === null ? state.first : prev.next,\n\t\t\t\tvalue,\n\t\t\t\tkey,\n\t\t\t\ti,\n\t\t\t\trender_fn,\n\t\t\t\tflags\n\t\t\t);\n\n\t\t\titems.set(key, prev);\n\n\t\t\tmatched = [];\n\t\t\tstashed = [];\n\n\t\t\tcurrent = prev.next;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (should_update) {\n\t\t\tupdate_item(item, value, i, flags);\n\t\t}\n\n\t\tif ((item.e.f & INERT) !== 0) {\n\t\t\tresume_effect(item.e);\n\t\t\tif (is_animated) {\n\t\t\t\titem.a?.unfix();\n\t\t\t\t(to_animate ??= new Set()).delete(item);\n\t\t\t}\n\t\t}\n\n\t\tif (item !== current) {\n\t\t\tif (seen !== undefined && seen.has(item)) {\n\t\t\t\tif (matched.length < stashed.length) {\n\t\t\t\t\t// more efficient to move later items to the front\n\t\t\t\t\tvar start = stashed[0];\n\t\t\t\t\tvar j;\n\n\t\t\t\t\tprev = start.prev;\n\n\t\t\t\t\tvar a = matched[0];\n\t\t\t\t\tvar b = matched[matched.length - 1];\n\n\t\t\t\t\tfor (j = 0; j < matched.length; j += 1) {\n\t\t\t\t\t\tmove(matched[j], start, anchor);\n\t\t\t\t\t}\n\n\t\t\t\t\tfor (j = 0; j < stashed.length; j += 1) {\n\t\t\t\t\t\tseen.delete(stashed[j]);\n\t\t\t\t\t}\n\n\t\t\t\t\tlink(state, a.prev, b.next);\n\t\t\t\t\tlink(state, prev, a);\n\t\t\t\t\tlink(state, b, start);\n\n\t\t\t\t\tcurrent = start;\n\t\t\t\t\tprev = b;\n\t\t\t\t\ti -= 1;\n\n\t\t\t\t\tmatched = [];\n\t\t\t\t\tstashed = [];\n\t\t\t\t} else {\n\t\t\t\t\t// more efficient to move earlier items to the back\n\t\t\t\t\tseen.delete(item);\n\t\t\t\t\tmove(item, current, anchor);\n\n\t\t\t\t\tlink(state, item.prev, item.next);\n\t\t\t\t\tlink(state, item, prev === null ? state.first : prev.next);\n\t\t\t\t\tlink(state, prev, item);\n\n\t\t\t\t\tprev = item;\n\t\t\t\t}\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tmatched = [];\n\t\t\tstashed = [];\n\n\t\t\twhile (current !== null && current.k !== key) {\n\t\t\t\t// If the item has an effect that is already inert, skip over adding it\n\t\t\t\t// to our seen Set as the item is already being handled\n\t\t\t\tif ((current.e.f & INERT) === 0) {\n\t\t\t\t\t(seen ??= new Set()).add(current);\n\t\t\t\t}\n\t\t\t\tstashed.push(current);\n\t\t\t\tcurrent = current.next;\n\t\t\t}\n\n\t\t\tif (current === null) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\titem = current;\n\t\t}\n\n\t\tmatched.push(item);\n\t\tprev = item;\n\t\tcurrent = item.next;\n\t}\n\n\tif (current !== null || seen !== undefined) {\n\t\tvar to_destroy = seen === undefined ? [] : array_from(seen);\n\n\t\twhile (current !== null) {\n\t\t\t// Inert effects are currently outroing and will be removed once the transition is finished\n\t\t\tif ((current.e.f & INERT) === 0) {\n\t\t\t\tto_destroy.push(current);\n\t\t\t}\n\t\t\tcurrent = current.next;\n\t\t}\n\n\t\tvar destroy_length = to_destroy.length;\n\n\t\tif (destroy_length > 0) {\n\t\t\tvar controlled_anchor = (flags & EACH_IS_CONTROLLED) !== 0 && length === 0 ? anchor : null;\n\n\t\t\tif (is_animated) {\n\t\t\t\tfor (i = 0; i < destroy_length; i += 1) {\n\t\t\t\t\tto_destroy[i].a?.measure();\n\t\t\t\t}\n\n\t\t\t\tfor (i = 0; i < destroy_length; i += 1) {\n\t\t\t\t\tto_destroy[i].a?.fix();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tpause_effects(state, to_destroy, controlled_anchor, items);\n\t\t}\n\t}\n\n\tif (is_animated) {\n\t\tqueue_micro_task(() => {\n\t\t\tif (to_animate === undefined) return;\n\t\t\tfor (item of to_animate) {\n\t\t\t\titem.a?.apply();\n\t\t\t}\n\t\t});\n\t}\n\n\t/** @type {Effect} */ (active_effect).first = state.first && state.first.e;\n\t/** @type {Effect} */ (active_effect).last = prev && prev.e;\n}\n\n/**\n * @param {EachItem} item\n * @param {any} value\n * @param {number} index\n * @param {number} type\n * @returns {void}\n */\nfunction update_item(item, value, index, type) {\n\tif ((type & EACH_ITEM_REACTIVE) !== 0) {\n\t\tinternal_set(item.v, value);\n\t}\n\n\tif ((type & EACH_INDEX_REACTIVE) !== 0) {\n\t\tinternal_set(/** @type {Value<number>} */ (item.i), index);\n\t} else {\n\t\titem.i = index;\n\t}\n}\n\n/**\n * @template V\n * @param {Node} anchor\n * @param {EachState} state\n * @param {EachItem | null} prev\n * @param {EachItem | null} next\n * @param {V} value\n * @param {unknown} key\n * @param {number} index\n * @param {(anchor: Node, item: V | Source<V>, index: number | Value<number>) => void} render_fn\n * @param {number} flags\n * @returns {EachItem}\n */\nfunction create_item(anchor, state, prev, next, value, key, index, render_fn, flags) {\n\tvar previous_each_item = current_each_item;\n\n\ttry {\n\t\tvar reactive = (flags & EACH_ITEM_REACTIVE) !== 0;\n\t\tvar mutable = (flags & EACH_ITEM_IMMUTABLE) === 0;\n\n\t\tvar v = reactive ? (mutable ? mutable_source(value) : source(value)) : value;\n\t\tvar i = (flags & EACH_INDEX_REACTIVE) === 0 ? index : source(index);\n\n\t\t/** @type {EachItem} */\n\t\tvar item = {\n\t\t\ti,\n\t\t\tv,\n\t\t\tk: key,\n\t\t\ta: null,\n\t\t\t// @ts-expect-error\n\t\t\te: null,\n\t\t\tprev,\n\t\t\tnext\n\t\t};\n\n\t\tcurrent_each_item = item;\n\t\titem.e = branch(() => render_fn(anchor, v, i), hydrating);\n\n\t\titem.e.prev = prev && prev.e;\n\t\titem.e.next = next && next.e;\n\n\t\tif (prev === null) {\n\t\t\tstate.first = item;\n\t\t} else {\n\t\t\tprev.next = item;\n\t\t\tprev.e.next = item.e;\n\t\t}\n\n\t\tif (next !== null) {\n\t\t\tnext.prev = item;\n\t\t\tnext.e.prev = item.e;\n\t\t}\n\n\t\treturn item;\n\t} finally {\n\t\tcurrent_each_item = previous_each_item;\n\t}\n}\n\n/**\n * @param {EachItem} item\n * @param {EachItem | null} next\n * @param {Text | Element | Comment} anchor\n */\nfunction move(item, next, anchor) {\n\tvar end = item.next ? /** @type {TemplateNode} */ (item.next.e.nodes_start) : anchor;\n\n\tvar dest = next ? /** @type {TemplateNode} */ (next.e.nodes_start) : anchor;\n\tvar node = /** @type {TemplateNode} */ (item.e.nodes_start);\n\n\twhile (node !== end) {\n\t\tvar next_node = /** @type {TemplateNode} */ (get_next_sibling(node));\n\t\tdest.before(node);\n\t\tnode = next_node;\n\t}\n}\n\n/**\n * @param {EachState} state\n * @param {EachItem | null} prev\n * @param {EachItem | null} next\n */\nfunction link(state, prev, next) {\n\tif (prev === null) {\n\t\tstate.first = next;\n\t} else {\n\t\tprev.next = next;\n\t\tprev.e.next = next && next.e;\n\t}\n\n\tif (next !== null) {\n\t\tnext.prev = prev;\n\t\tnext.e.prev = prev && prev.e;\n\t}\n}\n","import { hydrate_next, hydrating } from '../hydration.js';\n\n/**\n * @param {Comment} anchor\n * @param {Record<string, any>} $$props\n * @param {string} name\n * @param {Record<string, unknown>} slot_props\n * @param {null | ((anchor: Comment) => void)} fallback_fn\n */\nexport function slot(anchor, $$props, name, slot_props, fallback_fn) {\n\tif (hydrating) {\n\t\thydrate_next();\n\t}\n\n\tvar slot_fn = $$props.$$slots?.[name];\n\t// Interop: Can use snippets to fill slots\n\tvar is_interop = false;\n\tif (slot_fn === true) {\n\t\tslot_fn = $$props[name === 'default' ? 'children' : name];\n\t\tis_interop = true;\n\t}\n\n\tif (slot_fn === undefined) {\n\t\tif (fallback_fn !== null) {\n\t\t\tfallback_fn(anchor);\n\t\t}\n\t} else {\n\t\tslot_fn(anchor, is_interop ? () => slot_props : slot_props);\n\t}\n}\n\n/**\n * @param {Record<string, any>} props\n * @returns {Record<string, boolean>}\n */\nexport function sanitize_slots(props) {\n\t/** @type {Record<string, boolean>} */\n\tconst sanitized = {};\n\tif (props.children) sanitized.default = true;\n\tfor (const key in props.$$slots) {\n\t\tsanitized[key] = true;\n\t}\n\treturn sanitized;\n}\n","/** @import { Snippet } from 'svelte' */\n/** @import { Effect, TemplateNode } from '#client' */\n/** @import { Getters } from '#shared' */\nimport { EFFECT_TRANSPARENT } from '../../constants.js';\nimport { branch, block, destroy_effect, teardown } from '../../reactivity/effects.js';\nimport {\n\tdev_current_component_function,\n\tset_dev_current_component_function\n} from '../../runtime.js';\nimport { hydrate_next, hydrate_node, hydrating } from '../hydration.js';\nimport { create_fragment_from_html } from '../reconciler.js';\nimport { assign_nodes } from '../template.js';\nimport * as w from '../../warnings.js';\nimport * as e from '../../errors.js';\nimport { DEV } from 'esm-env';\nimport { get_first_child, get_next_sibling } from '../operations.js';\nimport { noop } from '../../../shared/utils.js';\n\n/**\n * @template {(node: TemplateNode, ...args: any[]) => void} SnippetFn\n * @param {TemplateNode} node\n * @param {() => SnippetFn | null | undefined} get_snippet\n * @param {(() => any)[]} args\n * @returns {void}\n */\nexport function snippet(node, get_snippet, ...args) {\n\tvar anchor = node;\n\n\t/** @type {SnippetFn | null | undefined} */\n\t// @ts-ignore\n\tvar snippet = noop;\n\n\t/** @type {Effect | null} */\n\tvar snippet_effect;\n\n\tblock(() => {\n\t\tif (snippet === (snippet = get_snippet())) return;\n\n\t\tif (snippet_effect) {\n\t\t\tdestroy_effect(snippet_effect);\n\t\t\tsnippet_effect = null;\n\t\t}\n\n\t\tif (DEV && snippet == null) {\n\t\t\te.invalid_snippet();\n\t\t}\n\n\t\tsnippet_effect = branch(() => /** @type {SnippetFn} */ (snippet)(anchor, ...args));\n\t}, EFFECT_TRANSPARENT);\n\n\tif (hydrating) {\n\t\tanchor = hydrate_node;\n\t}\n}\n\n/**\n * In development, wrap the snippet function so that it passes validation, and so that the\n * correct component context is set for ownership checks\n * @param {any} component\n * @param {(node: TemplateNode, ...args: any[]) => void} fn\n */\nexport function wrap_snippet(component, fn) {\n\treturn (/** @type {TemplateNode} */ node, /** @type {any[]} */ ...args) => {\n\t\tvar previous_component_function = dev_current_component_function;\n\t\tset_dev_current_component_function(component);\n\n\t\ttry {\n\t\t\treturn fn(node, ...args);\n\t\t} finally {\n\t\t\tset_dev_current_component_function(previous_component_function);\n\t\t}\n\t};\n}\n\n/**\n * Create a snippet programmatically\n * @template {unknown[]} Params\n * @param {(...params: Getters<Params>) => {\n *   render: () => string\n *   setup?: (element: Element) => void | (() => void)\n * }} fn\n * @returns {Snippet<Params>}\n */\nexport function createRawSnippet(fn) {\n\t// @ts-expect-error the types are a lie\n\treturn (/** @type {TemplateNode} */ anchor, /** @type {Getters<Params>} */ ...params) => {\n\t\tvar snippet = fn(...params);\n\n\t\t/** @type {Element} */\n\t\tvar element;\n\n\t\tif (hydrating) {\n\t\t\telement = /** @type {Element} */ (hydrate_node);\n\t\t\thydrate_next();\n\t\t} else {\n\t\t\tvar html = snippet.render().trim();\n\t\t\tvar fragment = create_fragment_from_html(html);\n\t\t\telement = /** @type {Element} */ (get_first_child(fragment));\n\n\t\t\tif (DEV && (get_next_sibling(element) !== null || element.nodeType !== 1)) {\n\t\t\t\tw.invalid_raw_snippet_render();\n\t\t\t}\n\n\t\t\tanchor.before(element);\n\t\t}\n\n\t\tconst result = snippet.setup?.(element);\n\t\tassign_nodes(element, element);\n\n\t\tif (typeof result === 'function') {\n\t\t\tteardown(result);\n\t\t}\n\t};\n}\n","/** @import { TemplateNode, Dom, Effect } from '#client' */\nimport { EFFECT_TRANSPARENT } from '../../constants.js';\nimport { block, branch, pause_effect } from '../../reactivity/effects.js';\nimport { hydrate_next, hydrate_node, hydrating } from '../hydration.js';\n\n/**\n * @template P\n * @template {(props: P) => void} C\n * @param {TemplateNode} node\n * @param {() => C} get_component\n * @param {(anchor: TemplateNode, component: C) => Dom | void} render_fn\n * @returns {void}\n */\nexport function component(node, get_component, render_fn) {\n\tif (hydrating) {\n\t\thydrate_next();\n\t}\n\n\tvar anchor = node;\n\n\t/** @type {C} */\n\tvar component;\n\n\t/** @type {Effect | null} */\n\tvar effect;\n\n\tblock(() => {\n\t\tif (component === (component = get_component())) return;\n\n\t\tif (effect) {\n\t\t\tpause_effect(effect);\n\t\t\teffect = null;\n\t\t}\n\n\t\tif (component) {\n\t\t\teffect = branch(() => render_fn(anchor, component));\n\t\t}\n\t}, EFFECT_TRANSPARENT);\n\n\tif (hydrating) {\n\t\tanchor = hydrate_node;\n\t}\n}\n","/** @import { Effect, TemplateNode } from '#client' */\nimport { FILENAME, NAMESPACE_SVG } from '../../../../constants.js';\nimport {\n\thydrate_next,\n\thydrate_node,\n\thydrating,\n\tset_hydrate_node,\n\tset_hydrating\n} from '../hydration.js';\nimport { create_text, get_first_child } from '../operations.js';\nimport {\n\tblock,\n\tbranch,\n\tdestroy_effect,\n\tpause_effect,\n\tresume_effect\n} from '../../reactivity/effects.js';\nimport { set_should_intro } from '../../render.js';\nimport { current_each_item, set_current_each_item } from './each.js';\nimport { component_context, active_effect } from '../../runtime.js';\nimport { DEV } from 'esm-env';\nimport { EFFECT_TRANSPARENT } from '../../constants.js';\nimport { assign_nodes } from '../template.js';\n\n/**\n * @param {Comment | Element} node\n * @param {() => string} get_tag\n * @param {boolean} is_svg\n * @param {undefined | ((element: Element, anchor: Node | null) => void)} render_fn,\n * @param {undefined | (() => string)} get_namespace\n * @param {undefined | [number, number]} location\n * @returns {void}\n */\nexport function element(node, get_tag, is_svg, render_fn, get_namespace, location) {\n\tlet was_hydrating = hydrating;\n\n\tif (hydrating) {\n\t\thydrate_next();\n\t}\n\n\tvar filename = DEV && location && component_context?.function[FILENAME];\n\n\t/** @type {string | null} */\n\tvar tag;\n\n\t/** @type {string | null} */\n\tvar current_tag;\n\n\t/** @type {null | Element} */\n\tvar element = null;\n\n\tif (hydrating && hydrate_node.nodeType === 1) {\n\t\telement = /** @type {Element} */ (hydrate_node);\n\t\thydrate_next();\n\t}\n\n\tvar anchor = /** @type {TemplateNode} */ (hydrating ? hydrate_node : node);\n\n\t/** @type {Effect | null} */\n\tvar effect;\n\n\t/**\n\t * The keyed `{#each ...}` item block, if any, that this element is inside.\n\t * We track this so we can set it when changing the element, allowing any\n\t * `animate:` directive to bind itself to the correct block\n\t */\n\tvar each_item_block = current_each_item;\n\n\tblock(() => {\n\t\tconst next_tag = get_tag() || null;\n\t\tvar ns = get_namespace ? get_namespace() : is_svg || next_tag === 'svg' ? NAMESPACE_SVG : null;\n\n\t\t// Assumption: Noone changes the namespace but not the tag (what would that even mean?)\n\t\tif (next_tag === tag) return;\n\n\t\t// See explanation of `each_item_block` above\n\t\tvar previous_each_item = current_each_item;\n\t\tset_current_each_item(each_item_block);\n\n\t\tif (effect) {\n\t\t\tif (next_tag === null) {\n\t\t\t\t// start outro\n\t\t\t\tpause_effect(effect, () => {\n\t\t\t\t\teffect = null;\n\t\t\t\t\tcurrent_tag = null;\n\t\t\t\t});\n\t\t\t} else if (next_tag === current_tag) {\n\t\t\t\t// same tag as is currently rendered  abort outro\n\t\t\t\tresume_effect(effect);\n\t\t\t} else {\n\t\t\t\t// tag is changing  destroy immediately, render contents without intro transitions\n\t\t\t\tdestroy_effect(effect);\n\t\t\t\tset_should_intro(false);\n\t\t\t}\n\t\t}\n\n\t\tif (next_tag && next_tag !== current_tag) {\n\t\t\teffect = branch(() => {\n\t\t\t\telement = hydrating\n\t\t\t\t\t? /** @type {Element} */ (element)\n\t\t\t\t\t: ns\n\t\t\t\t\t\t? document.createElementNS(ns, next_tag)\n\t\t\t\t\t\t: document.createElement(next_tag);\n\n\t\t\t\tif (DEV && location) {\n\t\t\t\t\t// @ts-expect-error\n\t\t\t\t\telement.__svelte_meta = {\n\t\t\t\t\t\tloc: {\n\t\t\t\t\t\t\tfile: filename,\n\t\t\t\t\t\t\tline: location[0],\n\t\t\t\t\t\t\tcolumn: location[1]\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t}\n\n\t\t\t\tassign_nodes(element, element);\n\n\t\t\t\tif (render_fn) {\n\t\t\t\t\t// If hydrating, use the existing ssr comment as the anchor so that the\n\t\t\t\t\t// inner open and close methods can pick up the existing nodes correctly\n\t\t\t\t\tvar child_anchor = /** @type {TemplateNode} */ (\n\t\t\t\t\t\thydrating ? get_first_child(element) : element.appendChild(create_text())\n\t\t\t\t\t);\n\n\t\t\t\t\tif (hydrating) {\n\t\t\t\t\t\tif (child_anchor === null) {\n\t\t\t\t\t\t\tset_hydrating(false);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tset_hydrate_node(child_anchor);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// `child_anchor` is undefined if this is a void element, but we still\n\t\t\t\t\t// need to call `render_fn` in order to run actions etc. If the element\n\t\t\t\t\t// contains children, it's a user error (which is warned on elsewhere)\n\t\t\t\t\t// and the DOM will be silently discarded\n\t\t\t\t\trender_fn(element, child_anchor);\n\t\t\t\t}\n\n\t\t\t\t// we do this after calling `render_fn` so that child effects don't override `nodes.end`\n\t\t\t\t/** @type {Effect} */ (active_effect).nodes_end = element;\n\n\t\t\t\tanchor.before(element);\n\t\t\t});\n\t\t}\n\n\t\ttag = next_tag;\n\t\tif (tag) current_tag = tag;\n\t\tset_should_intro(true);\n\n\t\tset_current_each_item(previous_each_item);\n\t}, EFFECT_TRANSPARENT);\n\n\tif (was_hydrating) {\n\t\tset_hydrating(true);\n\t\tset_hydrate_node(anchor);\n\t}\n}\n","/** @import { ActionPayload } from '#client' */\nimport { effect, render_effect } from '../../reactivity/effects.js';\nimport { safe_not_equal } from '../../reactivity/equality.js';\nimport { deep_read_state, untrack } from '../../runtime.js';\n\n/**\n * @template P\n * @param {Element} dom\n * @param {(dom: Element, value?: P) => ActionPayload<P>} action\n * @param {() => P} [get_value]\n * @returns {void}\n */\nexport function action(dom, action, get_value) {\n\teffect(() => {\n\t\tvar payload = untrack(() => action(dom, get_value?.()) || {});\n\n\t\tif (get_value && payload?.update) {\n\t\t\tvar inited = false;\n\t\t\t/** @type {P} */\n\t\t\tvar prev = /** @type {any} */ ({}); // initialize with something so it's never equal on first run\n\n\t\t\trender_effect(() => {\n\t\t\t\tvar value = get_value();\n\n\t\t\t\t// Action's update method is coarse-grained, i.e. when anything in the passed value changes, update.\n\t\t\t\t// This works in legacy mode because of mutable_source being updated as a whole, but when using $state\n\t\t\t\t// together with actions and mutation, it wouldn't notice the change without a deep read.\n\t\t\t\tdeep_read_state(value);\n\n\t\t\t\tif (inited && safe_not_equal(prev, value)) {\n\t\t\t\t\tprev = value;\n\t\t\t\t\t/** @type {Function} */ (payload.update)(value);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tinited = true;\n\t\t}\n\n\t\tif (payload?.destroy) {\n\t\t\treturn () => /** @type {Function} */ (payload.destroy)();\n\t\t}\n\t});\n}\n","import { hydrating } from '../hydration.js';\nimport { clear_text_content, get_first_child } from '../operations.js';\nimport { queue_micro_task } from '../task.js';\n\n/**\n * @param {HTMLElement} dom\n * @param {boolean} value\n * @returns {void}\n */\nexport function autofocus(dom, value) {\n\tif (value) {\n\t\tconst body = document.body;\n\t\tdom.autofocus = true;\n\n\t\tqueue_micro_task(() => {\n\t\t\tif (document.activeElement === body) {\n\t\t\t\tdom.focus();\n\t\t\t}\n\t\t});\n\t}\n}\n\n/**\n * The child of a textarea actually corresponds to the defaultValue property, so we need\n * to remove it upon hydration to avoid a bug when someone resets the form value.\n * @param {HTMLTextAreaElement} dom\n * @returns {void}\n */\nexport function remove_textarea_child(dom) {\n\tif (hydrating && get_first_child(dom) !== null) {\n\t\tclear_text_content(dom);\n\t}\n}\n\nlet listening_to_form_reset = false;\n\nexport function add_form_reset_listener() {\n\tif (!listening_to_form_reset) {\n\t\tlistening_to_form_reset = true;\n\t\tdocument.addEventListener(\n\t\t\t'reset',\n\t\t\t(evt) => {\n\t\t\t\t// Needs to happen one tick later or else the dom properties of the form\n\t\t\t\t// elements have not updated to their reset values yet\n\t\t\t\tPromise.resolve().then(() => {\n\t\t\t\t\tif (!evt.defaultPrevented) {\n\t\t\t\t\t\tfor (const e of /**@type {HTMLFormElement} */ (evt.target).elements) {\n\t\t\t\t\t\t\t// @ts-expect-error\n\t\t\t\t\t\t\te.__on_r?.();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t},\n\t\t\t// In the capture phase to guarantee we get noticed of it (no possiblity of stopPropagation)\n\t\t\t{ capture: true }\n\t\t);\n\t}\n}\n","import { DEV } from 'esm-env';\nimport { hydrating } from '../hydration.js';\nimport { get_descriptors, get_prototype_of } from '../../../shared/utils.js';\nimport { create_event, delegate } from './events.js';\nimport { add_form_reset_listener, autofocus } from './misc.js';\nimport * as w from '../../warnings.js';\nimport { LOADING_ATTR_SYMBOL } from '../../constants.js';\nimport { queue_idle_task, queue_micro_task } from '../task.js';\nimport { is_capture_event, is_delegated, normalize_attribute } from '../../../../utils.js';\n\n/**\n * The value/checked attribute in the template actually corresponds to the defaultValue property, so we need\n * to remove it upon hydration to avoid a bug when someone resets the form value.\n * @param {HTMLInputElement} input\n * @returns {void}\n */\nexport function remove_input_defaults(input) {\n\tif (!hydrating) return;\n\n\tvar already_removed = false;\n\n\t// We try and remove the default attributes later, rather than sync during hydration.\n\t// Doing it sync during hydration has a negative impact on performance, but deferring the\n\t// work in an idle task alleviates this greatly. If a form reset event comes in before\n\t// the idle callback, then we ensure the input defaults are cleared just before.\n\tvar remove_defaults = () => {\n\t\tif (already_removed) return;\n\t\talready_removed = true;\n\n\t\t// Remove the attributes but preserve the values\n\t\tif (input.hasAttribute('value')) {\n\t\t\tvar value = input.value;\n\t\t\tset_attribute(input, 'value', null);\n\t\t\tinput.value = value;\n\t\t}\n\n\t\tif (input.hasAttribute('checked')) {\n\t\t\tvar checked = input.checked;\n\t\t\tset_attribute(input, 'checked', null);\n\t\t\tinput.checked = checked;\n\t\t}\n\t};\n\n\t// @ts-expect-error\n\tinput.__on_r = remove_defaults;\n\tqueue_idle_task(remove_defaults);\n\tadd_form_reset_listener();\n}\n\n/**\n * @param {Element} element\n * @param {any} value\n */\nexport function set_value(element, value) {\n\t// @ts-expect-error\n\tvar attributes = (element.__attributes ??= {});\n\t// @ts-expect-error\n\tif (attributes.value === (attributes.value = value) || element.value === value) return;\n\t// @ts-expect-error\n\telement.value = value;\n}\n\n/**\n * @param {Element} element\n * @param {boolean} checked\n */\nexport function set_checked(element, checked) {\n\t// @ts-expect-error\n\tvar attributes = (element.__attributes ??= {});\n\n\tif (attributes.checked === (attributes.checked = checked)) return;\n\t// @ts-expect-error\n\telement.checked = checked;\n}\n\n/**\n * @param {Element} element\n * @param {string} attribute\n * @param {string | null} value\n * @param {boolean} [skip_warning]\n */\nexport function set_attribute(element, attribute, value, skip_warning) {\n\t// @ts-expect-error\n\tvar attributes = (element.__attributes ??= {});\n\n\tif (hydrating) {\n\t\tattributes[attribute] = element.getAttribute(attribute);\n\n\t\tif (\n\t\t\tattribute === 'src' ||\n\t\t\tattribute === 'srcset' ||\n\t\t\t(attribute === 'href' && element.nodeName === 'LINK')\n\t\t) {\n\t\t\tif (!skip_warning) {\n\t\t\t\tcheck_src_in_dev_hydration(element, attribute, value ?? '');\n\t\t\t}\n\n\t\t\t// If we reset these attributes, they would result in another network request, which we want to avoid.\n\t\t\t// We assume they are the same between client and server as checking if they are equal is expensive\n\t\t\t// (we can't just compare the strings as they can be different between client and server but result in the\n\t\t\t// same url, so we would need to create hidden anchor elements to compare them)\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (attributes[attribute] === (attributes[attribute] = value)) return;\n\n\tif (attribute === 'loading') {\n\t\t// @ts-expect-error\n\t\telement[LOADING_ATTR_SYMBOL] = value;\n\t}\n\n\tif (value == null) {\n\t\telement.removeAttribute(attribute);\n\t} else if (typeof value !== 'string' && get_setters(element).includes(attribute)) {\n\t\t// @ts-ignore\n\t\telement[attribute] = value;\n\t} else {\n\t\telement.setAttribute(attribute, value);\n\t}\n}\n\n/**\n * @param {Element} dom\n * @param {string} attribute\n * @param {string} value\n */\nexport function set_xlink_attribute(dom, attribute, value) {\n\tdom.setAttributeNS('http://www.w3.org/1999/xlink', attribute, value);\n}\n\n/**\n * @param {any} node\n * @param {string} prop\n * @param {any} value\n */\nexport function set_custom_element_data(node, prop, value) {\n\tif (get_setters(node).includes(prop)) {\n\t\tnode[prop] = value;\n\t} else {\n\t\tset_attribute(node, prop, value);\n\t}\n}\n\n/**\n * Spreads attributes onto a DOM element, taking into account the currently set attributes\n * @param {Element & ElementCSSInlineStyle} element\n * @param {Record<string, any> | undefined} prev\n * @param {Record<string, any>} next New attributes - this function mutates this object\n * @param {string} [css_hash]\n * @param {boolean} [preserve_attribute_case]\n * @param {boolean} [is_custom_element]\n * @param {boolean} [skip_warning]\n * @returns {Record<string, any>}\n */\nexport function set_attributes(\n\telement,\n\tprev,\n\tnext,\n\tcss_hash,\n\tpreserve_attribute_case = false,\n\tis_custom_element = false,\n\tskip_warning = false\n) {\n\tvar current = prev || {};\n\tvar is_option_element = element.tagName === 'OPTION';\n\n\tfor (var key in prev) {\n\t\tif (!(key in next)) {\n\t\t\tnext[key] = null;\n\t\t}\n\t}\n\n\tif (css_hash !== undefined) {\n\t\tnext.class = next.class ? next.class + ' ' + css_hash : css_hash;\n\t}\n\n\tvar setters = get_setters(element);\n\n\t// @ts-expect-error\n\tvar attributes = /** @type {Record<string, unknown>} **/ (element.__attributes ??= {});\n\t/** @type {Array<[string, any, () => void]>} */\n\tvar events = [];\n\n\t// since key is captured we use const\n\tfor (const key in next) {\n\t\t// let instead of var because referenced in a closure\n\t\tlet value = next[key];\n\n\t\t// Up here because we want to do this for the initial value, too, even if it's undefined,\n\t\t// and this wouldn't be reached in case of undefined because of the equality check below\n\t\tif (is_option_element && key === 'value' && value == null) {\n\t\t\t// The <option> element is a special case because removing the value attribute means\n\t\t\t// the value is set to the text content of the option element, and setting the value\n\t\t\t// to null or undefined means the value is set to the string \"null\" or \"undefined\".\n\t\t\t// To align with how we handle this case in non-spread-scenarios, this logic is needed.\n\t\t\t// There's a super-edge-case bug here that is left in in favor of smaller code size:\n\t\t\t// Because of the \"set missing props to null\" logic above, we can't differentiate\n\t\t\t// between a missing value and an explicitly set value of null or undefined. That means\n\t\t\t// that once set, the value attribute of an <option> element can't be removed. This is\n\t\t\t// a very rare edge case, and removing the attribute altogether isn't possible either\n\t\t\t// for the <option value={undefined}> case, so we're not losing any functionality here.\n\t\t\t// @ts-ignore\n\t\t\telement.value = element.__value = '';\n\t\t\tcurrent[key] = value;\n\t\t\tcontinue;\n\t\t}\n\n\t\tvar prev_value = current[key];\n\t\tif (value === prev_value) continue;\n\n\t\tcurrent[key] = value;\n\n\t\tvar prefix = key[0] + key[1]; // this is faster than key.slice(0, 2)\n\t\tif (prefix === '$$') continue;\n\n\t\tif (prefix === 'on') {\n\t\t\t/** @type {{ capture?: true }} */\n\t\t\tconst opts = {};\n\t\t\tconst event_handle_key = '$$' + key;\n\t\t\tlet event_name = key.slice(2);\n\t\t\tvar delegated = is_delegated(event_name);\n\n\t\t\tif (is_capture_event(event_name)) {\n\t\t\t\tevent_name = event_name.slice(0, -7);\n\t\t\t\topts.capture = true;\n\t\t\t}\n\n\t\t\tif (!delegated && prev_value) {\n\t\t\t\t// Listening to same event but different handler -> our handle function below takes care of this\n\t\t\t\t// If we were to remove and add listeners in this case, it could happen that the event is \"swallowed\"\n\t\t\t\t// (the browser seems to not know yet that a new one exists now) and doesn't reach the handler\n\t\t\t\t// https://github.com/sveltejs/svelte/issues/11903\n\t\t\t\tif (value != null) continue;\n\n\t\t\t\telement.removeEventListener(event_name, current[event_handle_key], opts);\n\t\t\t\tcurrent[event_handle_key] = null;\n\t\t\t}\n\n\t\t\tif (value != null) {\n\t\t\t\tif (!delegated) {\n\t\t\t\t\t/**\n\t\t\t\t\t * @this {any}\n\t\t\t\t\t * @param {Event} evt\n\t\t\t\t\t */\n\t\t\t\t\tfunction handle(evt) {\n\t\t\t\t\t\tcurrent[key].call(this, evt);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!prev) {\n\t\t\t\t\t\tevents.push([\n\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\tvalue,\n\t\t\t\t\t\t\t() => (current[event_handle_key] = create_event(event_name, element, handle, opts))\n\t\t\t\t\t\t]);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcurrent[event_handle_key] = create_event(event_name, element, handle, opts);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// @ts-ignore\n\t\t\t\t\telement[`__${event_name}`] = value;\n\t\t\t\t\tdelegate([event_name]);\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (key === 'style' && value != null) {\n\t\t\telement.style.cssText = value + '';\n\t\t} else if (key === 'autofocus') {\n\t\t\tautofocus(/** @type {HTMLElement} */ (element), Boolean(value));\n\t\t} else if (key === '__value' || (key === 'value' && value != null)) {\n\t\t\t// @ts-ignore\n\t\t\telement.value = element[key] = element.__value = value;\n\t\t} else {\n\t\t\tvar name = key;\n\t\t\tif (!preserve_attribute_case) {\n\t\t\t\tname = normalize_attribute(name);\n\t\t\t}\n\n\t\t\tif (value == null && !is_custom_element) {\n\t\t\t\tattributes[key] = null;\n\t\t\t\telement.removeAttribute(key);\n\t\t\t} else if (setters.includes(name) && (is_custom_element || typeof value !== 'string')) {\n\t\t\t\t// @ts-ignore\n\t\t\t\telement[name] = value;\n\t\t\t} else if (typeof value !== 'function') {\n\t\t\t\tif (hydrating && (name === 'src' || name === 'href' || name === 'srcset')) {\n\t\t\t\t\tif (!skip_warning) check_src_in_dev_hydration(element, name, value ?? '');\n\t\t\t\t} else {\n\t\t\t\t\tset_attribute(element, name, value);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// On the first run, ensure that events are added after bindings so\n\t// that their listeners fire after the binding listeners\n\tif (!prev) {\n\t\tqueue_micro_task(() => {\n\t\t\tif (!element.isConnected) return;\n\t\t\tfor (const [key, value, evt] of events) {\n\t\t\t\tif (current[key] === value) {\n\t\t\t\t\tevt();\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n\n\treturn current;\n}\n\n/** @type {Map<string, string[]>} */\nvar setters_cache = new Map();\n\n/** @param {Element} element */\nfunction get_setters(element) {\n\tvar setters = setters_cache.get(element.nodeName);\n\tif (setters) return setters;\n\tsetters_cache.set(element.nodeName, (setters = []));\n\tvar descriptors;\n\tvar proto = get_prototype_of(element);\n\tvar element_proto = Element.prototype;\n\n\t// Stop at Element, from there on there's only unnecessary setters we're not interested in\n\t// Do not use contructor.name here as that's unreliable in some browser environments\n\twhile (element_proto !== proto) {\n\t\tdescriptors = get_descriptors(proto);\n\n\t\tfor (var key in descriptors) {\n\t\t\tif (descriptors[key].set) {\n\t\t\t\tsetters.push(key);\n\t\t\t}\n\t\t}\n\n\t\tproto = get_prototype_of(proto);\n\t}\n\n\treturn setters;\n}\n\n/**\n * @param {any} element\n * @param {string} attribute\n * @param {string} value\n */\nfunction check_src_in_dev_hydration(element, attribute, value) {\n\tif (!DEV) return;\n\tif (attribute === 'srcset' && srcset_url_equal(element, value)) return;\n\tif (src_url_equal(element.getAttribute(attribute) ?? '', value)) return;\n\n\tw.hydration_attribute_changed(\n\t\tattribute,\n\t\telement.outerHTML.replace(element.innerHTML, element.innerHTML && '...'),\n\t\tString(value)\n\t);\n}\n\n/**\n * @param {string} element_src\n * @param {string} url\n * @returns {boolean}\n */\nfunction src_url_equal(element_src, url) {\n\tif (element_src === url) return true;\n\treturn new URL(element_src, document.baseURI).href === new URL(url, document.baseURI).href;\n}\n\n/** @param {string} srcset */\nfunction split_srcset(srcset) {\n\treturn srcset.split(',').map((src) => src.trim().split(' ').filter(Boolean));\n}\n\n/**\n * @param {HTMLSourceElement | HTMLImageElement} element\n * @param {string} srcset\n * @returns {boolean}\n */\nfunction srcset_url_equal(element, srcset) {\n\tvar element_urls = split_srcset(element.srcset);\n\tvar urls = split_srcset(srcset);\n\n\treturn (\n\t\turls.length === element_urls.length &&\n\t\turls.every(\n\t\t\t([url, width], i) =>\n\t\t\t\twidth === element_urls[i][1] &&\n\t\t\t\t// We need to test both ways because Vite will create an a full URL with\n\t\t\t\t// `new URL(asset, import.meta.url).href` for the client when `base: './'`, and the\n\t\t\t\t// relative URLs inside srcset are not automatically resolved to absolute URLs by\n\t\t\t\t// browsers (in contrast to img.src). This means both SSR and DOM code could\n\t\t\t\t// contain relative or absolute URLs.\n\t\t\t\t(src_url_equal(element_urls[i][0], url) || src_url_equal(url, element_urls[i][0]))\n\t\t)\n\t);\n}\n\n/**\n * @param {HTMLImageElement} element\n * @returns {void}\n */\nexport function handle_lazy_img(element) {\n\t// If we're using an image that has a lazy loading attribute, we need to apply\n\t// the loading and src after the img element has been appended to the document.\n\t// Otherwise the lazy behaviour will not work due to our cloneNode heuristic for\n\t// templates.\n\tif (!hydrating && element.loading === 'lazy') {\n\t\tvar src = element.src;\n\t\t// @ts-expect-error\n\t\telement[LOADING_ATTR_SYMBOL] = null;\n\t\telement.loading = 'eager';\n\t\telement.removeAttribute('src');\n\t\trequestAnimationFrame(() => {\n\t\t\t// @ts-expect-error\n\t\t\tif (element[LOADING_ATTR_SYMBOL] !== 'eager') {\n\t\t\t\telement.loading = 'lazy';\n\t\t\t}\n\t\t\telement.src = src;\n\t\t});\n\t}\n}\n","import { hydrating } from '../hydration.js';\n\n/**\n * @param {SVGElement} dom\n * @param {string} value\n * @returns {void}\n */\nexport function set_svg_class(dom, value) {\n\t// @ts-expect-error need to add __className to patched prototype\n\tvar prev_class_name = dom.__className;\n\tvar next_class_name = to_class(value);\n\n\tif (hydrating && dom.getAttribute('class') === next_class_name) {\n\t\t// In case of hydration don't reset the class as it's already correct.\n\t\t// @ts-expect-error need to add __className to patched prototype\n\t\tdom.__className = next_class_name;\n\t} else if (\n\t\tprev_class_name !== next_class_name ||\n\t\t(hydrating && dom.getAttribute('class') !== next_class_name)\n\t) {\n\t\tif (next_class_name === '') {\n\t\t\tdom.removeAttribute('class');\n\t\t} else {\n\t\t\tdom.setAttribute('class', next_class_name);\n\t\t}\n\n\t\t// @ts-expect-error need to add __className to patched prototype\n\t\tdom.__className = next_class_name;\n\t}\n}\n\n/**\n * @param {MathMLElement} dom\n * @param {string} value\n * @returns {void}\n */\nexport function set_mathml_class(dom, value) {\n\t// @ts-expect-error need to add __className to patched prototype\n\tvar prev_class_name = dom.__className;\n\tvar next_class_name = to_class(value);\n\n\tif (hydrating && dom.getAttribute('class') === next_class_name) {\n\t\t// In case of hydration don't reset the class as it's already correct.\n\t\t// @ts-expect-error need to add __className to patched prototype\n\t\tdom.__className = next_class_name;\n\t} else if (\n\t\tprev_class_name !== next_class_name ||\n\t\t(hydrating && dom.getAttribute('class') !== next_class_name)\n\t) {\n\t\tif (next_class_name === '') {\n\t\t\tdom.removeAttribute('class');\n\t\t} else {\n\t\t\tdom.setAttribute('class', next_class_name);\n\t\t}\n\n\t\t// @ts-expect-error need to add __className to patched prototype\n\t\tdom.__className = next_class_name;\n\t}\n}\n\n/**\n * @param {HTMLElement} dom\n * @param {string} value\n * @returns {void}\n */\nexport function set_class(dom, value) {\n\t// @ts-expect-error need to add __className to patched prototype\n\tvar prev_class_name = dom.__className;\n\tvar next_class_name = to_class(value);\n\n\tif (hydrating && dom.className === next_class_name) {\n\t\t// In case of hydration don't reset the class as it's already correct.\n\t\t// @ts-expect-error need to add __className to patched prototype\n\t\tdom.__className = next_class_name;\n\t} else if (\n\t\tprev_class_name !== next_class_name ||\n\t\t(hydrating && dom.className !== next_class_name)\n\t) {\n\t\t// Removing the attribute when the value is only an empty string causes\n\t\t// peformance issues vs simply making the className an empty string. So\n\t\t// we should only remove the class if the the value is nullish.\n\t\tif (value == null) {\n\t\t\tdom.removeAttribute('class');\n\t\t} else {\n\t\t\tdom.className = next_class_name;\n\t\t}\n\n\t\t// @ts-expect-error need to add __className to patched prototype\n\t\tdom.__className = next_class_name;\n\t}\n}\n\n/**\n * @template V\n * @param {V} value\n * @returns {string | V}\n */\nfunction to_class(value) {\n\treturn value == null ? '' : value;\n}\n\n/**\n * @param {Element} dom\n * @param {string} class_name\n * @param {boolean} value\n * @returns {void}\n */\nexport function toggle_class(dom, class_name, value) {\n\tif (value) {\n\t\tif (dom.classList.contains(class_name)) return;\n\t\tdom.classList.add(class_name);\n\t} else {\n\t\tif (!dom.classList.contains(class_name)) return;\n\t\tdom.classList.remove(class_name);\n\t}\n}\n","/** @import { Raf } from '#client' */\nimport { noop } from '../shared/utils.js';\n\nimport { BROWSER } from 'esm-env';\n\nconst request_animation_frame = BROWSER ? requestAnimationFrame : noop;\n\nconst now = BROWSER ? () => performance.now() : () => Date.now();\n\n/** @type {Raf} */\nexport const raf = {\n\ttick: /** @param {any} _ */ (_) => request_animation_frame(_),\n\tnow: () => now(),\n\ttasks: new Set()\n};\n","/** @import { TaskCallback, Task, TaskEntry } from '#client' */\nimport { raf } from './timing.js';\n\n// TODO move this into timing.js where it probably belongs\n\n/**\n * @param {number} now\n * @returns {void}\n */\nfunction run_tasks(now) {\n\traf.tasks.forEach((task) => {\n\t\tif (!task.c(now)) {\n\t\t\traf.tasks.delete(task);\n\t\t\ttask.f();\n\t\t}\n\t});\n\n\tif (raf.tasks.size !== 0) {\n\t\traf.tick(run_tasks);\n\t}\n}\n\n/**\n * Creates a new task that runs on each raf frame\n * until it returns a falsy value or is aborted\n * @param {TaskCallback} callback\n * @returns {Task}\n */\nexport function loop(callback) {\n\t/** @type {TaskEntry} */\n\tlet task;\n\n\tif (raf.tasks.size === 0) {\n\t\traf.tick(run_tasks);\n\t}\n\n\treturn {\n\t\tpromise: new Promise((fulfill) => {\n\t\t\traf.tasks.add((task = { c: callback, f: fulfill }));\n\t\t}),\n\t\tabort() {\n\t\t\traf.tasks.delete(task);\n\t\t}\n\t};\n}\n","/** @import { AnimateFn, Animation, AnimationConfig, EachItem, Effect, TransitionFn, TransitionManager } from '#client' */\nimport { noop, is_function } from '../../../shared/utils.js';\nimport { effect } from '../../reactivity/effects.js';\nimport { active_effect, untrack } from '../../runtime.js';\nimport { loop } from '../../loop.js';\nimport { should_intro } from '../../render.js';\nimport { current_each_item } from '../blocks/each.js';\nimport { TRANSITION_GLOBAL, TRANSITION_IN, TRANSITION_OUT } from '../../../../constants.js';\nimport { BLOCK_EFFECT, EFFECT_RAN, EFFECT_TRANSPARENT } from '../../constants.js';\nimport { queue_micro_task } from '../task.js';\n\n/**\n * @param {Element} element\n * @param {'introstart' | 'introend' | 'outrostart' | 'outroend'} type\n * @returns {void}\n */\nfunction dispatch_event(element, type) {\n\telement.dispatchEvent(new CustomEvent(type));\n}\n\n/**\n * @param {string} style\n * @returns {string}\n */\nfunction css_style_from_camel_case(style) {\n\tconst parts = style.split('-');\n\tif (parts.length === 1) return parts[0];\n\treturn (\n\t\tparts[0] +\n\t\tparts\n\t\t\t.slice(1)\n\t\t\t.map(/** @param {any} word */ (word) => word[0].toUpperCase() + word.slice(1))\n\t\t\t.join('')\n\t);\n}\n\n/**\n * @param {string} css\n * @returns {Keyframe}\n */\nfunction css_to_keyframe(css) {\n\t/** @type {Keyframe} */\n\tconst keyframe = {};\n\tconst parts = css.split(';');\n\tfor (const part of parts) {\n\t\tconst [property, value] = part.split(':');\n\t\tif (!property || value === undefined) break;\n\n\t\tconst formatted_property = css_style_from_camel_case(property.trim());\n\t\tkeyframe[formatted_property] = value.trim();\n\t}\n\treturn keyframe;\n}\n\n/** @param {number} t */\nconst linear = (t) => t;\n\n/**\n * Called inside keyed `{#each ...}` blocks (as `$.animation(...)`). This creates an animation manager\n * and attaches it to the block, so that moves can be animated following reconciliation.\n * @template P\n * @param {Element} element\n * @param {() => AnimateFn<P | undefined>} get_fn\n * @param {(() => P) | null} get_params\n */\nexport function animation(element, get_fn, get_params) {\n\tvar item = /** @type {EachItem} */ (current_each_item);\n\n\t/** @type {DOMRect} */\n\tvar from;\n\n\t/** @type {DOMRect} */\n\tvar to;\n\n\t/** @type {Animation | undefined} */\n\tvar animation;\n\n\t/** @type {null | { position: string, width: string, height: string, transform: string }} */\n\tvar original_styles = null;\n\n\titem.a ??= {\n\t\telement,\n\t\tmeasure() {\n\t\t\tfrom = this.element.getBoundingClientRect();\n\t\t},\n\t\tapply() {\n\t\t\tanimation?.abort();\n\n\t\t\tto = this.element.getBoundingClientRect();\n\n\t\t\tif (\n\t\t\t\tfrom.left !== to.left ||\n\t\t\t\tfrom.right !== to.right ||\n\t\t\t\tfrom.top !== to.top ||\n\t\t\t\tfrom.bottom !== to.bottom\n\t\t\t) {\n\t\t\t\tconst options = get_fn()(this.element, { from, to }, get_params?.());\n\n\t\t\t\tanimation = animate(this.element, options, undefined, 1, () => {\n\t\t\t\t\tanimation?.abort();\n\t\t\t\t\tanimation = undefined;\n\t\t\t\t});\n\t\t\t}\n\t\t},\n\t\tfix() {\n\t\t\t// If an animation is already running, transforming the element is likely to fail,\n\t\t\t// because the styles applied by the animation take precedence. In the case of crossfade,\n\t\t\t// that means the `translate(...)` of the crossfade transition overrules the `translate(...)`\n\t\t\t// we would apply below, leading to the element jumping somewhere to the top left.\n\t\t\tif (element.getAnimations().length) return;\n\n\t\t\t// It's important to destructure these to get fixed values - the object itself has getters,\n\t\t\t// and changing the style to 'absolute' can for example influence the width.\n\t\t\tvar { position, width, height } = getComputedStyle(element);\n\n\t\t\tif (position !== 'absolute' && position !== 'fixed') {\n\t\t\t\tvar style = /** @type {HTMLElement | SVGElement} */ (element).style;\n\n\t\t\t\toriginal_styles = {\n\t\t\t\t\tposition: style.position,\n\t\t\t\t\twidth: style.width,\n\t\t\t\t\theight: style.height,\n\t\t\t\t\ttransform: style.transform\n\t\t\t\t};\n\n\t\t\t\tstyle.position = 'absolute';\n\t\t\t\tstyle.width = width;\n\t\t\t\tstyle.height = height;\n\t\t\t\tvar to = element.getBoundingClientRect();\n\n\t\t\t\tif (from.left !== to.left || from.top !== to.top) {\n\t\t\t\t\tvar transform = `translate(${from.left - to.left}px, ${from.top - to.top}px)`;\n\t\t\t\t\tstyle.transform = style.transform ? `${style.transform} ${transform}` : transform;\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\tunfix() {\n\t\t\tif (original_styles) {\n\t\t\t\tvar style = /** @type {HTMLElement | SVGElement} */ (element).style;\n\n\t\t\t\tstyle.position = original_styles.position;\n\t\t\t\tstyle.width = original_styles.width;\n\t\t\t\tstyle.height = original_styles.height;\n\t\t\t\tstyle.transform = original_styles.transform;\n\t\t\t}\n\t\t}\n\t};\n\n\t// in the case of a `<svelte:element>`, it's possible for `$.animation(...)` to be called\n\t// when an animation manager already exists, if the tag changes. in that case, we need to\n\t// swap out the element rather than creating a new manager, in case it happened at the same\n\t// moment as a reconciliation\n\titem.a.element = element;\n}\n\n/**\n * Called inside block effects as `$.transition(...)`. This creates a transition manager and\n * attaches it to the current effect  later, inside `pause_effect` and `resume_effect`, we\n * use this to create `intro` and `outro` transitions.\n * @template P\n * @param {number} flags\n * @param {HTMLElement} element\n * @param {() => TransitionFn<P | undefined>} get_fn\n * @param {(() => P) | null} get_params\n * @returns {void}\n */\nexport function transition(flags, element, get_fn, get_params) {\n\tvar is_intro = (flags & TRANSITION_IN) !== 0;\n\tvar is_outro = (flags & TRANSITION_OUT) !== 0;\n\tvar is_both = is_intro && is_outro;\n\tvar is_global = (flags & TRANSITION_GLOBAL) !== 0;\n\n\t/** @type {'in' | 'out' | 'both'} */\n\tvar direction = is_both ? 'both' : is_intro ? 'in' : 'out';\n\n\t/** @type {AnimationConfig | ((opts: { direction: 'in' | 'out' }) => AnimationConfig) | undefined} */\n\tvar current_options;\n\n\tvar inert = element.inert;\n\n\t/** @type {Animation | undefined} */\n\tvar intro;\n\n\t/** @type {Animation | undefined} */\n\tvar outro;\n\n\tfunction get_options() {\n\t\t// If a transition is still ongoing, we use the existing options rather than generating\n\t\t// new ones. This ensures that reversible transitions reverse smoothly, rather than\n\t\t// jumping to a new spot because (for example) a different `duration` was used\n\t\treturn (current_options ??= get_fn()(element, get_params?.() ?? /** @type {P} */ ({}), {\n\t\t\tdirection\n\t\t}));\n\t}\n\n\t/** @type {TransitionManager} */\n\tvar transition = {\n\t\tis_global,\n\t\tin() {\n\t\t\telement.inert = inert;\n\n\t\t\tif (!is_intro) {\n\t\t\t\toutro?.abort();\n\t\t\t\toutro?.reset?.();\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (!is_outro) {\n\t\t\t\t// if we intro then outro then intro again, we want to abort the first intro,\n\t\t\t\t// if it's not a bidirectional transition\n\t\t\t\tintro?.abort();\n\t\t\t}\n\n\t\t\tdispatch_event(element, 'introstart');\n\n\t\t\tintro = animate(element, get_options(), outro, 1, () => {\n\t\t\t\tdispatch_event(element, 'introend');\n\n\t\t\t\t// Ensure we cancel the animation to prevent leaking\n\t\t\t\tintro?.abort();\n\t\t\t\tintro = current_options = undefined;\n\t\t\t});\n\t\t},\n\t\tout(fn) {\n\t\t\tif (!is_outro) {\n\t\t\t\tfn?.();\n\t\t\t\tcurrent_options = undefined;\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\telement.inert = true;\n\n\t\t\tdispatch_event(element, 'outrostart');\n\n\t\t\toutro = animate(element, get_options(), intro, 0, () => {\n\t\t\t\tdispatch_event(element, 'outroend');\n\t\t\t\tfn?.();\n\t\t\t});\n\t\t},\n\t\tstop: () => {\n\t\t\tintro?.abort();\n\t\t\toutro?.abort();\n\t\t}\n\t};\n\n\tvar e = /** @type {Effect} */ (active_effect);\n\n\t(e.transitions ??= []).push(transition);\n\n\t// if this is a local transition, we only want to run it if the parent (branch) effect's\n\t// parent (block) effect is where the state change happened. we can determine that by\n\t// looking at whether the block effect is currently initializing\n\tif (is_intro && should_intro) {\n\t\tvar run = is_global;\n\n\t\tif (!run) {\n\t\t\tvar block = /** @type {Effect | null} */ (e.parent);\n\n\t\t\t// skip over transparent blocks (e.g. snippets, else-if blocks)\n\t\t\twhile (block && (block.f & EFFECT_TRANSPARENT) !== 0) {\n\t\t\t\twhile ((block = block.parent)) {\n\t\t\t\t\tif ((block.f & BLOCK_EFFECT) !== 0) break;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\trun = !block || (block.f & EFFECT_RAN) !== 0;\n\t\t}\n\n\t\tif (run) {\n\t\t\teffect(() => {\n\t\t\t\tuntrack(() => transition.in());\n\t\t\t});\n\t\t}\n\t}\n}\n\n/**\n * Animates an element, according to the provided configuration\n * @param {Element} element\n * @param {AnimationConfig | ((opts: { direction: 'in' | 'out' }) => AnimationConfig)} options\n * @param {Animation | undefined} counterpart The corresponding intro/outro to this outro/intro\n * @param {number} t2 The target `t` value  `1` for intro, `0` for outro\n * @param {(() => void)} on_finish Called after successfully completing the animation\n * @returns {Animation}\n */\nfunction animate(element, options, counterpart, t2, on_finish) {\n\tvar is_intro = t2 === 1;\n\n\tif (is_function(options)) {\n\t\t// In the case of a deferred transition (such as `crossfade`), `option` will be\n\t\t// a function rather than an `AnimationConfig`. We need to call this function\n\t\t// once the DOM has been updated...\n\t\t/** @type {Animation} */\n\t\tvar a;\n\t\tvar aborted = false;\n\n\t\tqueue_micro_task(() => {\n\t\t\tif (aborted) return;\n\t\t\tvar o = options({ direction: is_intro ? 'in' : 'out' });\n\t\t\ta = animate(element, o, counterpart, t2, on_finish);\n\t\t});\n\n\t\t// ...but we want to do so without using `async`/`await` everywhere, so\n\t\t// we return a facade that allows everything to remain synchronous\n\t\treturn {\n\t\t\tabort: () => {\n\t\t\t\taborted = true;\n\t\t\t\ta?.abort();\n\t\t\t},\n\t\t\tdeactivate: () => a.deactivate(),\n\t\t\treset: () => a.reset(),\n\t\t\tt: () => a.t()\n\t\t};\n\t}\n\n\tcounterpart?.deactivate();\n\n\tif (!options?.duration) {\n\t\ton_finish();\n\n\t\treturn {\n\t\t\tabort: noop,\n\t\t\tdeactivate: noop,\n\t\t\treset: noop,\n\t\t\tt: () => t2\n\t\t};\n\t}\n\n\tconst { delay = 0, css, tick, easing = linear } = options;\n\n\tvar keyframes = [];\n\n\tif (is_intro && counterpart === undefined) {\n\t\tif (tick) {\n\t\t\ttick(0, 1); // TODO put in nested effect, to avoid interleaved reads/writes?\n\t\t}\n\n\t\tif (css) {\n\t\t\tvar styles = css_to_keyframe(css(0, 1));\n\t\t\tkeyframes.push(styles, styles);\n\t\t}\n\t}\n\n\tvar get_t = () => 1 - t2;\n\n\t// create a dummy animation that lasts as long as the delay (but with whatever devtools\n\t// multiplier is in effect). in the common case that it is `0`, we keep it anyway so that\n\t// the CSS keyframes aren't created until the DOM is updated\n\tvar animation = element.animate(keyframes, { duration: delay });\n\n\tanimation.onfinish = () => {\n\t\t// for bidirectional transitions, we start from the current position,\n\t\t// rather than doing a full intro/outro\n\t\tvar t1 = counterpart?.t() ?? 1 - t2;\n\t\tcounterpart?.abort();\n\n\t\tvar delta = t2 - t1;\n\t\tvar duration = /** @type {number} */ (options.duration) * Math.abs(delta);\n\t\tvar keyframes = [];\n\n\t\tif (duration > 0) {\n\t\t\tif (css) {\n\t\t\t\tvar n = Math.ceil(duration / (1000 / 60)); // `n` must be an integer, or we risk missing the `t2` value\n\n\t\t\t\tfor (var i = 0; i <= n; i += 1) {\n\t\t\t\t\tvar t = t1 + delta * easing(i / n);\n\t\t\t\t\tvar styles = css(t, 1 - t);\n\t\t\t\t\tkeyframes.push(css_to_keyframe(styles));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tget_t = () => {\n\t\t\t\tvar time = /** @type {number} */ (\n\t\t\t\t\t/** @type {globalThis.Animation} */ (animation).currentTime\n\t\t\t\t);\n\n\t\t\t\treturn t1 + delta * easing(time / duration);\n\t\t\t};\n\n\t\t\tif (tick) {\n\t\t\t\tloop(() => {\n\t\t\t\t\tif (animation.playState !== 'running') return false;\n\n\t\t\t\t\tvar t = get_t();\n\t\t\t\t\ttick(t, 1 - t);\n\n\t\t\t\t\treturn true;\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\tanimation = element.animate(keyframes, { duration, fill: 'forwards' });\n\n\t\tanimation.onfinish = () => {\n\t\t\tget_t = () => t2;\n\t\t\ttick?.(t2, 1 - t2);\n\t\t\ton_finish();\n\t\t};\n\t};\n\n\treturn {\n\t\tabort: () => {\n\t\t\tif (animation) {\n\t\t\t\tanimation.cancel();\n\t\t\t\t// This prevents memory leaks in Chromium\n\t\t\t\tanimation.effect = null;\n\t\t\t}\n\t\t},\n\t\tdeactivate: () => {\n\t\t\ton_finish = noop;\n\t\t},\n\t\treset: () => {\n\t\t\tif (t2 === 0) {\n\t\t\t\ttick?.(1, 0);\n\t\t\t}\n\t\t},\n\t\tt: () => get_t()\n\t};\n}\n","import { STATE_SYMBOL } from '../../../constants.js';\nimport { effect, render_effect } from '../../../reactivity/effects.js';\nimport { untrack } from '../../../runtime.js';\nimport { queue_micro_task } from '../../task.js';\n\n/**\n * @param {any} bound_value\n * @param {Element} element_or_component\n * @returns {boolean}\n */\nfunction is_bound_this(bound_value, element_or_component) {\n\treturn (\n\t\tbound_value === element_or_component || bound_value?.[STATE_SYMBOL] === element_or_component\n\t);\n}\n\n/**\n * @param {any} element_or_component\n * @param {(value: unknown, ...parts: unknown[]) => void} update\n * @param {(...parts: unknown[]) => unknown} get_value\n * @param {() => unknown[]} [get_parts] Set if the this binding is used inside an each block,\n * \t\t\t\t\t\t\t\t\t\treturns all the parts of the each block context that are used in the expression\n * @returns {void}\n */\nexport function bind_this(element_or_component = {}, update, get_value, get_parts) {\n\teffect(() => {\n\t\t/** @type {unknown[]} */\n\t\tvar old_parts;\n\n\t\t/** @type {unknown[]} */\n\t\tvar parts;\n\n\t\trender_effect(() => {\n\t\t\told_parts = parts;\n\t\t\t// We only track changes to the parts, not the value itself to avoid unnecessary reruns.\n\t\t\tparts = get_parts?.() || [];\n\n\t\t\tuntrack(() => {\n\t\t\t\tif (element_or_component !== get_value(...parts)) {\n\t\t\t\t\tupdate(element_or_component, ...parts);\n\t\t\t\t\t// If this is an effect rerun (cause: each block context changes), then nullfiy the binding at\n\t\t\t\t\t// the previous position if it isn't already taken over by a different effect.\n\t\t\t\t\tif (old_parts && is_bound_this(get_value(...old_parts), element_or_component)) {\n\t\t\t\t\t\tupdate(null, ...old_parts);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\n\t\treturn () => {\n\t\t\t// We cannot use effects in the teardown phase, we we use a microtask instead.\n\t\t\tqueue_micro_task(() => {\n\t\t\t\tif (parts && is_bound_this(get_value(...parts), element_or_component)) {\n\t\t\t\t\tupdate(null, ...parts);\n\t\t\t\t}\n\t\t\t});\n\t\t};\n\t});\n\n\treturn element_or_component;\n}\n","/** @import { ComponentContextLegacy } from '#client' */\nimport { run, run_all } from '../../../shared/utils.js';\nimport { derived } from '../../reactivity/deriveds.js';\nimport { user_pre_effect, user_effect } from '../../reactivity/effects.js';\nimport { component_context, deep_read_state, get, untrack } from '../../runtime.js';\n\n/**\n * Legacy-mode only: Call `onMount` callbacks and set up `beforeUpdate`/`afterUpdate` effects\n * @param {boolean} [immutable]\n */\nexport function init(immutable = false) {\n\tconst context = /** @type {ComponentContextLegacy} */ (component_context);\n\n\tconst callbacks = context.l.u;\n\tif (!callbacks) return;\n\n\tlet props = () => deep_read_state(context.s);\n\n\tif (immutable) {\n\t\tlet version = 0;\n\t\tlet prev = /** @type {Record<string, any>} */ ({});\n\n\t\t// In legacy immutable mode, before/afterUpdate only fire if the object identity of a prop changes\n\t\tconst d = derived(() => {\n\t\t\tlet changed = false;\n\t\t\tconst props = context.s;\n\t\t\tfor (const key in props) {\n\t\t\t\tif (props[key] !== prev[key]) {\n\t\t\t\t\tprev[key] = props[key];\n\t\t\t\t\tchanged = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (changed) version++;\n\t\t\treturn version;\n\t\t});\n\n\t\tprops = () => get(d);\n\t}\n\n\t// beforeUpdate\n\tif (callbacks.b.length) {\n\t\tuser_pre_effect(() => {\n\t\t\tobserve_all(context, props);\n\t\t\trun_all(callbacks.b);\n\t\t});\n\t}\n\n\t// onMount (must run before afterUpdate)\n\tuser_effect(() => {\n\t\tconst fns = untrack(() => callbacks.m.map(run));\n\t\treturn () => {\n\t\t\tfor (const fn of fns) {\n\t\t\t\tif (typeof fn === 'function') {\n\t\t\t\t\tfn();\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t});\n\n\t// afterUpdate\n\tif (callbacks.a.length) {\n\t\tuser_effect(() => {\n\t\t\tobserve_all(context, props);\n\t\t\trun_all(callbacks.a);\n\t\t});\n\t}\n}\n\n/**\n * Invoke the getter of all signals associated with a component\n * so they can be registered to the effect this function is called in.\n * @param {ComponentContextLegacy} context\n * @param {(() => void)} props\n */\nfunction observe_all(context, props) {\n\tif (context.l.s) {\n\t\tfor (const signal of context.l.s) get(signal);\n\t}\n\n\tprops();\n}\n","import { set, source } from '../../reactivity/sources.js';\nimport { get } from '../../runtime.js';\nimport { is_array } from '../../../shared/utils.js';\n\n/**\n * Under some circumstances, imports may be reactive in legacy mode. In that case,\n * they should be using `reactive_import` as part of the transformation\n * @param {() => any} fn\n */\nexport function reactive_import(fn) {\n\tvar s = source(0);\n\n\treturn function () {\n\t\tif (arguments.length === 1) {\n\t\t\tset(s, get(s) + 1);\n\t\t\treturn arguments[0];\n\t\t} else {\n\t\t\tget(s);\n\t\t\treturn fn();\n\t\t}\n\t};\n}\n\n/**\n * @this {any}\n * @param {Record<string, unknown>} $$props\n * @param {Event} event\n * @returns {void}\n */\nexport function bubble_event($$props, event) {\n\tvar events = /** @type {Record<string, Function[] | Function>} */ ($$props.$$events)?.[\n\t\tevent.type\n\t];\n\n\tvar callbacks = is_array(events) ? events.slice() : events == null ? [] : [events];\n\n\tfor (var fn of callbacks) {\n\t\t// Preserve \"this\" context\n\t\tfn.call(this, event);\n\t}\n}\n\n/**\n * Used to simulate `$on` on a component instance when `compatibility.componentApi === 4`\n * @param {Record<string, any>} $$props\n * @param {string} event_name\n * @param {Function} event_callback\n */\nexport function add_legacy_event_listener($$props, event_name, event_callback) {\n\t$$props.$$events ||= {};\n\t$$props.$$events[event_name] ||= [];\n\t$$props.$$events[event_name].push(event_callback);\n}\n\n/**\n * Used to simulate `$set` on a component instance when `compatibility.componentApi === 4`.\n * Needs component accessors so that it can call the setter of the prop. Therefore doesn't\n * work for updating props in `$$props` or `$$restProps`.\n * @this {Record<string, any>}\n * @param {Record<string, any>} $$new_props\n */\nexport function update_legacy_props($$new_props) {\n\tfor (var key in $$new_props) {\n\t\tif (key in this) {\n\t\t\tthis[key] = $$new_props[key];\n\t\t}\n\t}\n}\n","/** @import { Derived, Source } from './types.js' */\nimport { DEV } from 'esm-env';\nimport {\n\tPROPS_IS_BINDABLE,\n\tPROPS_IS_IMMUTABLE,\n\tPROPS_IS_LAZY_INITIAL,\n\tPROPS_IS_RUNES,\n\tPROPS_IS_UPDATED\n} from '../../../constants.js';\nimport { get_descriptor, is_function } from '../../shared/utils.js';\nimport { mutable_source, set, source } from './sources.js';\nimport { derived, derived_safe_equal } from './deriveds.js';\nimport {\n\tactive_effect,\n\tactive_reaction,\n\tget,\n\tis_signals_recorded,\n\tset_active_effect,\n\tuntrack,\n\tupdate\n} from '../runtime.js';\nimport { safe_equals } from './equality.js';\nimport * as e from '../errors.js';\nimport { BRANCH_EFFECT, DESTROYED, LEGACY_DERIVED_PROP, ROOT_EFFECT } from '../constants.js';\nimport { proxy } from '../proxy.js';\n\n/**\n * @param {((value?: number) => number)} fn\n * @param {1 | -1} [d]\n * @returns {number}\n */\nexport function update_prop(fn, d = 1) {\n\tconst value = fn();\n\tfn(value + d);\n\treturn value;\n}\n\n/**\n * @param {((value?: number) => number)} fn\n * @param {1 | -1} [d]\n * @returns {number}\n */\nexport function update_pre_prop(fn, d = 1) {\n\tconst value = fn() + d;\n\tfn(value);\n\treturn value;\n}\n\n/**\n * The proxy handler for rest props (i.e. `const { x, ...rest } = $props()`).\n * Is passed the full `$$props` object and excludes the named props.\n * @type {ProxyHandler<{ props: Record<string | symbol, unknown>, exclude: Array<string | symbol>, name?: string }>}}\n */\nconst rest_props_handler = {\n\tget(target, key) {\n\t\tif (target.exclude.includes(key)) return;\n\t\treturn target.props[key];\n\t},\n\tset(target, key) {\n\t\tif (DEV) {\n\t\t\t// TODO should this happen in prod too?\n\t\t\te.props_rest_readonly(`${target.name}.${String(key)}`);\n\t\t}\n\n\t\treturn false;\n\t},\n\tgetOwnPropertyDescriptor(target, key) {\n\t\tif (target.exclude.includes(key)) return;\n\t\tif (key in target.props) {\n\t\t\treturn {\n\t\t\t\tenumerable: true,\n\t\t\t\tconfigurable: true,\n\t\t\t\tvalue: target.props[key]\n\t\t\t};\n\t\t}\n\t},\n\thas(target, key) {\n\t\tif (target.exclude.includes(key)) return false;\n\t\treturn key in target.props;\n\t},\n\townKeys(target) {\n\t\treturn Reflect.ownKeys(target.props).filter((key) => !target.exclude.includes(key));\n\t}\n};\n\n/**\n * @param {Record<string, unknown>} props\n * @param {string[]} exclude\n * @param {string} [name]\n * @returns {Record<string, unknown>}\n */\n/*#__NO_SIDE_EFFECTS__*/\nexport function rest_props(props, exclude, name) {\n\treturn new Proxy(\n\t\tDEV ? { props, exclude, name, other: {}, to_proxy: [] } : { props, exclude },\n\t\trest_props_handler\n\t);\n}\n\n/**\n * The proxy handler for legacy $$restProps and $$props\n * @type {ProxyHandler<{ props: Record<string | symbol, unknown>, exclude: Array<string | symbol>, special: Record<string | symbol, (v?: unknown) => unknown>, version: Source<number> }>}}\n */\nconst legacy_rest_props_handler = {\n\tget(target, key) {\n\t\tif (target.exclude.includes(key)) return;\n\t\tget(target.version);\n\t\treturn key in target.special ? target.special[key]() : target.props[key];\n\t},\n\tset(target, key, value) {\n\t\tif (!(key in target.special)) {\n\t\t\t// Handle props that can temporarily get out of sync with the parent\n\t\t\t/** @type {Record<string, (v?: unknown) => unknown>} */\n\t\t\ttarget.special[key] = prop(\n\t\t\t\t{\n\t\t\t\t\tget [key]() {\n\t\t\t\t\t\treturn target.props[key];\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t/** @type {string} */ (key),\n\t\t\t\tPROPS_IS_UPDATED\n\t\t\t);\n\t\t}\n\n\t\ttarget.special[key](value);\n\t\tupdate(target.version); // $$props is coarse-grained: when $$props.x is updated, usages of $$props.y etc are also rerun\n\t\treturn true;\n\t},\n\tgetOwnPropertyDescriptor(target, key) {\n\t\tif (target.exclude.includes(key)) return;\n\t\tif (key in target.props) {\n\t\t\treturn {\n\t\t\t\tenumerable: true,\n\t\t\t\tconfigurable: true,\n\t\t\t\tvalue: target.props[key]\n\t\t\t};\n\t\t}\n\t},\n\tdeleteProperty(target, key) {\n\t\t// Svelte 4 allowed for deletions on $$restProps\n\t\tif (target.exclude.includes(key)) return true;\n\t\ttarget.exclude.push(key);\n\t\tupdate(target.version);\n\t\treturn true;\n\t},\n\thas(target, key) {\n\t\tif (target.exclude.includes(key)) return false;\n\t\treturn key in target.props;\n\t},\n\townKeys(target) {\n\t\treturn Reflect.ownKeys(target.props).filter((key) => !target.exclude.includes(key));\n\t}\n};\n\n/**\n * @param {Record<string, unknown>} props\n * @param {string[]} exclude\n * @returns {Record<string, unknown>}\n */\nexport function legacy_rest_props(props, exclude) {\n\treturn new Proxy({ props, exclude, special: {}, version: source(0) }, legacy_rest_props_handler);\n}\n\n/**\n * The proxy handler for spread props. Handles the incoming array of props\n * that looks like `() => { dynamic: props }, { static: prop }, ..` and wraps\n * them so that the whole thing is passed to the component as the `$$props` argument.\n * @template {Record<string | symbol, unknown>} T\n * @type {ProxyHandler<{ props: Array<T | (() => T)> }>}}\n */\nconst spread_props_handler = {\n\tget(target, key) {\n\t\tlet i = target.props.length;\n\t\twhile (i--) {\n\t\t\tlet p = target.props[i];\n\t\t\tif (is_function(p)) p = p();\n\t\t\tif (typeof p === 'object' && p !== null && key in p) return p[key];\n\t\t}\n\t},\n\tgetOwnPropertyDescriptor(target, key) {\n\t\tlet i = target.props.length;\n\t\twhile (i--) {\n\t\t\tlet p = target.props[i];\n\t\t\tif (is_function(p)) p = p();\n\t\t\tif (typeof p === 'object' && p !== null && key in p) {\n\t\t\t\tconst descriptor = get_descriptor(p, key);\n\t\t\t\tif (descriptor && !descriptor.configurable) {\n\t\t\t\t\t// Prevent a \"Non-configurability Report Error\": The target is an array, it does\n\t\t\t\t\t// not actually contain this property. If it is now described as non-configurable,\n\t\t\t\t\t// the proxy throws a validation error. Setting it to true avoids that.\n\t\t\t\t\tdescriptor.configurable = true;\n\t\t\t\t}\n\t\t\t\treturn descriptor;\n\t\t\t}\n\t\t}\n\t},\n\thas(target, key) {\n\t\tfor (let p of target.props) {\n\t\t\tif (is_function(p)) p = p();\n\t\t\tif (p != null && key in p) return true;\n\t\t}\n\n\t\treturn false;\n\t},\n\townKeys(target) {\n\t\t/** @type {Array<string | symbol>} */\n\t\tconst keys = [];\n\n\t\tfor (let p of target.props) {\n\t\t\tif (is_function(p)) p = p();\n\t\t\tfor (const key in p) {\n\t\t\t\tif (!keys.includes(key)) keys.push(key);\n\t\t\t}\n\t\t}\n\n\t\treturn keys;\n\t}\n};\n\n/**\n * @param {Array<Record<string, unknown> | (() => Record<string, unknown>)>} props\n * @returns {any}\n */\nexport function spread_props(...props) {\n\treturn new Proxy({ props }, spread_props_handler);\n}\n\n/**\n * @template T\n * @param {() => T} fn\n * @returns {T}\n */\nfunction with_parent_branch(fn) {\n\tvar effect = active_effect;\n\tvar previous_effect = active_effect;\n\n\twhile (effect !== null && (effect.f & (BRANCH_EFFECT | ROOT_EFFECT)) === 0) {\n\t\teffect = effect.parent;\n\t}\n\ttry {\n\t\tset_active_effect(effect);\n\t\treturn fn();\n\t} finally {\n\t\tset_active_effect(previous_effect);\n\t}\n}\n\n/**\n * This function is responsible for synchronizing a possibly bound prop with the inner component state.\n * It is used whenever the compiler sees that the component writes to the prop, or when it has a default prop_value.\n * @template V\n * @param {Record<string, unknown>} props\n * @param {string} key\n * @param {number} flags\n * @param {V | (() => V)} [fallback]\n * @returns {(() => V | ((arg: V) => V) | ((arg: V, mutation: boolean) => V))}\n */\nexport function prop(props, key, flags, fallback) {\n\tvar immutable = (flags & PROPS_IS_IMMUTABLE) !== 0;\n\tvar runes = (flags & PROPS_IS_RUNES) !== 0;\n\tvar bindable = (flags & PROPS_IS_BINDABLE) !== 0;\n\tvar lazy = (flags & PROPS_IS_LAZY_INITIAL) !== 0;\n\n\tvar prop_value = /** @type {V} */ (props[key]);\n\tvar setter = get_descriptor(props, key)?.set;\n\n\tvar fallback_value = /** @type {V} */ (fallback);\n\tvar fallback_dirty = true;\n\tvar fallback_used = false;\n\n\tvar get_fallback = () => {\n\t\tfallback_used = true;\n\t\tif (fallback_dirty) {\n\t\t\tfallback_dirty = false;\n\t\t\tif (lazy) {\n\t\t\t\tfallback_value = untrack(/** @type {() => V} */ (fallback));\n\t\t\t} else {\n\t\t\t\tfallback_value = /** @type {V} */ (fallback);\n\t\t\t}\n\t\t}\n\n\t\treturn fallback_value;\n\t};\n\n\tif (prop_value === undefined && fallback !== undefined) {\n\t\tif (setter && runes) {\n\t\t\te.props_invalid_value(key);\n\t\t}\n\n\t\tprop_value = get_fallback();\n\t\tif (setter) setter(prop_value);\n\t}\n\n\t/** @type {() => V} */\n\tvar getter;\n\tif (runes) {\n\t\tgetter = () => {\n\t\t\tvar value = /** @type {V} */ (props[key]);\n\t\t\tif (value === undefined) return get_fallback();\n\t\t\tfallback_dirty = true;\n\t\t\tfallback_used = false;\n\t\t\treturn value;\n\t\t};\n\t} else {\n\t\t// Svelte 4 did not trigger updates when a primitive value was updated to the same value.\n\t\t// Replicate that behavior through using a derived\n\t\tvar derived_getter = with_parent_branch(() =>\n\t\t\t(immutable ? derived : derived_safe_equal)(() => /** @type {V} */ (props[key]))\n\t\t);\n\t\tderived_getter.f |= LEGACY_DERIVED_PROP;\n\t\tgetter = () => {\n\t\t\tvar value = get(derived_getter);\n\t\t\tif (value !== undefined) fallback_value = /** @type {V} */ (undefined);\n\t\t\treturn value === undefined ? fallback_value : value;\n\t\t};\n\t}\n\n\t// easy mode  prop is never written to\n\tif ((flags & PROPS_IS_UPDATED) === 0) {\n\t\treturn getter;\n\t}\n\n\t// intermediate mode  prop is written to, but the parent component had\n\t// `bind:foo` which means we can just call `$$props.foo = value` directly\n\tif (setter) {\n\t\tvar legacy_parent = props.$$legacy;\n\t\treturn function (/** @type {any} */ value, /** @type {boolean} */ mutation) {\n\t\t\tif (arguments.length > 0) {\n\t\t\t\t// We don't want to notify if the value was mutated and the parent is in runes mode.\n\t\t\t\t// In that case the state proxy (if it exists) should take care of the notification.\n\t\t\t\t// If the parent is not in runes mode, we need to notify on mutation, too, that the prop\n\t\t\t\t// has changed because the parent will not be able to detect the change otherwise.\n\t\t\t\tif (!runes || !mutation || legacy_parent) {\n\t\t\t\t\t/** @type {Function} */ (setter)(mutation ? getter() : value);\n\t\t\t\t}\n\t\t\t\treturn value;\n\t\t\t} else {\n\t\t\t\treturn getter();\n\t\t\t}\n\t\t};\n\t}\n\n\t// hard mode. this is where it gets ugly  the value in the child should\n\t// synchronize with the parent, but it should also be possible to temporarily\n\t// set the value to something else locally.\n\tvar from_child = false;\n\tvar was_from_child = false;\n\n\t// The derived returns the current value. The underlying mutable\n\t// source is written to from various places to persist this value.\n\tvar inner_current_value = mutable_source(prop_value);\n\n\tvar current_value = with_parent_branch(() =>\n\t\tderived(() => {\n\t\t\tvar parent_value = getter();\n\t\t\tvar child_value = get(inner_current_value);\n\t\t\tvar current_derived = /** @type {Derived} */ (active_reaction);\n\n\t\t\t// If the getter from the parent returns undefined, switch\n\t\t\t// to using the local value from inner_current_value instead,\n\t\t\t// as the parent value might have been torn down\n\t\t\tif (from_child || (parent_value === undefined && (current_derived.f & DESTROYED) !== 0)) {\n\t\t\t\tfrom_child = false;\n\t\t\t\twas_from_child = true;\n\t\t\t\treturn child_value;\n\t\t\t}\n\n\t\t\twas_from_child = false;\n\t\t\treturn (inner_current_value.v = parent_value);\n\t\t})\n\t);\n\n\tif (!immutable) current_value.equals = safe_equals;\n\n\treturn function (/** @type {any} */ value, /** @type {boolean} */ mutation) {\n\t\tvar current = get(current_value);\n\n\t\t// legacy nonsense  need to ensure the source is invalidated when necessary\n\t\t// also needed for when handling inspect logic so we can inspect the correct source signal\n\t\tif (is_signals_recorded) {\n\t\t\t// set this so that we don't reset to the parent value if `d`\n\t\t\t// is invalidated because of `invalidate_inner_signals` (rather\n\t\t\t// than because the parent or child value changed)\n\t\t\tfrom_child = was_from_child;\n\t\t\t// invoke getters so that signals are picked up by `invalidate_inner_signals`\n\t\t\tgetter();\n\t\t\tget(inner_current_value);\n\t\t}\n\n\t\tif (arguments.length > 0) {\n\t\t\tconst new_value = mutation ? get(current_value) : runes && bindable ? proxy(value) : value;\n\n\t\t\tif (!current_value.equals(new_value)) {\n\t\t\t\tfrom_child = true;\n\t\t\t\tset(inner_current_value, new_value);\n\t\t\t\t// To ensure the fallback value is consistent when used with proxies, we\n\t\t\t\t// update the local fallback_value, but only if the fallback is actively used\n\t\t\t\tif (fallback_used && fallback_value !== undefined) {\n\t\t\t\t\tfallback_value = new_value;\n\t\t\t\t}\n\t\t\t\tget(current_value); // force a synchronisation immediately\n\t\t\t}\n\n\t\t\treturn value;\n\t\t}\n\n\t\treturn current;\n\t};\n}\n","/** @import { Readable } from './public' */\nimport { noop } from '../internal/shared/utils.js';\n\n/**\n * @template T\n * @param {Readable<T> | null | undefined} store\n * @param {(value: T) => void} run\n * @param {(value: T) => void} [invalidate]\n * @returns {() => void}\n */\nexport function subscribe_to_store(store, run, invalidate) {\n\tif (store == null) {\n\t\t// @ts-expect-error\n\t\trun(undefined);\n\n\t\t// @ts-expect-error\n\t\tif (invalidate) invalidate(undefined);\n\n\t\treturn noop;\n\t}\n\n\t// Svelte store takes a private second argument\n\tconst unsub = store.subscribe(\n\t\trun,\n\t\t// @ts-expect-error\n\t\tinvalidate\n\t);\n\n\t// Also support RxJS\n\t// @ts-expect-error TODO fix this in the types?\n\treturn unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;\n}\n","/** @import { StoreReferencesContainer } from '#client' */\n/** @import { Store } from '#shared' */\nimport { subscribe_to_store } from '../../../store/utils.js';\nimport { noop } from '../../shared/utils.js';\nimport { get } from '../runtime.js';\nimport { teardown } from './effects.js';\nimport { mutable_source, set } from './sources.js';\n\n/**\n * Gets the current value of a store. If the store isn't subscribed to yet, it will create a proxy\n * signal that will be updated when the store is. The store references container is needed to\n * track reassignments to stores and to track the correct component context.\n * @template V\n * @param {Store<V> | null | undefined} store\n * @param {string} store_name\n * @param {StoreReferencesContainer} stores\n * @returns {V}\n */\nexport function store_get(store, store_name, stores) {\n\tconst entry = (stores[store_name] ??= {\n\t\tstore: null,\n\t\tsource: mutable_source(undefined),\n\t\tunsubscribe: noop\n\t});\n\n\tif (entry.store !== store) {\n\t\tentry.unsubscribe();\n\t\tentry.store = store ?? null;\n\n\t\tif (store == null) {\n\t\t\tentry.source.v = undefined; // see synchronous callback comment below\n\t\t\tentry.unsubscribe = noop;\n\t\t} else {\n\t\t\tvar is_synchronous_callback = true;\n\n\t\t\tentry.unsubscribe = subscribe_to_store(store, (v) => {\n\t\t\t\tif (is_synchronous_callback) {\n\t\t\t\t\t// If the first updates to the store value (possibly multiple of them) are synchronously\n\t\t\t\t\t// inside a derived, we will hit the `state_unsafe_mutation` error if we `set` the value\n\t\t\t\t\tentry.source.v = v;\n\t\t\t\t} else {\n\t\t\t\t\tset(entry.source, v);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tis_synchronous_callback = false;\n\t\t}\n\t}\n\n\treturn get(entry.source);\n}\n\n/**\n * Unsubscribe from a store if it's not the same as the one in the store references container.\n * We need this in addition to `store_get` because someone could unsubscribe from a store but\n * then never subscribe to the new one (if any), causing the subscription to stay open wrongfully.\n * @param {Store<any> | null | undefined} store\n * @param {string} store_name\n * @param {StoreReferencesContainer} stores\n */\nexport function store_unsub(store, store_name, stores) {\n\t/** @type {StoreReferencesContainer[''] | undefined} */\n\tlet entry = stores[store_name];\n\n\tif (entry && entry.store !== store) {\n\t\t// Don't reset store yet, so that store_get above can resubscribe to new store if necessary\n\t\tentry.unsubscribe();\n\t\tentry.unsubscribe = noop;\n\t}\n\n\treturn store;\n}\n\n/**\n * Sets the new value of a store and returns that value.\n * @template V\n * @param {Store<V>} store\n * @param {V} value\n * @returns {V}\n */\nexport function store_set(store, value) {\n\tstore.set(value);\n\treturn value;\n}\n\n/**\n * @param {StoreReferencesContainer} stores\n * @param {string} store_name\n */\nexport function invalidate_store(stores, store_name) {\n\tvar entry = stores[store_name];\n\tif (entry.store !== null) {\n\t\tstore_set(entry.store, entry.source.v);\n\t}\n}\n\n/**\n * Unsubscribes from all auto-subscribed stores on destroy\n * @returns {StoreReferencesContainer}\n */\nexport function setup_stores() {\n\t/** @type {StoreReferencesContainer} */\n\tconst stores = {};\n\n\tteardown(() => {\n\t\tfor (var store_name in stores) {\n\t\t\tconst ref = stores[store_name];\n\t\t\tref.unsubscribe();\n\t\t}\n\t});\n\n\treturn stores;\n}\n\n/**\n * Updates a store with a new value.\n * @param {Store<V>} store  the store to update\n * @param {any} expression  the expression that mutates the store\n * @param {V} new_value  the new store value\n * @template V\n */\nexport function store_mutate(store, expression, new_value) {\n\tstore.set(new_value);\n\treturn expression;\n}\n\n/**\n * @param {Store<number>} store\n * @param {number} store_value\n * @param {1 | -1} [d]\n * @returns {number}\n */\nexport function update_store(store, store_value, d = 1) {\n\tstore.set(store_value + d);\n\treturn store_value;\n}\n\n/**\n * @param {Store<number>} store\n * @param {number} store_value\n * @param {1 | -1} [d]\n * @returns {number}\n */\nexport function update_pre_store(store, store_value, d = 1) {\n\tconst value = store_value + d;\n\tstore.set(value);\n\treturn value;\n}\n","import { dequal as deepEqual } from 'dequal';\n/**\n * Returns the element some number before the given index. If the target index is out of bounds:\n *   - If looping is disabled, the first element will be returned.\n *   - If looping is enabled, the last element will be returned.\n * @param array the array.\n * @param currentIndex the index of the current element.\n * @param increment the number of elements to move forward.\n * @param loop loop to the beginning of the array if the target index is out of bounds?\n */\nexport function back(array, index, increment, loop = true) {\n    const previousIndex = index - increment;\n    if (previousIndex <= 0) {\n        return loop ? array[array.length - 1] : array[0];\n    }\n    return array[previousIndex];\n}\n/**\n * Returns the element some number after the given index. If the target index is out of bounds:\n *   - If looping is disabled, the last element will be returned.\n *   - If looping is enabled, the first element will be returned.\n * @param array the array.\n * @param currentIndex the index of the current element.\n * @param increment the number of elements to move forward.\n * @param loop loop to the beginning of the array if the target index is out of bounds?\n */\nexport function forward(array, index, increment, loop = true) {\n    const nextIndex = index + increment;\n    if (nextIndex > array.length - 1) {\n        return loop ? array[0] : array[array.length - 1];\n    }\n    return array[nextIndex];\n}\n/**\n * Returns the array element after to the given index.\n * @param array the array.\n * @param currentIndex the index of the current element.\n * @param loop loop to the beginning of the array if the next index is out of bounds?\n */\nexport function next(array, index, loop = true) {\n    if (index === array.length - 1) {\n        return loop ? array[0] : array[index];\n    }\n    return array[index + 1];\n}\n/**\n * Returns the array element prior to the given index.\n * @param array the array.\n * @param currentIndex the index of the current element.\n * @param loop loop to the end of the array if the previous index is out of bounds?\n */\nexport function prev(array, currentIndex, loop = true) {\n    if (currentIndex <= 0) {\n        return loop ? array[array.length - 1] : array[0];\n    }\n    return array[currentIndex - 1];\n}\n/**\n * Returns the last element in an array.\n * @param array the array.\n */\nexport function last(array) {\n    return array[array.length - 1];\n}\n/**\n * Wraps an array around itself at a given starting index.\n * @example ```ts\n * wrapArray(['a', 'b', 'c', 'd'], 2);\n * // ['c', 'd', 'a', 'b']\n * ```\n * @see https://github.com/radix-ui/primitives\n */\nexport function wrapArray(array, startIndex) {\n    return array.map((_, index) => array[(startIndex + index) % array.length]);\n}\n/**\n * Toggles an item in an array. If the item is already in the array,\n * it is removed. Otherwise, it is added.\n * @param item The item to toggle.\n * @param array The array to toggle the item in.\n * @returns The updated array with the item toggled.\n * @template T The type of the items in the array.\n * @example ```typescript\n * const arr = [1, 2, 3];\n * const newArr = toggle(2, arr);\n * // newArr = [1, 3]\n * ```\n */\nexport function toggle(item, array, compare = deepEqual) {\n    const itemIdx = array.findIndex((innerItem) => compare(innerItem, item));\n    if (itemIdx !== -1) {\n        array.splice(itemIdx, 1);\n    }\n    else {\n        array.push(item);\n    }\n    return array;\n}\n/**\n * Splits an array into chunks of a given size.\n * @param arr The array to split.\n * @param size The size of each chunk.\n * @returns An array of arrays, where each sub-array has `size` elements from the original array.\n * @example ```ts\n * const arr = [1, 2, 3, 4, 5, 6, 7, 8];\n * const chunks = chunk(arr, 3);\n * // chunks = [[1, 2, 3], [4, 5, 6], [7, 8]]\n * ```\n */\nexport function chunk(arr, size) {\n    const result = [];\n    for (let i = 0; i < arr.length; i += size) {\n        result.push(arr.slice(i, i + size));\n    }\n    return result;\n}\n/**\n * Checks if the given index is valid for the given array.\n *\n * @param index - The index to check\n * @param arr - The array to check\n */\nexport function isValidIndex(index, arr) {\n    return index >= 0 && index < arr.length;\n}\n","/**\n * A utility function that converts a style object to a string.\n *\n * @param style - The style object to convert\n * @returns The style object as a string\n */\nexport function styleToString(style) {\n    return Object.keys(style).reduce((str, key) => {\n        if (style[key] === undefined)\n            return str;\n        return str + `${key}:${style[key]};`;\n    }, '');\n}\n","import { styleToString } from './style.js';\nexport function disabledAttr(disabled) {\n    return disabled ? true : undefined;\n}\nexport const hiddenInputAttrs = {\n    type: 'hidden',\n    'aria-hidden': true,\n    hidden: true,\n    tabIndex: -1,\n    style: styleToString({\n        position: 'absolute',\n        opacity: 0,\n        'pointer-events': 'none',\n        margin: 0,\n        transform: 'translateX(-100%)',\n    }),\n};\n/**\n * @param portal The value of the `portal` option store.\n * @returns the value of the `data-portal` attribute.\n */\nexport function portalAttr(portal) {\n    if (portal !== null) {\n        return '';\n    }\n    return undefined;\n}\n","/** @import { Readable, StartStopNotifier, Subscriber, Unsubscriber, Updater, Writable } from '../public.js' */\n/** @import { Stores, StoresValues, SubscribeInvalidateTuple } from '../private.js' */\nimport { noop, run_all } from '../../internal/shared/utils.js';\nimport { safe_not_equal } from '../../internal/client/reactivity/equality.js';\nimport { subscribe_to_store } from '../utils.js';\n\n/**\n * @type {Array<SubscribeInvalidateTuple<any> | any>}\n */\nconst subscriber_queue = [];\n\n/**\n * Creates a `Readable` store that allows reading by subscription.\n *\n * @template T\n * @param {T} [value] initial value\n * @param {StartStopNotifier<T>} [start]\n * @returns {Readable<T>}\n */\nexport function readable(value, start) {\n\treturn {\n\t\tsubscribe: writable(value, start).subscribe\n\t};\n}\n\n/**\n * Create a `Writable` store that allows both updating and reading by subscription.\n *\n * @template T\n * @param {T} [value] initial value\n * @param {StartStopNotifier<T>} [start]\n * @returns {Writable<T>}\n */\nexport function writable(value, start = noop) {\n\t/** @type {Unsubscriber | null} */\n\tlet stop = null;\n\n\t/** @type {Set<SubscribeInvalidateTuple<T>>} */\n\tconst subscribers = new Set();\n\n\t/**\n\t * @param {T} new_value\n\t * @returns {void}\n\t */\n\tfunction set(new_value) {\n\t\tif (safe_not_equal(value, new_value)) {\n\t\t\tvalue = new_value;\n\t\t\tif (stop) {\n\t\t\t\t// store is ready\n\t\t\t\tconst run_queue = !subscriber_queue.length;\n\t\t\t\tfor (const subscriber of subscribers) {\n\t\t\t\t\tsubscriber[1]();\n\t\t\t\t\tsubscriber_queue.push(subscriber, value);\n\t\t\t\t}\n\t\t\t\tif (run_queue) {\n\t\t\t\t\tfor (let i = 0; i < subscriber_queue.length; i += 2) {\n\t\t\t\t\t\tsubscriber_queue[i][0](subscriber_queue[i + 1]);\n\t\t\t\t\t}\n\t\t\t\t\tsubscriber_queue.length = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * @param {Updater<T>} fn\n\t * @returns {void}\n\t */\n\tfunction update(fn) {\n\t\tset(fn(/** @type {T} */ (value)));\n\t}\n\n\t/**\n\t * @param {Subscriber<T>} run\n\t * @param {() => void} [invalidate]\n\t * @returns {Unsubscriber}\n\t */\n\tfunction subscribe(run, invalidate = noop) {\n\t\t/** @type {SubscribeInvalidateTuple<T>} */\n\t\tconst subscriber = [run, invalidate];\n\t\tsubscribers.add(subscriber);\n\t\tif (subscribers.size === 1) {\n\t\t\tstop = start(set, update) || noop;\n\t\t}\n\t\trun(/** @type {T} */ (value));\n\t\treturn () => {\n\t\t\tsubscribers.delete(subscriber);\n\t\t\tif (subscribers.size === 0 && stop) {\n\t\t\t\tstop();\n\t\t\t\tstop = null;\n\t\t\t}\n\t\t};\n\t}\n\treturn { set, update, subscribe };\n}\n\n/**\n * Derived value store by synchronizing one or more readable stores and\n * applying an aggregation function over its input values.\n *\n * @template {Stores} S\n * @template T\n * @overload\n * @param {S} stores\n * @param {(values: StoresValues<S>, set: (value: T) => void, update: (fn: Updater<T>) => void) => Unsubscriber | void} fn\n * @param {T} [initial_value]\n * @returns {Readable<T>}\n */\n/**\n * Derived value store by synchronizing one or more readable stores and\n * applying an aggregation function over its input values.\n *\n * @template {Stores} S\n * @template T\n * @overload\n * @param {S} stores\n * @param {(values: StoresValues<S>) => T} fn\n * @param {T} [initial_value]\n * @returns {Readable<T>}\n */\n/**\n * @template {Stores} S\n * @template T\n * @param {S} stores\n * @param {Function} fn\n * @param {T} [initial_value]\n * @returns {Readable<T>}\n */\nexport function derived(stores, fn, initial_value) {\n\tconst single = !Array.isArray(stores);\n\t/** @type {Array<Readable<any>>} */\n\tconst stores_array = single ? [stores] : stores;\n\tif (!stores_array.every(Boolean)) {\n\t\tthrow new Error('derived() expects stores as input, got a falsy value');\n\t}\n\tconst auto = fn.length < 2;\n\treturn readable(initial_value, (set, update) => {\n\t\tlet started = false;\n\t\t/** @type {T[]} */\n\t\tconst values = [];\n\t\tlet pending = 0;\n\t\tlet cleanup = noop;\n\t\tconst sync = () => {\n\t\t\tif (pending) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tcleanup();\n\t\t\tconst result = fn(single ? values[0] : values, set, update);\n\t\t\tif (auto) {\n\t\t\t\tset(result);\n\t\t\t} else {\n\t\t\t\tcleanup = typeof result === 'function' ? result : noop;\n\t\t\t}\n\t\t};\n\t\tconst unsubscribers = stores_array.map((store, i) =>\n\t\t\tsubscribe_to_store(\n\t\t\t\tstore,\n\t\t\t\t(value) => {\n\t\t\t\t\tvalues[i] = value;\n\t\t\t\t\tpending &= ~(1 << i);\n\t\t\t\t\tif (started) {\n\t\t\t\t\t\tsync();\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t() => {\n\t\t\t\t\tpending |= 1 << i;\n\t\t\t\t}\n\t\t\t)\n\t\t);\n\t\tstarted = true;\n\t\tsync();\n\t\treturn function stop() {\n\t\t\trun_all(unsubscribers);\n\t\t\tcleanup();\n\t\t\t// We need to set this to false because callbacks can still happen despite having unsubscribed:\n\t\t\t// Callbacks might already be placed in the queue which doesn't know it should no longer\n\t\t\t// invoke this derived store.\n\t\t\tstarted = false;\n\t\t};\n\t});\n}\n\n/**\n * Takes a store and returns a new one derived from the old one that is readable.\n *\n * @template T\n * @param {Readable<T>} store  - store to make readonly\n * @returns {Readable<T>}\n */\nexport function readonly(store) {\n\treturn {\n\t\t// @ts-expect-error TODO i suspect the bind is unnecessary\n\t\tsubscribe: store.subscribe.bind(store)\n\t};\n}\n\n/**\n * Get the current value from a store by subscribing and immediately unsubscribing.\n *\n * @template T\n * @param {Readable<T>} store\n * @returns {T}\n */\nexport function get(store) {\n\tlet value;\n\tsubscribe_to_store(store, (_) => (value = _))();\n\t// @ts-expect-error\n\treturn value;\n}\n","export function lightable(value) {\n    function subscribe(run) {\n        run(value);\n        return () => {\n            // don't need to unsub from anything\n        };\n    }\n    return { subscribe };\n}\n","import { derived } from 'svelte/store';\nimport { isBrowser, isHTMLElement, noop } from './index.js';\nimport { lightable } from './store/lightable.js';\nexport function getElementByMeltId(id) {\n    if (!isBrowser)\n        return null;\n    const el = document.querySelector(`[data-melt-id=\"${id}\"]`);\n    return isHTMLElement(el) ? el : null;\n}\nexport const hiddenAction = (obj) => {\n    return new Proxy(obj, {\n        get(target, prop, receiver) {\n            return Reflect.get(target, prop, receiver);\n        },\n        ownKeys(target) {\n            return Reflect.ownKeys(target).filter((key) => key !== 'action');\n        },\n    });\n};\nconst isFunctionWithParams = (fn) => {\n    return typeof fn === 'function';\n};\nexport const emptyMeltElement = makeElement('empty');\nexport function makeElement(name, args) {\n    const { stores, action, returned } = args ?? {};\n    const derivedStore = (() => {\n        if (stores && returned) {\n            // If stores are provided, create a derived store from them\n            return derived(stores, (values) => {\n                const result = returned(values);\n                if (isFunctionWithParams(result)) {\n                    const fn = (...args) => {\n                        return hiddenAction({\n                            ...result(...args),\n                            [`data-melt-${name}`]: '',\n                            action: action ?? noop,\n                        });\n                    };\n                    fn.action = action ?? noop;\n                    return fn;\n                }\n                return hiddenAction({\n                    ...result,\n                    [`data-melt-${name}`]: '',\n                    action: action ?? noop,\n                });\n            });\n        }\n        else {\n            // If stores are not provided, return a lightable store, for consistency\n            const returnedFn = returned;\n            const result = returnedFn?.();\n            if (isFunctionWithParams(result)) {\n                const resultFn = (...args) => {\n                    return hiddenAction({\n                        ...result(...args),\n                        [`data-melt-${name}`]: '',\n                        action: action ?? noop,\n                    });\n                };\n                resultFn.action = action ?? noop;\n                return lightable(resultFn);\n            }\n            return lightable(hiddenAction({\n                ...result,\n                [`data-melt-${name}`]: '',\n                action: action ?? noop,\n            }));\n        }\n    })();\n    const actionFn = (action ??\n        (() => {\n            /** noop */\n        }));\n    actionFn.subscribe = derivedStore.subscribe;\n    return actionFn;\n}\nexport function makeElementArray(name, args) {\n    const { stores, returned, action } = args;\n    const { subscribe } = derived(stores, (values) => returned(values).map((value) => hiddenAction({\n        ...value,\n        [`data-melt-${name}`]: '',\n        action: action ?? noop,\n    })));\n    const actionFn = (action ??\n        (() => {\n            /** noop */\n        }));\n    actionFn.subscribe = subscribe;\n    return actionFn;\n}\nexport function createElHelpers(prefix) {\n    const name = (part) => (part ? `${prefix}-${part}` : prefix);\n    const attribute = (part) => `data-melt-${prefix}${part ? `-${part}` : ''}`;\n    const selector = (part) => `[data-melt-${prefix}${part ? `-${part}` : ''}]`;\n    const getEl = (part) => document.querySelector(selector(part));\n    return {\n        name,\n        attribute,\n        selector,\n        getEl,\n    };\n}\n","export const isBrowser = typeof document !== 'undefined';\n// eslint-disable-next-line @typescript-eslint/ban-types\nexport const isFunction = (v) => typeof v === 'function';\nexport const isLetter = (key) => /^[a-z]$/i.test(key);\nexport function isDocument(element) {\n    return element instanceof Document;\n}\nexport function isElement(element) {\n    return element instanceof Element;\n}\nexport function isHTMLElement(element) {\n    return element instanceof HTMLElement;\n}\nexport function isHTMLInputElement(element) {\n    return element instanceof HTMLInputElement;\n}\nexport function isHTMLLabelElement(element) {\n    return element instanceof HTMLLabelElement;\n}\nexport function isHTMLButtonElement(element) {\n    return element instanceof HTMLButtonElement;\n}\nexport function isElementDisabled(element) {\n    const ariaDisabled = element.getAttribute('aria-disabled');\n    const disabled = element.getAttribute('disabled');\n    const dataDisabled = element.hasAttribute('data-disabled');\n    if (ariaDisabled === 'true' || disabled !== null || dataDisabled) {\n        return true;\n    }\n    return false;\n}\nexport function isTouch(event) {\n    return event.pointerType === 'touch';\n}\nexport function isLeftClick(event) {\n    return event.button === 0 && event.ctrlKey === false && event.metaKey === false;\n}\nexport function isFocusVisible(element) {\n    return element.matches(':focus-visible');\n}\nexport function isContentEditable(element) {\n    if (!isHTMLElement(element))\n        return false;\n    return element.isContentEditable;\n}\nexport function isNull(value) {\n    return value === null;\n}\nexport function isNumberString(value) {\n    if (isNaN(parseInt(value)))\n        return false;\n    return true;\n}\nexport function isObject(value) {\n    return value !== null && typeof value === 'object';\n}\nexport function isReadable(value) {\n    return isObject(value) && 'subscribe' in value;\n}\nexport function isWritable(value) {\n    return isReadable(value) && 'set' in value;\n}\n","/**\n * Executes an array of callback functions with the same arguments.\n * @template T The types of the arguments that the callback functions take.\n * @param n array of callback functions to execute.\n * @returns A new function that executes all of the original callback functions with the same arguments.\n */\nexport function executeCallbacks(...callbacks) {\n    return (...args) => {\n        for (const callback of callbacks) {\n            if (typeof callback === 'function') {\n                callback(...args);\n            }\n        }\n    };\n}\n/**\n * A no operation function (does nothing)\n */\nexport function noop() {\n    //\n}\n","import { noop } from './callbacks.js';\nimport { isHTMLElement } from './is.js';\n/**\n * Adds an event listener to the specified target element(s) for the given event(s), and returns a function to remove it.\n * @param target The target element(s) to add the event listener to.\n * @param event The event(s) to listen for.\n * @param handler The function to be called when the event is triggered.\n * @param options An optional object that specifies characteristics about the event listener.\n * @returns A function that removes the event listener from the target element(s).\n */\nexport function addEventListener(target, event, handler, options) {\n    const events = Array.isArray(event) ? event : [event];\n    // Add the event listener to each specified event for the target element(s).\n    events.forEach((_event) => target.addEventListener(_event, handler, options));\n    // Return a function that removes the event listener from the target element(s).\n    return () => {\n        events.forEach((_event) => target.removeEventListener(_event, handler, options));\n    };\n}\nexport function addMeltEventListener(target, event, handler, options) {\n    const events = Array.isArray(event) ? event : [event];\n    if (typeof handler === 'function') {\n        const handlerWithMelt = withMelt((_event) => handler(_event));\n        // Add the event listener to each specified event for the target element(s).\n        events.forEach((_event) => target.addEventListener(_event, handlerWithMelt, options));\n        // Return a function that removes the event listener from the target element(s).\n        return () => {\n            events.forEach((_event) => target.removeEventListener(_event, handlerWithMelt, options));\n        };\n    }\n    return () => noop();\n}\nexport function dispatchMeltEvent(originalEvent) {\n    const node = originalEvent.currentTarget;\n    if (!isHTMLElement(node))\n        return null;\n    const customMeltEvent = new CustomEvent(`m-${originalEvent.type}`, {\n        detail: {\n            originalEvent,\n        },\n        cancelable: true,\n    });\n    node.dispatchEvent(customMeltEvent);\n    return customMeltEvent;\n}\nexport function withMelt(handler) {\n    return (event) => {\n        const customEvent = dispatchMeltEvent(event);\n        if (customEvent?.defaultPrevented)\n            return;\n        return handler(event);\n    };\n}\n","export function addHighlight(element) {\n    element.setAttribute('data-highlighted', '');\n}\nexport function removeHighlight(element) {\n    element.removeAttribute('data-highlighted');\n}\n","/** @import { ComponentContext, ComponentContextLegacy } from '#client' */\n/** @import { EventDispatcher } from './index.js' */\n/** @import { NotFunction } from './internal/types.js' */\nimport { component_context, flush_sync, untrack } from './internal/client/runtime.js';\nimport { is_array } from './internal/shared/utils.js';\nimport { user_effect } from './internal/client/index.js';\nimport * as e from './internal/client/errors.js';\nimport { lifecycle_outside_component } from './internal/shared/errors.js';\n\n/**\n * The `onMount` function schedules a callback to run as soon as the component has been mounted to the DOM.\n * It must be called during the component's initialisation (but doesn't need to live *inside* the component;\n * it can be called from an external module).\n *\n * If a function is returned _synchronously_ from `onMount`, it will be called when the component is unmounted.\n *\n * `onMount` does not run inside a [server-side component](https://svelte.dev/docs#run-time-server-side-component-api).\n *\n * @template T\n * @param {() => NotFunction<T> | Promise<NotFunction<T>> | (() => any)} fn\n * @returns {void}\n */\nexport function onMount(fn) {\n\tif (component_context === null) {\n\t\tlifecycle_outside_component('onMount');\n\t}\n\n\tif (component_context.l !== null) {\n\t\tinit_update_callbacks(component_context).m.push(fn);\n\t} else {\n\t\tuser_effect(() => {\n\t\t\tconst cleanup = untrack(fn);\n\t\t\tif (typeof cleanup === 'function') return /** @type {() => void} */ (cleanup);\n\t\t});\n\t}\n}\n\n/**\n * Schedules a callback to run immediately before the component is unmounted.\n *\n * Out of `onMount`, `beforeUpdate`, `afterUpdate` and `onDestroy`, this is the\n * only one that runs inside a server-side component.\n *\n * @param {() => any} fn\n * @returns {void}\n */\nexport function onDestroy(fn) {\n\tif (component_context === null) {\n\t\tlifecycle_outside_component('onDestroy');\n\t}\n\n\tonMount(() => () => untrack(fn));\n}\n\n/**\n * @template [T=any]\n * @param {string} type\n * @param {T} [detail]\n * @param {any}params_0\n * @returns {CustomEvent<T>}\n */\nfunction create_custom_event(type, detail, { bubbles = false, cancelable = false } = {}) {\n\treturn new CustomEvent(type, { detail, bubbles, cancelable });\n}\n\n/**\n * Creates an event dispatcher that can be used to dispatch [component events](https://svelte.dev/docs#template-syntax-component-directives-on-eventname).\n * Event dispatchers are functions that can take two arguments: `name` and `detail`.\n *\n * Component events created with `createEventDispatcher` create a\n * [CustomEvent](https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent).\n * These events do not [bubble](https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Building_blocks/Events#Event_bubbling_and_capture).\n * The `detail` argument corresponds to the [CustomEvent.detail](https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent/detail)\n * property and can contain any type of data.\n *\n * The event dispatcher can be typed to narrow the allowed event names and the type of the `detail` argument:\n * ```ts\n * const dispatch = createEventDispatcher<{\n *  loaded: never; // does not take a detail argument\n *  change: string; // takes a detail argument of type string, which is required\n *  optional: number | null; // takes an optional detail argument of type number\n * }>();\n * ```\n *\n * @deprecated Use callback props and/or the `$host()` rune instead  see https://svelte-5-preview.vercel.app/docs/deprecations#createeventdispatcher\n * @template {Record<string, any>} [EventMap = any]\n * @returns {EventDispatcher<EventMap>}\n */\nexport function createEventDispatcher() {\n\tconst active_component_context = component_context;\n\tif (active_component_context === null) {\n\t\tlifecycle_outside_component('createEventDispatcher');\n\t}\n\n\treturn (type, detail, options) => {\n\t\tconst events = /** @type {Record<string, Function | Function[]>} */ (\n\t\t\tactive_component_context.s.$$events\n\t\t)?.[/** @type {any} */ (type)];\n\n\t\tif (events) {\n\t\t\tconst callbacks = is_array(events) ? events.slice() : [events];\n\t\t\t// TODO are there situations where events could be dispatched\n\t\t\t// in a server (non-DOM) environment?\n\t\t\tconst event = create_custom_event(/** @type {string} */ (type), detail, options);\n\t\t\tfor (const fn of callbacks) {\n\t\t\t\tfn.call(active_component_context.x, event);\n\t\t\t}\n\t\t\treturn !event.defaultPrevented;\n\t\t}\n\n\t\treturn true;\n\t};\n}\n\n// TODO mark beforeUpdate and afterUpdate as deprecated in Svelte 6\n\n/**\n * Schedules a callback to run immediately before the component is updated after any state change.\n *\n * The first time the callback runs will be before the initial `onMount`.\n *\n * In runes mode use `$effect.pre` instead.\n *\n * @deprecated Use `$effect.pre` instead  see https://svelte-5-preview.vercel.app/docs/deprecations#beforeupdate-and-afterupdate\n * @param {() => void} fn\n * @returns {void}\n */\nexport function beforeUpdate(fn) {\n\tif (component_context === null) {\n\t\tlifecycle_outside_component('beforeUpdate');\n\t}\n\n\tif (component_context.l === null) {\n\t\te.lifecycle_legacy_only('beforeUpdate');\n\t}\n\n\tinit_update_callbacks(component_context).b.push(fn);\n}\n\n/**\n * Schedules a callback to run immediately after the component has been updated.\n *\n * The first time the callback runs will be after the initial `onMount`.\n *\n * In runes mode use `$effect` instead.\n *\n * @deprecated Use `$effect` instead  see https://svelte-5-preview.vercel.app/docs/deprecations#beforeupdate-and-afterupdate\n * @param {() => void} fn\n * @returns {void}\n */\nexport function afterUpdate(fn) {\n\tif (component_context === null) {\n\t\tlifecycle_outside_component('afterUpdate');\n\t}\n\n\tif (component_context.l === null) {\n\t\te.lifecycle_legacy_only('afterUpdate');\n\t}\n\n\tinit_update_callbacks(component_context).a.push(fn);\n}\n\n/**\n * Legacy-mode: Init callbacks object for onMount/beforeUpdate/afterUpdate\n * @param {ComponentContext} context\n */\nfunction init_update_callbacks(context) {\n\tvar l = /** @type {ComponentContextLegacy} */ (context).l;\n\treturn (l.u ??= { a: [], b: [], m: [] });\n}\n\n/**\n * Synchronously flushes any pending state changes and those that result from it.\n * @param {() => void} [fn]\n * @returns {void}\n */\nexport function flushSync(fn) {\n\tflush_sync(fn);\n}\n\nexport { hydrate, mount, unmount } from './internal/client/render.js';\n\nexport {\n\tgetContext,\n\tgetAllContexts,\n\thasContext,\n\tsetContext,\n\ttick,\n\tuntrack\n} from './internal/client/runtime.js';\n\nexport { createRawSnippet } from './internal/client/dom/blocks/snippet.js';\n","import { onDestroy, onMount } from 'svelte';\nexport const safeOnMount = (fn) => {\n    try {\n        onMount(fn);\n    }\n    catch {\n        return fn;\n    }\n};\nexport const safeOnDestroy = (fn) => {\n    try {\n        onDestroy(fn);\n    }\n    catch {\n        return fn;\n    }\n};\n","import { dequal } from 'dequal';\nexport function omit(obj, ...keys) {\n    const result = {};\n    for (const key of Object.keys(obj)) {\n        if (!keys.includes(key)) {\n            result[key] = obj[key];\n        }\n    }\n    return result;\n}\nexport function stripValues(inputObject, toStrip, recursive) {\n    return Object.fromEntries(Object.entries(inputObject).filter(([_, value]) => !dequal(value, toStrip)));\n}\nexport function removeUndefined(obj) {\n    const result = {};\n    for (const key in obj) {\n        const value = obj[key];\n        if (value !== undefined) {\n            result[key] = value;\n        }\n    }\n    return result;\n}\n","import { get, writable } from 'svelte/store';\n/**\n * Transforms an existing store into a store with a `get` method.\n * Uses subscriptions to keep the value up to date, so make sure to call `destroy` when you're done with it.\n * @date 20/01/2024 - 16:38:39\n *\n * @export\n * @template {Readable<unknown>} T\n * @param {T} store\n * @returns {WithGet<T>}\n */\nexport function withGet(store) {\n    return {\n        ...store,\n        get: () => get(store),\n    };\n}\nwithGet.writable = function (initial) {\n    const internal = writable(initial);\n    let value = initial;\n    return {\n        subscribe: internal.subscribe,\n        set(newValue) {\n            internal.set(newValue);\n            value = newValue;\n        },\n        update(updater) {\n            const newValue = updater(value);\n            internal.set(newValue);\n            value = newValue;\n        },\n        get() {\n            return value;\n        },\n    };\n};\nwithGet.derived = function (stores, fn) {\n    const subscribers = new Map();\n    const get = () => {\n        const values = Array.isArray(stores) ? stores.map((store) => store.get()) : stores.get();\n        return fn(values);\n    };\n    const subscribe = (subscriber) => {\n        const unsubscribers = [];\n        const storesArr = Array.isArray(stores) ? stores : [stores];\n        storesArr.forEach((store) => {\n            unsubscribers.push(store.subscribe(() => {\n                subscriber(get());\n            }));\n        });\n        subscriber(get());\n        subscribers.set(subscriber, unsubscribers);\n        return () => {\n            const unsubscribers = subscribers.get(subscriber);\n            if (unsubscribers) {\n                for (const unsubscribe of unsubscribers) {\n                    unsubscribe();\n                }\n            }\n            subscribers.delete(subscriber);\n        };\n    };\n    return {\n        get,\n        subscribe,\n    };\n};\nexport function addGetToStores(stores) {\n    return Object.keys(stores).reduce((acc, key) => {\n        return {\n            ...acc,\n            [key]: withGet(stores[key]),\n        };\n    }, {});\n}\n","import { withGet } from './withGet.js';\nexport const overridable = (_store, onChange) => {\n    const store = withGet(_store);\n    const update = (updater, sideEffect) => {\n        store.update((curr) => {\n            const next = updater(curr);\n            let res = next;\n            if (onChange) {\n                res = onChange({ curr, next });\n            }\n            sideEffect?.(res);\n            return res;\n        });\n    };\n    const set = (curr) => {\n        update(() => curr);\n    };\n    return {\n        ...store,\n        update,\n        set,\n    };\n};\n","export function sleep(ms) {\n    return new Promise((resolve) => setTimeout(resolve, ms));\n}\n","let urlAlphabet =\n  'useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict'\nexport let customAlphabet = (alphabet, defaultSize = 21) => {\n  return (size = defaultSize) => {\n    let id = ''\n    let i = size\n    while (i--) {\n      id += alphabet[(Math.random() * alphabet.length) | 0]\n    }\n    return id\n  }\n}\nexport let nanoid = (size = 21) => {\n  let id = ''\n  let i = size\n  while (i--) {\n    id += urlAlphabet[(Math.random() * 64) | 0]\n  }\n  return id\n}\n","import { nanoid } from 'nanoid/non-secure';\n/**\n * A function that generates a random id\n * @returns An id\n */\nexport function generateId() {\n    return nanoid(10);\n}\nexport function generateIds(args) {\n    return args.reduce((acc, curr) => {\n        acc[curr] = generateId();\n        return acc;\n    }, {});\n}\nexport function stringifiedIdObjType(args) {\n    return `Record<${args.map((arg) => `\"${arg}\"`).join(' | ')}, string>`;\n}\n","/**\n * A constant object that maps commonly used keyboard keys to their corresponding string values.\n * This object can be used in other parts of the application to handle keyboard input and prevent\n * hard-coded strings throughout.\n */\nexport const kbd = {\n    ALT: 'Alt',\n    ARROW_DOWN: 'ArrowDown',\n    ARROW_LEFT: 'ArrowLeft',\n    ARROW_RIGHT: 'ArrowRight',\n    ARROW_UP: 'ArrowUp',\n    BACKSPACE: 'Backspace',\n    CAPS_LOCK: 'CapsLock',\n    CONTROL: 'Control',\n    DELETE: 'Delete',\n    END: 'End',\n    ENTER: 'Enter',\n    ESCAPE: 'Escape',\n    F1: 'F1',\n    F10: 'F10',\n    F11: 'F11',\n    F12: 'F12',\n    F2: 'F2',\n    F3: 'F3',\n    F4: 'F4',\n    F5: 'F5',\n    F6: 'F6',\n    F7: 'F7',\n    F8: 'F8',\n    F9: 'F9',\n    HOME: 'Home',\n    META: 'Meta',\n    PAGE_DOWN: 'PageDown',\n    PAGE_UP: 'PageUp',\n    SHIFT: 'Shift',\n    SPACE: ' ',\n    TAB: 'Tab',\n    CTRL: 'Control',\n    ASTERISK: '*',\n    A: 'a',\n    P: 'p',\n};\n/** Key sets for navigation within lists, such as select, menu, and combobox. */\nexport const FIRST_KEYS = [kbd.ARROW_DOWN, kbd.PAGE_UP, kbd.HOME];\nexport const LAST_KEYS = [kbd.ARROW_UP, kbd.PAGE_DOWN, kbd.END];\nexport const FIRST_LAST_KEYS = [...FIRST_KEYS, ...LAST_KEYS];\nexport const SELECTION_KEYS = [kbd.ENTER, kbd.SPACE];\nexport const getNextKey = (dir = 'ltr', orientation = 'horizontal') => {\n    return {\n        horizontal: dir === 'rtl' ? kbd.ARROW_LEFT : kbd.ARROW_RIGHT,\n        vertical: kbd.ARROW_DOWN,\n    }[orientation];\n};\nexport const getPrevKey = (dir = 'ltr', orientation = 'horizontal') => {\n    return {\n        horizontal: dir === 'rtl' ? kbd.ARROW_RIGHT : kbd.ARROW_LEFT,\n        vertical: kbd.ARROW_UP,\n    }[orientation];\n};\nexport const getDirectionalKeys = (dir = 'ltr', orientation = 'horizontal') => {\n    return {\n        nextKey: getNextKey(dir, orientation),\n        prevKey: getPrevKey(dir, orientation),\n    };\n};\n","export function debounce(fn, wait = 500) {\n    let timeout = null;\n    return function (...args) {\n        const later = () => {\n            timeout = null;\n            fn(...args);\n        };\n        timeout && clearTimeout(timeout);\n        timeout = setTimeout(later, wait);\n    };\n}\n","export const isDom = () => typeof window !== 'undefined';\nexport function getPlatform() {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const agent = navigator.userAgentData;\n    return (agent?.platform ?? navigator.platform);\n}\nconst pt = (v) => isDom() && v.test(getPlatform().toLowerCase());\nconst ua = (v) => isDom() && v.test(navigator.userAgent);\nconst vn = (v) => isDom() && v.test(navigator.vendor);\nexport const isTouchDevice = () => isDom() && !!navigator.maxTouchPoints;\nexport const isMac = () => pt(/^mac/) && !isTouchDevice();\nexport const isIPhone = () => pt(/^iphone/);\nexport const isSafari = () => isApple() && vn(/apple/i);\nexport const isFirefox = () => ua(/firefox\\//i);\nexport const isApple = () => pt(/mac|iphone|ipad|ipod/i);\nexport const isIos = () => isApple() && !isMac();\n","// Modified from @zag-js/remove-scroll v0.10.2 (2023-06-10)\n// Source: https://github.com/chakra-ui/zag\n// https://github.com/chakra-ui/zag/blob/main/packages/utilities/remove-scroll/src/index.ts\nimport { noop } from './callbacks.js';\nimport { isIos } from './platform.js';\nconst LOCK_CLASSNAME = 'data-melt-scroll-lock';\nfunction assignStyle(el, style) {\n    if (!el)\n        return;\n    const previousStyle = el.style.cssText;\n    Object.assign(el.style, style);\n    return () => {\n        el.style.cssText = previousStyle;\n    };\n}\nfunction setCSSProperty(el, property, value) {\n    if (!el)\n        return;\n    const previousValue = el.style.getPropertyValue(property);\n    el.style.setProperty(property, value);\n    return () => {\n        if (previousValue) {\n            el.style.setProperty(property, previousValue);\n        }\n        else {\n            el.style.removeProperty(property);\n        }\n    };\n}\nfunction getPaddingProperty(documentElement) {\n    // RTL <body> scrollbar\n    const documentLeft = documentElement.getBoundingClientRect().left;\n    const scrollbarX = Math.round(documentLeft) + documentElement.scrollLeft;\n    return scrollbarX ? 'paddingLeft' : 'paddingRight';\n}\nexport function removeScroll(_document) {\n    const doc = _document ?? document;\n    const win = doc.defaultView ?? window;\n    const { documentElement, body } = doc;\n    const locked = body.hasAttribute(LOCK_CLASSNAME);\n    if (locked)\n        return noop;\n    body.setAttribute(LOCK_CLASSNAME, '');\n    const scrollbarWidth = win.innerWidth - documentElement.clientWidth;\n    const setScrollbarWidthProperty = () => setCSSProperty(documentElement, '--scrollbar-width', `${scrollbarWidth}px`);\n    const paddingProperty = getPaddingProperty(documentElement);\n    const scrollbarSidePadding = win.getComputedStyle(body)[paddingProperty];\n    const setStyle = () => assignStyle(body, {\n        overflow: 'hidden',\n        [paddingProperty]: `calc(${scrollbarSidePadding} + ${scrollbarWidth}px)`,\n    });\n    // Only iOS doesn't respect `overflow: hidden` on document.body\n    const setIOSStyle = () => {\n        const { scrollX, scrollY, visualViewport } = win;\n        // iOS 12 does not support `visuaViewport`.\n        const offsetLeft = visualViewport?.offsetLeft ?? 0;\n        const offsetTop = visualViewport?.offsetTop ?? 0;\n        const restoreStyle = assignStyle(body, {\n            position: 'fixed',\n            overflow: 'hidden',\n            top: `${-(scrollY - Math.floor(offsetTop))}px`,\n            left: `${-(scrollX - Math.floor(offsetLeft))}px`,\n            right: '0',\n            [paddingProperty]: `calc(${scrollbarSidePadding} + ${scrollbarWidth}px)`,\n        });\n        return () => {\n            restoreStyle?.();\n            win.scrollTo(scrollX, scrollY);\n        };\n    };\n    const cleanups = [setScrollbarWidthProperty(), isIos() ? setIOSStyle() : setStyle()];\n    return () => {\n        cleanups.forEach((fn) => fn?.());\n        body.removeAttribute(LOCK_CLASSNAME);\n    };\n}\n","import { derived } from 'svelte/store';\n/**\n * Helper function to standardize the way we derive a visible state for the\n * popper/floating elements.\n */\nexport function derivedVisible(obj) {\n    const { open, forceVisible, activeTrigger } = obj;\n    return derived([open, forceVisible, activeTrigger], ([$open, $forceVisible, $activeTrigger]) => ($open || $forceVisible) && $activeTrigger !== null);\n}\n","import { derived } from 'svelte/store';\nimport { noop } from '../index.js';\nimport { safeOnDestroy } from '../lifecycle.js';\n/**\n * A utility function that creates an effect from a set of stores and a function.\n * The effect is automatically cleaned up when the component is destroyed.\n *\n * @template S - The type of the stores object\n * @param stores - The stores object to derive from\n * @param fn - The function to run when the stores change\n * @returns A function that can be used to unsubscribe the effect\n */\nexport function effect(stores, fn) {\n    let cb = undefined;\n    // Create a derived store that contains the stores object and an onUnsubscribe function\n    const destroy = derived(stores, (stores) => {\n        cb?.();\n        cb = fn(stores);\n    }).subscribe(noop);\n    const unsub = () => {\n        destroy();\n        cb?.();\n    };\n    // Automatically unsubscribe the effect when the component is destroyed\n    safeOnDestroy(unsub);\n    return unsub;\n}\n","import { writable } from 'svelte/store';\nimport { withGet } from '../withGet.js';\n/**\n * Given an object of properties, returns an object of writable stores\n * with the same properties and values.\n */\nexport function toWritableStores(properties) {\n    const result = {};\n    Object.keys(properties).forEach((key) => {\n        const propertyKey = key;\n        const value = properties[propertyKey];\n        result[propertyKey] = withGet(writable(value));\n    });\n    return result;\n}\n","import { isBrowser, isHTMLElement } from './is.js';\nimport { sleep } from './sleep.js';\n/**\n * Manage roving focus between elements. Sets the current active element to\n * tabindex -1 and the next element to tabindex 0.\n *\n * @param nextElement The element to focus on\n */\nexport function handleRovingFocus(nextElement) {\n    if (!isBrowser)\n        return;\n    sleep(1).then(() => {\n        const currentFocusedElement = document.activeElement;\n        if (!isHTMLElement(currentFocusedElement) || currentFocusedElement === nextElement)\n            return;\n        currentFocusedElement.tabIndex = -1;\n        if (nextElement) {\n            nextElement.tabIndex = 0;\n            nextElement.focus();\n        }\n    });\n}\nfunction getFocusableElements() {\n    return Array.from(document.querySelectorAll('a[href]:not([tabindex=\"-1\"]), button:not([disabled]):not([tabindex=\"-1\"]), input:not([disabled]):not([tabindex=\"-1\"]), select:not([disabled]):not([tabindex=\"-1\"]), textarea:not([disabled]):not([tabindex=\"-1\"]), [tabindex]:not([tabindex=\"-1\"])'));\n}\nexport function getNextFocusable(currentElement) {\n    const focusableElements = getFocusableElements();\n    const currentIndex = focusableElements.indexOf(currentElement);\n    const nextIndex = currentIndex + 1;\n    const nextElement = focusableElements[nextIndex];\n    if (nextIndex < focusableElements.length && isHTMLElement(nextElement)) {\n        return nextElement;\n    }\n    return null;\n}\nexport function getPreviousFocusable(currentElement) {\n    const focusableElements = getFocusableElements();\n    const currentIndex = focusableElements.indexOf(currentElement);\n    const previousIndex = currentIndex - 1;\n    const prevElement = focusableElements[previousIndex];\n    if (previousIndex >= 0 && isHTMLElement(prevElement)) {\n        return prevElement;\n    }\n    return null;\n}\n","import { get, writable } from 'svelte/store';\nimport { wrapArray } from './array.js';\nimport { debounce } from './debounce.js';\nimport { isHTMLElement } from './is.js';\nimport { handleRovingFocus } from './rovingFocus.js';\nimport { withGet } from './withGet.js';\n/**\n * Keys to ignore for typeahead so we aren't matching things\n * like `Shift menu item` or `Control center` or `Alt menu` when\n * a user presses those keys.\n */\nconst ignoredKeys = new Set(['Shift', 'Control', 'Alt', 'Meta', 'CapsLock', 'NumLock']);\n/**\n * Default options for the typeahead search.\n * We default to roving focus when a match is found, but\n * you can override this with the `onMatch` option.\n */\nconst defaults = {\n    onMatch: handleRovingFocus,\n    getCurrentItem: () => document.activeElement,\n};\nexport function createTypeaheadSearch(args = {}) {\n    const withDefaults = { ...defaults, ...args };\n    const typed = withGet(writable([]));\n    const resetTyped = debounce(() => {\n        typed.update(() => []);\n    });\n    const handleTypeaheadSearch = (key, items) => {\n        if (ignoredKeys.has(key))\n            return;\n        const currentItem = withDefaults.getCurrentItem();\n        const $typed = get(typed);\n        if (!Array.isArray($typed)) {\n            return;\n        }\n        $typed.push(key.toLowerCase());\n        typed.set($typed);\n        const candidateItems = items.filter((item) => {\n            if (item.getAttribute('disabled') === 'true' ||\n                item.getAttribute('aria-disabled') === 'true' ||\n                item.hasAttribute('data-disabled')) {\n                return false;\n            }\n            return true;\n        });\n        const isRepeated = $typed.length > 1 && $typed.every((char) => char === $typed[0]);\n        const normalizeSearch = isRepeated ? $typed[0] : $typed.join('');\n        const currentItemIndex = isHTMLElement(currentItem) ? candidateItems.indexOf(currentItem) : -1;\n        let wrappedItems = wrapArray(candidateItems, Math.max(currentItemIndex, 0));\n        const excludeCurrentItem = normalizeSearch.length === 1;\n        if (excludeCurrentItem) {\n            wrappedItems = wrappedItems.filter((v) => v !== currentItem);\n        }\n        const nextItem = wrappedItems.find((item) => item?.innerText && item.innerText.toLowerCase().startsWith(normalizeSearch.toLowerCase()));\n        if (isHTMLElement(nextItem) && nextItem !== currentItem) {\n            withDefaults.onMatch(nextItem);\n        }\n        resetTyped();\n    };\n    return {\n        typed,\n        resetTyped,\n        handleTypeaheadSearch,\n    };\n}\n","import { isHTMLElement } from './is.js';\n/**\n * Get an element's ancestor which has a `data-portal` attribute.\n * This is used to handle nested portals/overlays/dialogs/popovers.\n */\nfunction getPortalParent(node) {\n    let parent = node.parentElement;\n    while (isHTMLElement(parent) && !parent.hasAttribute('data-portal')) {\n        parent = parent.parentElement;\n    }\n    return parent || 'body';\n}\n/**\n * Gets the destination for a portal given the node and a user-specified portal prop.\n * If a portal prop is not `undefined`, it is used as the destination.\n */\nexport function getPortalDestination(node, portalProp) {\n    // user-specified portal prop, use it\n    if (portalProp !== undefined)\n        return portalProp;\n    // find the closest portal parent, or the body if none is found\n    const portalParent = getPortalParent(node);\n    // if the portalParent is the body, we portal to the body\n    // making it a \"top-level\" portal\n    if (portalParent === 'body')\n        return document.body;\n    // if the portalParent is not the body, we have a portal parent\n    // and shouldn't portal to anything so it remains within that parent\n    // so we return `null`\n    return null;\n}\n","import { isFunction, isHTMLElement, sleep } from './index.js';\nimport { tick } from 'svelte';\nexport async function handleFocus(args) {\n    const { prop, defaultEl } = args;\n    await Promise.all([sleep(1), tick]);\n    if (prop === undefined) {\n        defaultEl?.focus();\n        return;\n    }\n    const returned = isFunction(prop) ? prop(defaultEl) : prop;\n    if (typeof returned === 'string') {\n        // Get el by selector, focus it\n        const el = document.querySelector(returned);\n        if (!isHTMLElement(el))\n            return;\n        el.focus();\n    }\n    else if (isHTMLElement(returned)) {\n        // Focus it\n        returned.focus();\n    }\n}\n","// Modified from Grail UI v0.9.6 (2023-06-10)\n// Source: https://github.com/grail-ui/grail-ui\n// https://github.com/grail-ui/grail-ui/tree/master/packages/grail-ui/src/clickOutside/clickOutside.ts\nimport { readable } from 'svelte/store';\nimport { addEventListener } from '../../helpers/event.js';\nimport { get } from 'svelte/store';\nimport { isFunction } from '../../helpers/is.js';\n/**\n * Creates a readable store that tracks the latest PointerEvent that occurred on the document.\n *\n * @returns A function to unsubscribe from the event listener and stop tracking pointer events.\n */\nconst documentClickStore = readable(undefined, (set) => {\n    /**\n     * Event handler for pointerdown events on the document.\n     * Updates the store's value with the latest PointerEvent and then resets it to undefined.\n     */\n    function clicked(event) {\n        set(event);\n        // New subscriptions will not trigger immediately\n        set(undefined);\n    }\n    // Adds a pointerdown event listener to the document, calling the clicked function when triggered.\n    const unsubscribe = addEventListener(document, 'pointerup', clicked, {\n        passive: false,\n        capture: true,\n    });\n    // Returns a function to unsubscribe from the event listener and stop tracking pointer events.\n    return unsubscribe;\n});\nexport const useClickOutside = (node, config = {}) => {\n    let options = { enabled: true, ...config };\n    // Returns true if the click outside handler is enabled\n    function isEnabled() {\n        return typeof options.enabled === 'boolean' ? options.enabled : get(options.enabled);\n    }\n    // Handle document clicks\n    const unsubscribe = documentClickStore.subscribe((e) => {\n        // If the click outside handler is disabled, or if the event is null or the node itself, return early\n        if (!isEnabled() || !e || e.target === node) {\n            return;\n        }\n        const composedPath = e.composedPath();\n        // If the target is in the node, return early\n        if (composedPath.includes(node))\n            return;\n        // If an ignore function is passed, check if it returns true\n        if (options.ignore) {\n            if (isFunction(options.ignore)) {\n                if (options.ignore(e))\n                    return;\n            }\n            // If an ignore array is passed, check if any elements in the array match the target\n            else if (Array.isArray(options.ignore)) {\n                if (options.ignore.length > 0 &&\n                    options.ignore.some((ignoreEl) => {\n                        return ignoreEl && (e.target === ignoreEl || composedPath.includes(ignoreEl));\n                    }))\n                    return;\n            }\n        }\n        // If none of the above conditions are met, call the handler\n        options.handler?.(e);\n    });\n    return {\n        update(params) {\n            options = { ...options, ...params };\n        },\n        destroy() {\n            unsubscribe();\n        },\n    };\n};\n","import { addEventListener } from '../../helpers/event.js';\nimport { isFunction, isHTMLElement, isReadable } from '../../helpers/is.js';\nimport { get, readable } from 'svelte/store';\nimport { effect, executeCallbacks, kbd, noop } from '../../helpers/index.js';\n/**\n * Creates a readable store that tracks the latest Escape Keydown that occurred on the document.\n *\n * @returns A function to unsubscribe from the event listener and stop tracking keydown events.\n */\nconst documentEscapeKeyStore = readable(undefined, (set) => {\n    /**\n     * Event handler for keydown events on the document.\n     * Updates the store's value with the latest Escape Keydown event and then resets it to undefined.\n     */\n    function keydown(event) {\n        if (event && event.key === kbd.ESCAPE) {\n            set(event);\n        }\n        // New subscriptions will not trigger immediately\n        set(undefined);\n    }\n    // Adds a keydown event listener to the document, calling the keydown function when triggered.\n    const unsubscribe = addEventListener(document, 'keydown', keydown, {\n        passive: false,\n    });\n    // Returns a function to unsubscribe from the event listener and stop tracking keydown events.\n    return unsubscribe;\n});\nexport const useEscapeKeydown = ((node, config = {}) => {\n    let unsub = noop;\n    function update(config = {}) {\n        unsub();\n        const options = { enabled: true, ...config };\n        const enabled = (isReadable(options.enabled) ? options.enabled : readable(options.enabled));\n        unsub = executeCallbacks(\n        // Handle escape keydowns\n        documentEscapeKeyStore.subscribe((e) => {\n            if (!e || !get(enabled))\n                return;\n            const target = e.target;\n            if (!isHTMLElement(target) || target.closest('[data-escapee]') !== node) {\n                return;\n            }\n            e.preventDefault();\n            // If an ignore function is passed, check if it returns true\n            if (options.ignore) {\n                if (isFunction(options.ignore)) {\n                    if (options.ignore(e))\n                        return;\n                }\n                // If an ignore array is passed, check if any elements in the array match the target\n                else if (Array.isArray(options.ignore)) {\n                    if (options.ignore.length > 0 &&\n                        options.ignore.some((ignoreEl) => {\n                            return ignoreEl && target === ignoreEl;\n                        }))\n                        return;\n                }\n            }\n            // If none of the above conditions are met, call the handler\n            options.handler?.(e);\n        }), effect(enabled, ($enabled) => {\n            if ($enabled) {\n                node.dataset.escapee = '';\n            }\n            else {\n                delete node.dataset.escapee;\n            }\n        }));\n    }\n    update(config);\n    return {\n        update,\n        destroy() {\n            node.removeAttribute('data-escapee');\n            unsub();\n        },\n    };\n});\n","/**\n * Custom positioning reference element.\n * @see https://floating-ui.com/docs/virtual-elements\n */\n\nconst sides = ['top', 'right', 'bottom', 'left'];\nconst alignments = ['start', 'end'];\nconst placements = /*#__PURE__*/sides.reduce((acc, side) => acc.concat(side, side + \"-\" + alignments[0], side + \"-\" + alignments[1]), []);\nconst min = Math.min;\nconst max = Math.max;\nconst round = Math.round;\nconst floor = Math.floor;\nconst createCoords = v => ({\n  x: v,\n  y: v\n});\nconst oppositeSideMap = {\n  left: 'right',\n  right: 'left',\n  bottom: 'top',\n  top: 'bottom'\n};\nconst oppositeAlignmentMap = {\n  start: 'end',\n  end: 'start'\n};\nfunction clamp(start, value, end) {\n  return max(start, min(value, end));\n}\nfunction evaluate(value, param) {\n  return typeof value === 'function' ? value(param) : value;\n}\nfunction getSide(placement) {\n  return placement.split('-')[0];\n}\nfunction getAlignment(placement) {\n  return placement.split('-')[1];\n}\nfunction getOppositeAxis(axis) {\n  return axis === 'x' ? 'y' : 'x';\n}\nfunction getAxisLength(axis) {\n  return axis === 'y' ? 'height' : 'width';\n}\nfunction getSideAxis(placement) {\n  return ['top', 'bottom'].includes(getSide(placement)) ? 'y' : 'x';\n}\nfunction getAlignmentAxis(placement) {\n  return getOppositeAxis(getSideAxis(placement));\n}\nfunction getAlignmentSides(placement, rects, rtl) {\n  if (rtl === void 0) {\n    rtl = false;\n  }\n  const alignment = getAlignment(placement);\n  const alignmentAxis = getAlignmentAxis(placement);\n  const length = getAxisLength(alignmentAxis);\n  let mainAlignmentSide = alignmentAxis === 'x' ? alignment === (rtl ? 'end' : 'start') ? 'right' : 'left' : alignment === 'start' ? 'bottom' : 'top';\n  if (rects.reference[length] > rects.floating[length]) {\n    mainAlignmentSide = getOppositePlacement(mainAlignmentSide);\n  }\n  return [mainAlignmentSide, getOppositePlacement(mainAlignmentSide)];\n}\nfunction getExpandedPlacements(placement) {\n  const oppositePlacement = getOppositePlacement(placement);\n  return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];\n}\nfunction getOppositeAlignmentPlacement(placement) {\n  return placement.replace(/start|end/g, alignment => oppositeAlignmentMap[alignment]);\n}\nfunction getSideList(side, isStart, rtl) {\n  const lr = ['left', 'right'];\n  const rl = ['right', 'left'];\n  const tb = ['top', 'bottom'];\n  const bt = ['bottom', 'top'];\n  switch (side) {\n    case 'top':\n    case 'bottom':\n      if (rtl) return isStart ? rl : lr;\n      return isStart ? lr : rl;\n    case 'left':\n    case 'right':\n      return isStart ? tb : bt;\n    default:\n      return [];\n  }\n}\nfunction getOppositeAxisPlacements(placement, flipAlignment, direction, rtl) {\n  const alignment = getAlignment(placement);\n  let list = getSideList(getSide(placement), direction === 'start', rtl);\n  if (alignment) {\n    list = list.map(side => side + \"-\" + alignment);\n    if (flipAlignment) {\n      list = list.concat(list.map(getOppositeAlignmentPlacement));\n    }\n  }\n  return list;\n}\nfunction getOppositePlacement(placement) {\n  return placement.replace(/left|right|bottom|top/g, side => oppositeSideMap[side]);\n}\nfunction expandPaddingObject(padding) {\n  return {\n    top: 0,\n    right: 0,\n    bottom: 0,\n    left: 0,\n    ...padding\n  };\n}\nfunction getPaddingObject(padding) {\n  return typeof padding !== 'number' ? expandPaddingObject(padding) : {\n    top: padding,\n    right: padding,\n    bottom: padding,\n    left: padding\n  };\n}\nfunction rectToClientRect(rect) {\n  const {\n    x,\n    y,\n    width,\n    height\n  } = rect;\n  return {\n    width,\n    height,\n    top: y,\n    left: x,\n    right: x + width,\n    bottom: y + height,\n    x,\n    y\n  };\n}\n\nexport { alignments, clamp, createCoords, evaluate, expandPaddingObject, floor, getAlignment, getAlignmentAxis, getAlignmentSides, getAxisLength, getExpandedPlacements, getOppositeAlignmentPlacement, getOppositeAxis, getOppositeAxisPlacements, getOppositePlacement, getPaddingObject, getSide, getSideAxis, max, min, placements, rectToClientRect, round, sides };\n","import { getSideAxis, getAlignmentAxis, getAxisLength, getSide, getAlignment, evaluate, getPaddingObject, rectToClientRect, min, clamp, placements, getAlignmentSides, getOppositeAlignmentPlacement, getOppositePlacement, getExpandedPlacements, getOppositeAxisPlacements, sides, max, getOppositeAxis } from '@floating-ui/utils';\nexport { rectToClientRect } from '@floating-ui/utils';\n\nfunction computeCoordsFromPlacement(_ref, placement, rtl) {\n  let {\n    reference,\n    floating\n  } = _ref;\n  const sideAxis = getSideAxis(placement);\n  const alignmentAxis = getAlignmentAxis(placement);\n  const alignLength = getAxisLength(alignmentAxis);\n  const side = getSide(placement);\n  const isVertical = sideAxis === 'y';\n  const commonX = reference.x + reference.width / 2 - floating.width / 2;\n  const commonY = reference.y + reference.height / 2 - floating.height / 2;\n  const commonAlign = reference[alignLength] / 2 - floating[alignLength] / 2;\n  let coords;\n  switch (side) {\n    case 'top':\n      coords = {\n        x: commonX,\n        y: reference.y - floating.height\n      };\n      break;\n    case 'bottom':\n      coords = {\n        x: commonX,\n        y: reference.y + reference.height\n      };\n      break;\n    case 'right':\n      coords = {\n        x: reference.x + reference.width,\n        y: commonY\n      };\n      break;\n    case 'left':\n      coords = {\n        x: reference.x - floating.width,\n        y: commonY\n      };\n      break;\n    default:\n      coords = {\n        x: reference.x,\n        y: reference.y\n      };\n  }\n  switch (getAlignment(placement)) {\n    case 'start':\n      coords[alignmentAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);\n      break;\n    case 'end':\n      coords[alignmentAxis] += commonAlign * (rtl && isVertical ? -1 : 1);\n      break;\n  }\n  return coords;\n}\n\n/**\n * Computes the `x` and `y` coordinates that will place the floating element\n * next to a given reference element.\n *\n * This export does not have any `platform` interface logic. You will need to\n * write one for the platform you are using Floating UI with.\n */\nconst computePosition = async (reference, floating, config) => {\n  const {\n    placement = 'bottom',\n    strategy = 'absolute',\n    middleware = [],\n    platform\n  } = config;\n  const validMiddleware = middleware.filter(Boolean);\n  const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(floating));\n  let rects = await platform.getElementRects({\n    reference,\n    floating,\n    strategy\n  });\n  let {\n    x,\n    y\n  } = computeCoordsFromPlacement(rects, placement, rtl);\n  let statefulPlacement = placement;\n  let middlewareData = {};\n  let resetCount = 0;\n  for (let i = 0; i < validMiddleware.length; i++) {\n    const {\n      name,\n      fn\n    } = validMiddleware[i];\n    const {\n      x: nextX,\n      y: nextY,\n      data,\n      reset\n    } = await fn({\n      x,\n      y,\n      initialPlacement: placement,\n      placement: statefulPlacement,\n      strategy,\n      middlewareData,\n      rects,\n      platform,\n      elements: {\n        reference,\n        floating\n      }\n    });\n    x = nextX != null ? nextX : x;\n    y = nextY != null ? nextY : y;\n    middlewareData = {\n      ...middlewareData,\n      [name]: {\n        ...middlewareData[name],\n        ...data\n      }\n    };\n    if (reset && resetCount <= 50) {\n      resetCount++;\n      if (typeof reset === 'object') {\n        if (reset.placement) {\n          statefulPlacement = reset.placement;\n        }\n        if (reset.rects) {\n          rects = reset.rects === true ? await platform.getElementRects({\n            reference,\n            floating,\n            strategy\n          }) : reset.rects;\n        }\n        ({\n          x,\n          y\n        } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));\n      }\n      i = -1;\n    }\n  }\n  return {\n    x,\n    y,\n    placement: statefulPlacement,\n    strategy,\n    middlewareData\n  };\n};\n\n/**\n * Resolves with an object of overflow side offsets that determine how much the\n * element is overflowing a given clipping boundary on each side.\n * - positive = overflowing the boundary by that number of pixels\n * - negative = how many pixels left before it will overflow\n * - 0 = lies flush with the boundary\n * @see https://floating-ui.com/docs/detectOverflow\n */\nasync function detectOverflow(state, options) {\n  var _await$platform$isEle;\n  if (options === void 0) {\n    options = {};\n  }\n  const {\n    x,\n    y,\n    platform,\n    rects,\n    elements,\n    strategy\n  } = state;\n  const {\n    boundary = 'clippingAncestors',\n    rootBoundary = 'viewport',\n    elementContext = 'floating',\n    altBoundary = false,\n    padding = 0\n  } = evaluate(options, state);\n  const paddingObject = getPaddingObject(padding);\n  const altContext = elementContext === 'floating' ? 'reference' : 'floating';\n  const element = elements[altBoundary ? altContext : elementContext];\n  const clippingClientRect = rectToClientRect(await platform.getClippingRect({\n    element: ((_await$platform$isEle = await (platform.isElement == null ? void 0 : platform.isElement(element))) != null ? _await$platform$isEle : true) ? element : element.contextElement || (await (platform.getDocumentElement == null ? void 0 : platform.getDocumentElement(elements.floating))),\n    boundary,\n    rootBoundary,\n    strategy\n  }));\n  const rect = elementContext === 'floating' ? {\n    x,\n    y,\n    width: rects.floating.width,\n    height: rects.floating.height\n  } : rects.reference;\n  const offsetParent = await (platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(elements.floating));\n  const offsetScale = (await (platform.isElement == null ? void 0 : platform.isElement(offsetParent))) ? (await (platform.getScale == null ? void 0 : platform.getScale(offsetParent))) || {\n    x: 1,\n    y: 1\n  } : {\n    x: 1,\n    y: 1\n  };\n  const elementClientRect = rectToClientRect(platform.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform.convertOffsetParentRelativeRectToViewportRelativeRect({\n    elements,\n    rect,\n    offsetParent,\n    strategy\n  }) : rect);\n  return {\n    top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,\n    bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,\n    left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,\n    right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x\n  };\n}\n\n/**\n * Provides data to position an inner element of the floating element so that it\n * appears centered to the reference element.\n * @see https://floating-ui.com/docs/arrow\n */\nconst arrow = options => ({\n  name: 'arrow',\n  options,\n  async fn(state) {\n    const {\n      x,\n      y,\n      placement,\n      rects,\n      platform,\n      elements,\n      middlewareData\n    } = state;\n    // Since `element` is required, we don't Partial<> the type.\n    const {\n      element,\n      padding = 0\n    } = evaluate(options, state) || {};\n    if (element == null) {\n      return {};\n    }\n    const paddingObject = getPaddingObject(padding);\n    const coords = {\n      x,\n      y\n    };\n    const axis = getAlignmentAxis(placement);\n    const length = getAxisLength(axis);\n    const arrowDimensions = await platform.getDimensions(element);\n    const isYAxis = axis === 'y';\n    const minProp = isYAxis ? 'top' : 'left';\n    const maxProp = isYAxis ? 'bottom' : 'right';\n    const clientProp = isYAxis ? 'clientHeight' : 'clientWidth';\n    const endDiff = rects.reference[length] + rects.reference[axis] - coords[axis] - rects.floating[length];\n    const startDiff = coords[axis] - rects.reference[axis];\n    const arrowOffsetParent = await (platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(element));\n    let clientSize = arrowOffsetParent ? arrowOffsetParent[clientProp] : 0;\n\n    // DOM platform can return `window` as the `offsetParent`.\n    if (!clientSize || !(await (platform.isElement == null ? void 0 : platform.isElement(arrowOffsetParent)))) {\n      clientSize = elements.floating[clientProp] || rects.floating[length];\n    }\n    const centerToReference = endDiff / 2 - startDiff / 2;\n\n    // If the padding is large enough that it causes the arrow to no longer be\n    // centered, modify the padding so that it is centered.\n    const largestPossiblePadding = clientSize / 2 - arrowDimensions[length] / 2 - 1;\n    const minPadding = min(paddingObject[minProp], largestPossiblePadding);\n    const maxPadding = min(paddingObject[maxProp], largestPossiblePadding);\n\n    // Make sure the arrow doesn't overflow the floating element if the center\n    // point is outside the floating element's bounds.\n    const min$1 = minPadding;\n    const max = clientSize - arrowDimensions[length] - maxPadding;\n    const center = clientSize / 2 - arrowDimensions[length] / 2 + centerToReference;\n    const offset = clamp(min$1, center, max);\n\n    // If the reference is small enough that the arrow's padding causes it to\n    // to point to nothing for an aligned placement, adjust the offset of the\n    // floating element itself. To ensure `shift()` continues to take action,\n    // a single reset is performed when this is true.\n    const shouldAddOffset = !middlewareData.arrow && getAlignment(placement) != null && center !== offset && rects.reference[length] / 2 - (center < min$1 ? minPadding : maxPadding) - arrowDimensions[length] / 2 < 0;\n    const alignmentOffset = shouldAddOffset ? center < min$1 ? center - min$1 : center - max : 0;\n    return {\n      [axis]: coords[axis] + alignmentOffset,\n      data: {\n        [axis]: offset,\n        centerOffset: center - offset - alignmentOffset,\n        ...(shouldAddOffset && {\n          alignmentOffset\n        })\n      },\n      reset: shouldAddOffset\n    };\n  }\n});\n\nfunction getPlacementList(alignment, autoAlignment, allowedPlacements) {\n  const allowedPlacementsSortedByAlignment = alignment ? [...allowedPlacements.filter(placement => getAlignment(placement) === alignment), ...allowedPlacements.filter(placement => getAlignment(placement) !== alignment)] : allowedPlacements.filter(placement => getSide(placement) === placement);\n  return allowedPlacementsSortedByAlignment.filter(placement => {\n    if (alignment) {\n      return getAlignment(placement) === alignment || (autoAlignment ? getOppositeAlignmentPlacement(placement) !== placement : false);\n    }\n    return true;\n  });\n}\n/**\n * Optimizes the visibility of the floating element by choosing the placement\n * that has the most space available automatically, without needing to specify a\n * preferred placement. Alternative to `flip`.\n * @see https://floating-ui.com/docs/autoPlacement\n */\nconst autoPlacement = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'autoPlacement',\n    options,\n    async fn(state) {\n      var _middlewareData$autoP, _middlewareData$autoP2, _placementsThatFitOnE;\n      const {\n        rects,\n        middlewareData,\n        placement,\n        platform,\n        elements\n      } = state;\n      const {\n        crossAxis = false,\n        alignment,\n        allowedPlacements = placements,\n        autoAlignment = true,\n        ...detectOverflowOptions\n      } = evaluate(options, state);\n      const placements$1 = alignment !== undefined || allowedPlacements === placements ? getPlacementList(alignment || null, autoAlignment, allowedPlacements) : allowedPlacements;\n      const overflow = await detectOverflow(state, detectOverflowOptions);\n      const currentIndex = ((_middlewareData$autoP = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP.index) || 0;\n      const currentPlacement = placements$1[currentIndex];\n      if (currentPlacement == null) {\n        return {};\n      }\n      const alignmentSides = getAlignmentSides(currentPlacement, rects, await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating)));\n\n      // Make `computeCoords` start from the right place.\n      if (placement !== currentPlacement) {\n        return {\n          reset: {\n            placement: placements$1[0]\n          }\n        };\n      }\n      const currentOverflows = [overflow[getSide(currentPlacement)], overflow[alignmentSides[0]], overflow[alignmentSides[1]]];\n      const allOverflows = [...(((_middlewareData$autoP2 = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP2.overflows) || []), {\n        placement: currentPlacement,\n        overflows: currentOverflows\n      }];\n      const nextPlacement = placements$1[currentIndex + 1];\n\n      // There are more placements to check.\n      if (nextPlacement) {\n        return {\n          data: {\n            index: currentIndex + 1,\n            overflows: allOverflows\n          },\n          reset: {\n            placement: nextPlacement\n          }\n        };\n      }\n      const placementsSortedByMostSpace = allOverflows.map(d => {\n        const alignment = getAlignment(d.placement);\n        return [d.placement, alignment && crossAxis ?\n        // Check along the mainAxis and main crossAxis side.\n        d.overflows.slice(0, 2).reduce((acc, v) => acc + v, 0) :\n        // Check only the mainAxis.\n        d.overflows[0], d.overflows];\n      }).sort((a, b) => a[1] - b[1]);\n      const placementsThatFitOnEachSide = placementsSortedByMostSpace.filter(d => d[2].slice(0,\n      // Aligned placements should not check their opposite crossAxis\n      // side.\n      getAlignment(d[0]) ? 2 : 3).every(v => v <= 0));\n      const resetPlacement = ((_placementsThatFitOnE = placementsThatFitOnEachSide[0]) == null ? void 0 : _placementsThatFitOnE[0]) || placementsSortedByMostSpace[0][0];\n      if (resetPlacement !== placement) {\n        return {\n          data: {\n            index: currentIndex + 1,\n            overflows: allOverflows\n          },\n          reset: {\n            placement: resetPlacement\n          }\n        };\n      }\n      return {};\n    }\n  };\n};\n\n/**\n * Optimizes the visibility of the floating element by flipping the `placement`\n * in order to keep it in view when the preferred placement(s) will overflow the\n * clipping boundary. Alternative to `autoPlacement`.\n * @see https://floating-ui.com/docs/flip\n */\nconst flip = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'flip',\n    options,\n    async fn(state) {\n      var _middlewareData$arrow, _middlewareData$flip;\n      const {\n        placement,\n        middlewareData,\n        rects,\n        initialPlacement,\n        platform,\n        elements\n      } = state;\n      const {\n        mainAxis: checkMainAxis = true,\n        crossAxis: checkCrossAxis = true,\n        fallbackPlacements: specifiedFallbackPlacements,\n        fallbackStrategy = 'bestFit',\n        fallbackAxisSideDirection = 'none',\n        flipAlignment = true,\n        ...detectOverflowOptions\n      } = evaluate(options, state);\n\n      // If a reset by the arrow was caused due to an alignment offset being\n      // added, we should skip any logic now since `flip()` has already done its\n      // work.\n      // https://github.com/floating-ui/floating-ui/issues/2549#issuecomment-1719601643\n      if ((_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {\n        return {};\n      }\n      const side = getSide(placement);\n      const initialSideAxis = getSideAxis(initialPlacement);\n      const isBasePlacement = getSide(initialPlacement) === initialPlacement;\n      const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating));\n      const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement));\n      const hasFallbackAxisSideDirection = fallbackAxisSideDirection !== 'none';\n      if (!specifiedFallbackPlacements && hasFallbackAxisSideDirection) {\n        fallbackPlacements.push(...getOppositeAxisPlacements(initialPlacement, flipAlignment, fallbackAxisSideDirection, rtl));\n      }\n      const placements = [initialPlacement, ...fallbackPlacements];\n      const overflow = await detectOverflow(state, detectOverflowOptions);\n      const overflows = [];\n      let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];\n      if (checkMainAxis) {\n        overflows.push(overflow[side]);\n      }\n      if (checkCrossAxis) {\n        const sides = getAlignmentSides(placement, rects, rtl);\n        overflows.push(overflow[sides[0]], overflow[sides[1]]);\n      }\n      overflowsData = [...overflowsData, {\n        placement,\n        overflows\n      }];\n\n      // One or more sides is overflowing.\n      if (!overflows.every(side => side <= 0)) {\n        var _middlewareData$flip2, _overflowsData$filter;\n        const nextIndex = (((_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) || 0) + 1;\n        const nextPlacement = placements[nextIndex];\n        if (nextPlacement) {\n          // Try next placement and re-run the lifecycle.\n          return {\n            data: {\n              index: nextIndex,\n              overflows: overflowsData\n            },\n            reset: {\n              placement: nextPlacement\n            }\n          };\n        }\n\n        // First, find the candidates that fit on the mainAxis side of overflow,\n        // then find the placement that fits the best on the main crossAxis side.\n        let resetPlacement = (_overflowsData$filter = overflowsData.filter(d => d.overflows[0] <= 0).sort((a, b) => a.overflows[1] - b.overflows[1])[0]) == null ? void 0 : _overflowsData$filter.placement;\n\n        // Otherwise fallback.\n        if (!resetPlacement) {\n          switch (fallbackStrategy) {\n            case 'bestFit':\n              {\n                var _overflowsData$filter2;\n                const placement = (_overflowsData$filter2 = overflowsData.filter(d => {\n                  if (hasFallbackAxisSideDirection) {\n                    const currentSideAxis = getSideAxis(d.placement);\n                    return currentSideAxis === initialSideAxis ||\n                    // Create a bias to the `y` side axis due to horizontal\n                    // reading directions favoring greater width.\n                    currentSideAxis === 'y';\n                  }\n                  return true;\n                }).map(d => [d.placement, d.overflows.filter(overflow => overflow > 0).reduce((acc, overflow) => acc + overflow, 0)]).sort((a, b) => a[1] - b[1])[0]) == null ? void 0 : _overflowsData$filter2[0];\n                if (placement) {\n                  resetPlacement = placement;\n                }\n                break;\n              }\n            case 'initialPlacement':\n              resetPlacement = initialPlacement;\n              break;\n          }\n        }\n        if (placement !== resetPlacement) {\n          return {\n            reset: {\n              placement: resetPlacement\n            }\n          };\n        }\n      }\n      return {};\n    }\n  };\n};\n\nfunction getSideOffsets(overflow, rect) {\n  return {\n    top: overflow.top - rect.height,\n    right: overflow.right - rect.width,\n    bottom: overflow.bottom - rect.height,\n    left: overflow.left - rect.width\n  };\n}\nfunction isAnySideFullyClipped(overflow) {\n  return sides.some(side => overflow[side] >= 0);\n}\n/**\n * Provides data to hide the floating element in applicable situations, such as\n * when it is not in the same clipping context as the reference element.\n * @see https://floating-ui.com/docs/hide\n */\nconst hide = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'hide',\n    options,\n    async fn(state) {\n      const {\n        rects\n      } = state;\n      const {\n        strategy = 'referenceHidden',\n        ...detectOverflowOptions\n      } = evaluate(options, state);\n      switch (strategy) {\n        case 'referenceHidden':\n          {\n            const overflow = await detectOverflow(state, {\n              ...detectOverflowOptions,\n              elementContext: 'reference'\n            });\n            const offsets = getSideOffsets(overflow, rects.reference);\n            return {\n              data: {\n                referenceHiddenOffsets: offsets,\n                referenceHidden: isAnySideFullyClipped(offsets)\n              }\n            };\n          }\n        case 'escaped':\n          {\n            const overflow = await detectOverflow(state, {\n              ...detectOverflowOptions,\n              altBoundary: true\n            });\n            const offsets = getSideOffsets(overflow, rects.floating);\n            return {\n              data: {\n                escapedOffsets: offsets,\n                escaped: isAnySideFullyClipped(offsets)\n              }\n            };\n          }\n        default:\n          {\n            return {};\n          }\n      }\n    }\n  };\n};\n\nfunction getBoundingRect(rects) {\n  const minX = min(...rects.map(rect => rect.left));\n  const minY = min(...rects.map(rect => rect.top));\n  const maxX = max(...rects.map(rect => rect.right));\n  const maxY = max(...rects.map(rect => rect.bottom));\n  return {\n    x: minX,\n    y: minY,\n    width: maxX - minX,\n    height: maxY - minY\n  };\n}\nfunction getRectsByLine(rects) {\n  const sortedRects = rects.slice().sort((a, b) => a.y - b.y);\n  const groups = [];\n  let prevRect = null;\n  for (let i = 0; i < sortedRects.length; i++) {\n    const rect = sortedRects[i];\n    if (!prevRect || rect.y - prevRect.y > prevRect.height / 2) {\n      groups.push([rect]);\n    } else {\n      groups[groups.length - 1].push(rect);\n    }\n    prevRect = rect;\n  }\n  return groups.map(rect => rectToClientRect(getBoundingRect(rect)));\n}\n/**\n * Provides improved positioning for inline reference elements that can span\n * over multiple lines, such as hyperlinks or range selections.\n * @see https://floating-ui.com/docs/inline\n */\nconst inline = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'inline',\n    options,\n    async fn(state) {\n      const {\n        placement,\n        elements,\n        rects,\n        platform,\n        strategy\n      } = state;\n      // A MouseEvent's client{X,Y} coords can be up to 2 pixels off a\n      // ClientRect's bounds, despite the event listener being triggered. A\n      // padding of 2 seems to handle this issue.\n      const {\n        padding = 2,\n        x,\n        y\n      } = evaluate(options, state);\n      const nativeClientRects = Array.from((await (platform.getClientRects == null ? void 0 : platform.getClientRects(elements.reference))) || []);\n      const clientRects = getRectsByLine(nativeClientRects);\n      const fallback = rectToClientRect(getBoundingRect(nativeClientRects));\n      const paddingObject = getPaddingObject(padding);\n      function getBoundingClientRect() {\n        // There are two rects and they are disjoined.\n        if (clientRects.length === 2 && clientRects[0].left > clientRects[1].right && x != null && y != null) {\n          // Find the first rect in which the point is fully inside.\n          return clientRects.find(rect => x > rect.left - paddingObject.left && x < rect.right + paddingObject.right && y > rect.top - paddingObject.top && y < rect.bottom + paddingObject.bottom) || fallback;\n        }\n\n        // There are 2 or more connected rects.\n        if (clientRects.length >= 2) {\n          if (getSideAxis(placement) === 'y') {\n            const firstRect = clientRects[0];\n            const lastRect = clientRects[clientRects.length - 1];\n            const isTop = getSide(placement) === 'top';\n            const top = firstRect.top;\n            const bottom = lastRect.bottom;\n            const left = isTop ? firstRect.left : lastRect.left;\n            const right = isTop ? firstRect.right : lastRect.right;\n            const width = right - left;\n            const height = bottom - top;\n            return {\n              top,\n              bottom,\n              left,\n              right,\n              width,\n              height,\n              x: left,\n              y: top\n            };\n          }\n          const isLeftSide = getSide(placement) === 'left';\n          const maxRight = max(...clientRects.map(rect => rect.right));\n          const minLeft = min(...clientRects.map(rect => rect.left));\n          const measureRects = clientRects.filter(rect => isLeftSide ? rect.left === minLeft : rect.right === maxRight);\n          const top = measureRects[0].top;\n          const bottom = measureRects[measureRects.length - 1].bottom;\n          const left = minLeft;\n          const right = maxRight;\n          const width = right - left;\n          const height = bottom - top;\n          return {\n            top,\n            bottom,\n            left,\n            right,\n            width,\n            height,\n            x: left,\n            y: top\n          };\n        }\n        return fallback;\n      }\n      const resetRects = await platform.getElementRects({\n        reference: {\n          getBoundingClientRect\n        },\n        floating: elements.floating,\n        strategy\n      });\n      if (rects.reference.x !== resetRects.reference.x || rects.reference.y !== resetRects.reference.y || rects.reference.width !== resetRects.reference.width || rects.reference.height !== resetRects.reference.height) {\n        return {\n          reset: {\n            rects: resetRects\n          }\n        };\n      }\n      return {};\n    }\n  };\n};\n\n// For type backwards-compatibility, the `OffsetOptions` type was also\n// Derivable.\n\nasync function convertValueToCoords(state, options) {\n  const {\n    placement,\n    platform,\n    elements\n  } = state;\n  const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating));\n  const side = getSide(placement);\n  const alignment = getAlignment(placement);\n  const isVertical = getSideAxis(placement) === 'y';\n  const mainAxisMulti = ['left', 'top'].includes(side) ? -1 : 1;\n  const crossAxisMulti = rtl && isVertical ? -1 : 1;\n  const rawValue = evaluate(options, state);\n\n  // eslint-disable-next-line prefer-const\n  let {\n    mainAxis,\n    crossAxis,\n    alignmentAxis\n  } = typeof rawValue === 'number' ? {\n    mainAxis: rawValue,\n    crossAxis: 0,\n    alignmentAxis: null\n  } : {\n    mainAxis: rawValue.mainAxis || 0,\n    crossAxis: rawValue.crossAxis || 0,\n    alignmentAxis: rawValue.alignmentAxis\n  };\n  if (alignment && typeof alignmentAxis === 'number') {\n    crossAxis = alignment === 'end' ? alignmentAxis * -1 : alignmentAxis;\n  }\n  return isVertical ? {\n    x: crossAxis * crossAxisMulti,\n    y: mainAxis * mainAxisMulti\n  } : {\n    x: mainAxis * mainAxisMulti,\n    y: crossAxis * crossAxisMulti\n  };\n}\n\n/**\n * Modifies the placement by translating the floating element along the\n * specified axes.\n * A number (shorthand for `mainAxis` or distance), or an axes configuration\n * object may be passed.\n * @see https://floating-ui.com/docs/offset\n */\nconst offset = function (options) {\n  if (options === void 0) {\n    options = 0;\n  }\n  return {\n    name: 'offset',\n    options,\n    async fn(state) {\n      var _middlewareData$offse, _middlewareData$arrow;\n      const {\n        x,\n        y,\n        placement,\n        middlewareData\n      } = state;\n      const diffCoords = await convertValueToCoords(state, options);\n\n      // If the placement is the same and the arrow caused an alignment offset\n      // then we don't need to change the positioning coordinates.\n      if (placement === ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse.placement) && (_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {\n        return {};\n      }\n      return {\n        x: x + diffCoords.x,\n        y: y + diffCoords.y,\n        data: {\n          ...diffCoords,\n          placement\n        }\n      };\n    }\n  };\n};\n\n/**\n * Optimizes the visibility of the floating element by shifting it in order to\n * keep it in view when it will overflow the clipping boundary.\n * @see https://floating-ui.com/docs/shift\n */\nconst shift = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'shift',\n    options,\n    async fn(state) {\n      const {\n        x,\n        y,\n        placement\n      } = state;\n      const {\n        mainAxis: checkMainAxis = true,\n        crossAxis: checkCrossAxis = false,\n        limiter = {\n          fn: _ref => {\n            let {\n              x,\n              y\n            } = _ref;\n            return {\n              x,\n              y\n            };\n          }\n        },\n        ...detectOverflowOptions\n      } = evaluate(options, state);\n      const coords = {\n        x,\n        y\n      };\n      const overflow = await detectOverflow(state, detectOverflowOptions);\n      const crossAxis = getSideAxis(getSide(placement));\n      const mainAxis = getOppositeAxis(crossAxis);\n      let mainAxisCoord = coords[mainAxis];\n      let crossAxisCoord = coords[crossAxis];\n      if (checkMainAxis) {\n        const minSide = mainAxis === 'y' ? 'top' : 'left';\n        const maxSide = mainAxis === 'y' ? 'bottom' : 'right';\n        const min = mainAxisCoord + overflow[minSide];\n        const max = mainAxisCoord - overflow[maxSide];\n        mainAxisCoord = clamp(min, mainAxisCoord, max);\n      }\n      if (checkCrossAxis) {\n        const minSide = crossAxis === 'y' ? 'top' : 'left';\n        const maxSide = crossAxis === 'y' ? 'bottom' : 'right';\n        const min = crossAxisCoord + overflow[minSide];\n        const max = crossAxisCoord - overflow[maxSide];\n        crossAxisCoord = clamp(min, crossAxisCoord, max);\n      }\n      const limitedCoords = limiter.fn({\n        ...state,\n        [mainAxis]: mainAxisCoord,\n        [crossAxis]: crossAxisCoord\n      });\n      return {\n        ...limitedCoords,\n        data: {\n          x: limitedCoords.x - x,\n          y: limitedCoords.y - y,\n          enabled: {\n            [mainAxis]: checkMainAxis,\n            [crossAxis]: checkCrossAxis\n          }\n        }\n      };\n    }\n  };\n};\n/**\n * Built-in `limiter` that will stop `shift()` at a certain point.\n */\nconst limitShift = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    options,\n    fn(state) {\n      const {\n        x,\n        y,\n        placement,\n        rects,\n        middlewareData\n      } = state;\n      const {\n        offset = 0,\n        mainAxis: checkMainAxis = true,\n        crossAxis: checkCrossAxis = true\n      } = evaluate(options, state);\n      const coords = {\n        x,\n        y\n      };\n      const crossAxis = getSideAxis(placement);\n      const mainAxis = getOppositeAxis(crossAxis);\n      let mainAxisCoord = coords[mainAxis];\n      let crossAxisCoord = coords[crossAxis];\n      const rawOffset = evaluate(offset, state);\n      const computedOffset = typeof rawOffset === 'number' ? {\n        mainAxis: rawOffset,\n        crossAxis: 0\n      } : {\n        mainAxis: 0,\n        crossAxis: 0,\n        ...rawOffset\n      };\n      if (checkMainAxis) {\n        const len = mainAxis === 'y' ? 'height' : 'width';\n        const limitMin = rects.reference[mainAxis] - rects.floating[len] + computedOffset.mainAxis;\n        const limitMax = rects.reference[mainAxis] + rects.reference[len] - computedOffset.mainAxis;\n        if (mainAxisCoord < limitMin) {\n          mainAxisCoord = limitMin;\n        } else if (mainAxisCoord > limitMax) {\n          mainAxisCoord = limitMax;\n        }\n      }\n      if (checkCrossAxis) {\n        var _middlewareData$offse, _middlewareData$offse2;\n        const len = mainAxis === 'y' ? 'width' : 'height';\n        const isOriginSide = ['top', 'left'].includes(getSide(placement));\n        const limitMin = rects.reference[crossAxis] - rects.floating[len] + (isOriginSide ? ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse[crossAxis]) || 0 : 0) + (isOriginSide ? 0 : computedOffset.crossAxis);\n        const limitMax = rects.reference[crossAxis] + rects.reference[len] + (isOriginSide ? 0 : ((_middlewareData$offse2 = middlewareData.offset) == null ? void 0 : _middlewareData$offse2[crossAxis]) || 0) - (isOriginSide ? computedOffset.crossAxis : 0);\n        if (crossAxisCoord < limitMin) {\n          crossAxisCoord = limitMin;\n        } else if (crossAxisCoord > limitMax) {\n          crossAxisCoord = limitMax;\n        }\n      }\n      return {\n        [mainAxis]: mainAxisCoord,\n        [crossAxis]: crossAxisCoord\n      };\n    }\n  };\n};\n\n/**\n * Provides data that allows you to change the size of the floating element \n * for instance, prevent it from overflowing the clipping boundary or match the\n * width of the reference element.\n * @see https://floating-ui.com/docs/size\n */\nconst size = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'size',\n    options,\n    async fn(state) {\n      var _state$middlewareData, _state$middlewareData2;\n      const {\n        placement,\n        rects,\n        platform,\n        elements\n      } = state;\n      const {\n        apply = () => {},\n        ...detectOverflowOptions\n      } = evaluate(options, state);\n      const overflow = await detectOverflow(state, detectOverflowOptions);\n      const side = getSide(placement);\n      const alignment = getAlignment(placement);\n      const isYAxis = getSideAxis(placement) === 'y';\n      const {\n        width,\n        height\n      } = rects.floating;\n      let heightSide;\n      let widthSide;\n      if (side === 'top' || side === 'bottom') {\n        heightSide = side;\n        widthSide = alignment === ((await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating))) ? 'start' : 'end') ? 'left' : 'right';\n      } else {\n        widthSide = side;\n        heightSide = alignment === 'end' ? 'top' : 'bottom';\n      }\n      const maximumClippingHeight = height - overflow.top - overflow.bottom;\n      const maximumClippingWidth = width - overflow.left - overflow.right;\n      const overflowAvailableHeight = min(height - overflow[heightSide], maximumClippingHeight);\n      const overflowAvailableWidth = min(width - overflow[widthSide], maximumClippingWidth);\n      const noShift = !state.middlewareData.shift;\n      let availableHeight = overflowAvailableHeight;\n      let availableWidth = overflowAvailableWidth;\n      if ((_state$middlewareData = state.middlewareData.shift) != null && _state$middlewareData.enabled.x) {\n        availableWidth = maximumClippingWidth;\n      }\n      if ((_state$middlewareData2 = state.middlewareData.shift) != null && _state$middlewareData2.enabled.y) {\n        availableHeight = maximumClippingHeight;\n      }\n      if (noShift && !alignment) {\n        const xMin = max(overflow.left, 0);\n        const xMax = max(overflow.right, 0);\n        const yMin = max(overflow.top, 0);\n        const yMax = max(overflow.bottom, 0);\n        if (isYAxis) {\n          availableWidth = width - 2 * (xMin !== 0 || xMax !== 0 ? xMin + xMax : max(overflow.left, overflow.right));\n        } else {\n          availableHeight = height - 2 * (yMin !== 0 || yMax !== 0 ? yMin + yMax : max(overflow.top, overflow.bottom));\n        }\n      }\n      await apply({\n        ...state,\n        availableWidth,\n        availableHeight\n      });\n      const nextDimensions = await platform.getDimensions(elements.floating);\n      if (width !== nextDimensions.width || height !== nextDimensions.height) {\n        return {\n          reset: {\n            rects: true\n          }\n        };\n      }\n      return {};\n    }\n  };\n};\n\nexport { arrow, autoPlacement, computePosition, detectOverflow, flip, hide, inline, limitShift, offset, shift, size };\n","function hasWindow() {\n  return typeof window !== 'undefined';\n}\nfunction getNodeName(node) {\n  if (isNode(node)) {\n    return (node.nodeName || '').toLowerCase();\n  }\n  // Mocked nodes in testing environments may not be instances of Node. By\n  // returning `#document` an infinite loop won't occur.\n  // https://github.com/floating-ui/floating-ui/issues/2317\n  return '#document';\n}\nfunction getWindow(node) {\n  var _node$ownerDocument;\n  return (node == null || (_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;\n}\nfunction getDocumentElement(node) {\n  var _ref;\n  return (_ref = (isNode(node) ? node.ownerDocument : node.document) || window.document) == null ? void 0 : _ref.documentElement;\n}\nfunction isNode(value) {\n  if (!hasWindow()) {\n    return false;\n  }\n  return value instanceof Node || value instanceof getWindow(value).Node;\n}\nfunction isElement(value) {\n  if (!hasWindow()) {\n    return false;\n  }\n  return value instanceof Element || value instanceof getWindow(value).Element;\n}\nfunction isHTMLElement(value) {\n  if (!hasWindow()) {\n    return false;\n  }\n  return value instanceof HTMLElement || value instanceof getWindow(value).HTMLElement;\n}\nfunction isShadowRoot(value) {\n  if (!hasWindow() || typeof ShadowRoot === 'undefined') {\n    return false;\n  }\n  return value instanceof ShadowRoot || value instanceof getWindow(value).ShadowRoot;\n}\nfunction isOverflowElement(element) {\n  const {\n    overflow,\n    overflowX,\n    overflowY,\n    display\n  } = getComputedStyle(element);\n  return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && !['inline', 'contents'].includes(display);\n}\nfunction isTableElement(element) {\n  return ['table', 'td', 'th'].includes(getNodeName(element));\n}\nfunction isTopLayer(element) {\n  return [':popover-open', ':modal'].some(selector => {\n    try {\n      return element.matches(selector);\n    } catch (e) {\n      return false;\n    }\n  });\n}\nfunction isContainingBlock(elementOrCss) {\n  const webkit = isWebKit();\n  const css = isElement(elementOrCss) ? getComputedStyle(elementOrCss) : elementOrCss;\n\n  // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block\n  return css.transform !== 'none' || css.perspective !== 'none' || (css.containerType ? css.containerType !== 'normal' : false) || !webkit && (css.backdropFilter ? css.backdropFilter !== 'none' : false) || !webkit && (css.filter ? css.filter !== 'none' : false) || ['transform', 'perspective', 'filter'].some(value => (css.willChange || '').includes(value)) || ['paint', 'layout', 'strict', 'content'].some(value => (css.contain || '').includes(value));\n}\nfunction getContainingBlock(element) {\n  let currentNode = getParentNode(element);\n  while (isHTMLElement(currentNode) && !isLastTraversableNode(currentNode)) {\n    if (isContainingBlock(currentNode)) {\n      return currentNode;\n    } else if (isTopLayer(currentNode)) {\n      return null;\n    }\n    currentNode = getParentNode(currentNode);\n  }\n  return null;\n}\nfunction isWebKit() {\n  if (typeof CSS === 'undefined' || !CSS.supports) return false;\n  return CSS.supports('-webkit-backdrop-filter', 'none');\n}\nfunction isLastTraversableNode(node) {\n  return ['html', 'body', '#document'].includes(getNodeName(node));\n}\nfunction getComputedStyle(element) {\n  return getWindow(element).getComputedStyle(element);\n}\nfunction getNodeScroll(element) {\n  if (isElement(element)) {\n    return {\n      scrollLeft: element.scrollLeft,\n      scrollTop: element.scrollTop\n    };\n  }\n  return {\n    scrollLeft: element.scrollX,\n    scrollTop: element.scrollY\n  };\n}\nfunction getParentNode(node) {\n  if (getNodeName(node) === 'html') {\n    return node;\n  }\n  const result =\n  // Step into the shadow DOM of the parent of a slotted node.\n  node.assignedSlot ||\n  // DOM Element detected.\n  node.parentNode ||\n  // ShadowRoot detected.\n  isShadowRoot(node) && node.host ||\n  // Fallback.\n  getDocumentElement(node);\n  return isShadowRoot(result) ? result.host : result;\n}\nfunction getNearestOverflowAncestor(node) {\n  const parentNode = getParentNode(node);\n  if (isLastTraversableNode(parentNode)) {\n    return node.ownerDocument ? node.ownerDocument.body : node.body;\n  }\n  if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) {\n    return parentNode;\n  }\n  return getNearestOverflowAncestor(parentNode);\n}\nfunction getOverflowAncestors(node, list, traverseIframes) {\n  var _node$ownerDocument2;\n  if (list === void 0) {\n    list = [];\n  }\n  if (traverseIframes === void 0) {\n    traverseIframes = true;\n  }\n  const scrollableAncestor = getNearestOverflowAncestor(node);\n  const isBody = scrollableAncestor === ((_node$ownerDocument2 = node.ownerDocument) == null ? void 0 : _node$ownerDocument2.body);\n  const win = getWindow(scrollableAncestor);\n  if (isBody) {\n    const frameElement = getFrameElement(win);\n    return list.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : [], frameElement && traverseIframes ? getOverflowAncestors(frameElement) : []);\n  }\n  return list.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor, [], traverseIframes));\n}\nfunction getFrameElement(win) {\n  return win.parent && Object.getPrototypeOf(win.parent) ? win.frameElement : null;\n}\n\nexport { getComputedStyle, getContainingBlock, getDocumentElement, getFrameElement, getNearestOverflowAncestor, getNodeName, getNodeScroll, getOverflowAncestors, getParentNode, getWindow, isContainingBlock, isElement, isHTMLElement, isLastTraversableNode, isNode, isOverflowElement, isShadowRoot, isTableElement, isTopLayer, isWebKit };\n","import { rectToClientRect, detectOverflow as detectOverflow$1, offset as offset$1, autoPlacement as autoPlacement$1, shift as shift$1, flip as flip$1, size as size$1, hide as hide$1, arrow as arrow$1, inline as inline$1, limitShift as limitShift$1, computePosition as computePosition$1 } from '@floating-ui/core';\nimport { round, createCoords, max, min, floor } from '@floating-ui/utils';\nimport { getComputedStyle, isHTMLElement, isElement, getWindow, isWebKit, getFrameElement, getDocumentElement, isTopLayer, getNodeName, isOverflowElement, getNodeScroll, getOverflowAncestors, getParentNode, isLastTraversableNode, isContainingBlock, isTableElement, getContainingBlock } from '@floating-ui/utils/dom';\nexport { getOverflowAncestors } from '@floating-ui/utils/dom';\n\nfunction getCssDimensions(element) {\n  const css = getComputedStyle(element);\n  // In testing environments, the `width` and `height` properties are empty\n  // strings for SVG elements, returning NaN. Fallback to `0` in this case.\n  let width = parseFloat(css.width) || 0;\n  let height = parseFloat(css.height) || 0;\n  const hasOffset = isHTMLElement(element);\n  const offsetWidth = hasOffset ? element.offsetWidth : width;\n  const offsetHeight = hasOffset ? element.offsetHeight : height;\n  const shouldFallback = round(width) !== offsetWidth || round(height) !== offsetHeight;\n  if (shouldFallback) {\n    width = offsetWidth;\n    height = offsetHeight;\n  }\n  return {\n    width,\n    height,\n    $: shouldFallback\n  };\n}\n\nfunction unwrapElement(element) {\n  return !isElement(element) ? element.contextElement : element;\n}\n\nfunction getScale(element) {\n  const domElement = unwrapElement(element);\n  if (!isHTMLElement(domElement)) {\n    return createCoords(1);\n  }\n  const rect = domElement.getBoundingClientRect();\n  const {\n    width,\n    height,\n    $\n  } = getCssDimensions(domElement);\n  let x = ($ ? round(rect.width) : rect.width) / width;\n  let y = ($ ? round(rect.height) : rect.height) / height;\n\n  // 0, NaN, or Infinity should always fallback to 1.\n\n  if (!x || !Number.isFinite(x)) {\n    x = 1;\n  }\n  if (!y || !Number.isFinite(y)) {\n    y = 1;\n  }\n  return {\n    x,\n    y\n  };\n}\n\nconst noOffsets = /*#__PURE__*/createCoords(0);\nfunction getVisualOffsets(element) {\n  const win = getWindow(element);\n  if (!isWebKit() || !win.visualViewport) {\n    return noOffsets;\n  }\n  return {\n    x: win.visualViewport.offsetLeft,\n    y: win.visualViewport.offsetTop\n  };\n}\nfunction shouldAddVisualOffsets(element, isFixed, floatingOffsetParent) {\n  if (isFixed === void 0) {\n    isFixed = false;\n  }\n  if (!floatingOffsetParent || isFixed && floatingOffsetParent !== getWindow(element)) {\n    return false;\n  }\n  return isFixed;\n}\n\nfunction getBoundingClientRect(element, includeScale, isFixedStrategy, offsetParent) {\n  if (includeScale === void 0) {\n    includeScale = false;\n  }\n  if (isFixedStrategy === void 0) {\n    isFixedStrategy = false;\n  }\n  const clientRect = element.getBoundingClientRect();\n  const domElement = unwrapElement(element);\n  let scale = createCoords(1);\n  if (includeScale) {\n    if (offsetParent) {\n      if (isElement(offsetParent)) {\n        scale = getScale(offsetParent);\n      }\n    } else {\n      scale = getScale(element);\n    }\n  }\n  const visualOffsets = shouldAddVisualOffsets(domElement, isFixedStrategy, offsetParent) ? getVisualOffsets(domElement) : createCoords(0);\n  let x = (clientRect.left + visualOffsets.x) / scale.x;\n  let y = (clientRect.top + visualOffsets.y) / scale.y;\n  let width = clientRect.width / scale.x;\n  let height = clientRect.height / scale.y;\n  if (domElement) {\n    const win = getWindow(domElement);\n    const offsetWin = offsetParent && isElement(offsetParent) ? getWindow(offsetParent) : offsetParent;\n    let currentWin = win;\n    let currentIFrame = getFrameElement(currentWin);\n    while (currentIFrame && offsetParent && offsetWin !== currentWin) {\n      const iframeScale = getScale(currentIFrame);\n      const iframeRect = currentIFrame.getBoundingClientRect();\n      const css = getComputedStyle(currentIFrame);\n      const left = iframeRect.left + (currentIFrame.clientLeft + parseFloat(css.paddingLeft)) * iframeScale.x;\n      const top = iframeRect.top + (currentIFrame.clientTop + parseFloat(css.paddingTop)) * iframeScale.y;\n      x *= iframeScale.x;\n      y *= iframeScale.y;\n      width *= iframeScale.x;\n      height *= iframeScale.y;\n      x += left;\n      y += top;\n      currentWin = getWindow(currentIFrame);\n      currentIFrame = getFrameElement(currentWin);\n    }\n  }\n  return rectToClientRect({\n    width,\n    height,\n    x,\n    y\n  });\n}\n\nfunction convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {\n  let {\n    elements,\n    rect,\n    offsetParent,\n    strategy\n  } = _ref;\n  const isFixed = strategy === 'fixed';\n  const documentElement = getDocumentElement(offsetParent);\n  const topLayer = elements ? isTopLayer(elements.floating) : false;\n  if (offsetParent === documentElement || topLayer && isFixed) {\n    return rect;\n  }\n  let scroll = {\n    scrollLeft: 0,\n    scrollTop: 0\n  };\n  let scale = createCoords(1);\n  const offsets = createCoords(0);\n  const isOffsetParentAnElement = isHTMLElement(offsetParent);\n  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {\n    if (getNodeName(offsetParent) !== 'body' || isOverflowElement(documentElement)) {\n      scroll = getNodeScroll(offsetParent);\n    }\n    if (isHTMLElement(offsetParent)) {\n      const offsetRect = getBoundingClientRect(offsetParent);\n      scale = getScale(offsetParent);\n      offsets.x = offsetRect.x + offsetParent.clientLeft;\n      offsets.y = offsetRect.y + offsetParent.clientTop;\n    }\n  }\n  return {\n    width: rect.width * scale.x,\n    height: rect.height * scale.y,\n    x: rect.x * scale.x - scroll.scrollLeft * scale.x + offsets.x,\n    y: rect.y * scale.y - scroll.scrollTop * scale.y + offsets.y\n  };\n}\n\nfunction getClientRects(element) {\n  return Array.from(element.getClientRects());\n}\n\n// If <html> has a CSS width greater than the viewport, then this will be\n// incorrect for RTL.\nfunction getWindowScrollBarX(element, rect) {\n  const leftScroll = getNodeScroll(element).scrollLeft;\n  if (!rect) {\n    return getBoundingClientRect(getDocumentElement(element)).left + leftScroll;\n  }\n  return rect.left + leftScroll;\n}\n\n// Gets the entire size of the scrollable document area, even extending outside\n// of the `<html>` and `<body>` rect bounds if horizontally scrollable.\nfunction getDocumentRect(element) {\n  const html = getDocumentElement(element);\n  const scroll = getNodeScroll(element);\n  const body = element.ownerDocument.body;\n  const width = max(html.scrollWidth, html.clientWidth, body.scrollWidth, body.clientWidth);\n  const height = max(html.scrollHeight, html.clientHeight, body.scrollHeight, body.clientHeight);\n  let x = -scroll.scrollLeft + getWindowScrollBarX(element);\n  const y = -scroll.scrollTop;\n  if (getComputedStyle(body).direction === 'rtl') {\n    x += max(html.clientWidth, body.clientWidth) - width;\n  }\n  return {\n    width,\n    height,\n    x,\n    y\n  };\n}\n\nfunction getViewportRect(element, strategy) {\n  const win = getWindow(element);\n  const html = getDocumentElement(element);\n  const visualViewport = win.visualViewport;\n  let width = html.clientWidth;\n  let height = html.clientHeight;\n  let x = 0;\n  let y = 0;\n  if (visualViewport) {\n    width = visualViewport.width;\n    height = visualViewport.height;\n    const visualViewportBased = isWebKit();\n    if (!visualViewportBased || visualViewportBased && strategy === 'fixed') {\n      x = visualViewport.offsetLeft;\n      y = visualViewport.offsetTop;\n    }\n  }\n  return {\n    width,\n    height,\n    x,\n    y\n  };\n}\n\n// Returns the inner client rect, subtracting scrollbars if present.\nfunction getInnerBoundingClientRect(element, strategy) {\n  const clientRect = getBoundingClientRect(element, true, strategy === 'fixed');\n  const top = clientRect.top + element.clientTop;\n  const left = clientRect.left + element.clientLeft;\n  const scale = isHTMLElement(element) ? getScale(element) : createCoords(1);\n  const width = element.clientWidth * scale.x;\n  const height = element.clientHeight * scale.y;\n  const x = left * scale.x;\n  const y = top * scale.y;\n  return {\n    width,\n    height,\n    x,\n    y\n  };\n}\nfunction getClientRectFromClippingAncestor(element, clippingAncestor, strategy) {\n  let rect;\n  if (clippingAncestor === 'viewport') {\n    rect = getViewportRect(element, strategy);\n  } else if (clippingAncestor === 'document') {\n    rect = getDocumentRect(getDocumentElement(element));\n  } else if (isElement(clippingAncestor)) {\n    rect = getInnerBoundingClientRect(clippingAncestor, strategy);\n  } else {\n    const visualOffsets = getVisualOffsets(element);\n    rect = {\n      ...clippingAncestor,\n      x: clippingAncestor.x - visualOffsets.x,\n      y: clippingAncestor.y - visualOffsets.y\n    };\n  }\n  return rectToClientRect(rect);\n}\nfunction hasFixedPositionAncestor(element, stopNode) {\n  const parentNode = getParentNode(element);\n  if (parentNode === stopNode || !isElement(parentNode) || isLastTraversableNode(parentNode)) {\n    return false;\n  }\n  return getComputedStyle(parentNode).position === 'fixed' || hasFixedPositionAncestor(parentNode, stopNode);\n}\n\n// A \"clipping ancestor\" is an `overflow` element with the characteristic of\n// clipping (or hiding) child elements. This returns all clipping ancestors\n// of the given element up the tree.\nfunction getClippingElementAncestors(element, cache) {\n  const cachedResult = cache.get(element);\n  if (cachedResult) {\n    return cachedResult;\n  }\n  let result = getOverflowAncestors(element, [], false).filter(el => isElement(el) && getNodeName(el) !== 'body');\n  let currentContainingBlockComputedStyle = null;\n  const elementIsFixed = getComputedStyle(element).position === 'fixed';\n  let currentNode = elementIsFixed ? getParentNode(element) : element;\n\n  // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block\n  while (isElement(currentNode) && !isLastTraversableNode(currentNode)) {\n    const computedStyle = getComputedStyle(currentNode);\n    const currentNodeIsContaining = isContainingBlock(currentNode);\n    if (!currentNodeIsContaining && computedStyle.position === 'fixed') {\n      currentContainingBlockComputedStyle = null;\n    }\n    const shouldDropCurrentNode = elementIsFixed ? !currentNodeIsContaining && !currentContainingBlockComputedStyle : !currentNodeIsContaining && computedStyle.position === 'static' && !!currentContainingBlockComputedStyle && ['absolute', 'fixed'].includes(currentContainingBlockComputedStyle.position) || isOverflowElement(currentNode) && !currentNodeIsContaining && hasFixedPositionAncestor(element, currentNode);\n    if (shouldDropCurrentNode) {\n      // Drop non-containing blocks.\n      result = result.filter(ancestor => ancestor !== currentNode);\n    } else {\n      // Record last containing block for next iteration.\n      currentContainingBlockComputedStyle = computedStyle;\n    }\n    currentNode = getParentNode(currentNode);\n  }\n  cache.set(element, result);\n  return result;\n}\n\n// Gets the maximum area that the element is visible in due to any number of\n// clipping ancestors.\nfunction getClippingRect(_ref) {\n  let {\n    element,\n    boundary,\n    rootBoundary,\n    strategy\n  } = _ref;\n  const elementClippingAncestors = boundary === 'clippingAncestors' ? isTopLayer(element) ? [] : getClippingElementAncestors(element, this._c) : [].concat(boundary);\n  const clippingAncestors = [...elementClippingAncestors, rootBoundary];\n  const firstClippingAncestor = clippingAncestors[0];\n  const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {\n    const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);\n    accRect.top = max(rect.top, accRect.top);\n    accRect.right = min(rect.right, accRect.right);\n    accRect.bottom = min(rect.bottom, accRect.bottom);\n    accRect.left = max(rect.left, accRect.left);\n    return accRect;\n  }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));\n  return {\n    width: clippingRect.right - clippingRect.left,\n    height: clippingRect.bottom - clippingRect.top,\n    x: clippingRect.left,\n    y: clippingRect.top\n  };\n}\n\nfunction getDimensions(element) {\n  const {\n    width,\n    height\n  } = getCssDimensions(element);\n  return {\n    width,\n    height\n  };\n}\n\nfunction getRectRelativeToOffsetParent(element, offsetParent, strategy) {\n  const isOffsetParentAnElement = isHTMLElement(offsetParent);\n  const documentElement = getDocumentElement(offsetParent);\n  const isFixed = strategy === 'fixed';\n  const rect = getBoundingClientRect(element, true, isFixed, offsetParent);\n  let scroll = {\n    scrollLeft: 0,\n    scrollTop: 0\n  };\n  const offsets = createCoords(0);\n  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {\n    if (getNodeName(offsetParent) !== 'body' || isOverflowElement(documentElement)) {\n      scroll = getNodeScroll(offsetParent);\n    }\n    if (isOffsetParentAnElement) {\n      const offsetRect = getBoundingClientRect(offsetParent, true, isFixed, offsetParent);\n      offsets.x = offsetRect.x + offsetParent.clientLeft;\n      offsets.y = offsetRect.y + offsetParent.clientTop;\n    } else if (documentElement) {\n      // If the <body> scrollbar appears on the left (e.g. RTL systems). Use\n      // Firefox with layout.scrollbar.side = 3 in about:config to test this.\n      offsets.x = getWindowScrollBarX(documentElement);\n    }\n  }\n  let htmlX = 0;\n  let htmlY = 0;\n  if (documentElement && !isOffsetParentAnElement && !isFixed) {\n    const htmlRect = documentElement.getBoundingClientRect();\n    htmlY = htmlRect.top + scroll.scrollTop;\n    htmlX = htmlRect.left + scroll.scrollLeft -\n    // RTL <body> scrollbar.\n    getWindowScrollBarX(documentElement, htmlRect);\n  }\n  const x = rect.left + scroll.scrollLeft - offsets.x - htmlX;\n  const y = rect.top + scroll.scrollTop - offsets.y - htmlY;\n  return {\n    x,\n    y,\n    width: rect.width,\n    height: rect.height\n  };\n}\n\nfunction isStaticPositioned(element) {\n  return getComputedStyle(element).position === 'static';\n}\n\nfunction getTrueOffsetParent(element, polyfill) {\n  if (!isHTMLElement(element) || getComputedStyle(element).position === 'fixed') {\n    return null;\n  }\n  if (polyfill) {\n    return polyfill(element);\n  }\n  let rawOffsetParent = element.offsetParent;\n\n  // Firefox returns the <html> element as the offsetParent if it's non-static,\n  // while Chrome and Safari return the <body> element. The <body> element must\n  // be used to perform the correct calculations even if the <html> element is\n  // non-static.\n  if (getDocumentElement(element) === rawOffsetParent) {\n    rawOffsetParent = rawOffsetParent.ownerDocument.body;\n  }\n  return rawOffsetParent;\n}\n\n// Gets the closest ancestor positioned element. Handles some edge cases,\n// such as table ancestors and cross browser bugs.\nfunction getOffsetParent(element, polyfill) {\n  const win = getWindow(element);\n  if (isTopLayer(element)) {\n    return win;\n  }\n  if (!isHTMLElement(element)) {\n    let svgOffsetParent = getParentNode(element);\n    while (svgOffsetParent && !isLastTraversableNode(svgOffsetParent)) {\n      if (isElement(svgOffsetParent) && !isStaticPositioned(svgOffsetParent)) {\n        return svgOffsetParent;\n      }\n      svgOffsetParent = getParentNode(svgOffsetParent);\n    }\n    return win;\n  }\n  let offsetParent = getTrueOffsetParent(element, polyfill);\n  while (offsetParent && isTableElement(offsetParent) && isStaticPositioned(offsetParent)) {\n    offsetParent = getTrueOffsetParent(offsetParent, polyfill);\n  }\n  if (offsetParent && isLastTraversableNode(offsetParent) && isStaticPositioned(offsetParent) && !isContainingBlock(offsetParent)) {\n    return win;\n  }\n  return offsetParent || getContainingBlock(element) || win;\n}\n\nconst getElementRects = async function (data) {\n  const getOffsetParentFn = this.getOffsetParent || getOffsetParent;\n  const getDimensionsFn = this.getDimensions;\n  const floatingDimensions = await getDimensionsFn(data.floating);\n  return {\n    reference: getRectRelativeToOffsetParent(data.reference, await getOffsetParentFn(data.floating), data.strategy),\n    floating: {\n      x: 0,\n      y: 0,\n      width: floatingDimensions.width,\n      height: floatingDimensions.height\n    }\n  };\n};\n\nfunction isRTL(element) {\n  return getComputedStyle(element).direction === 'rtl';\n}\n\nconst platform = {\n  convertOffsetParentRelativeRectToViewportRelativeRect,\n  getDocumentElement,\n  getClippingRect,\n  getOffsetParent,\n  getElementRects,\n  getClientRects,\n  getDimensions,\n  getScale,\n  isElement,\n  isRTL\n};\n\n// https://samthor.au/2021/observing-dom/\nfunction observeMove(element, onMove) {\n  let io = null;\n  let timeoutId;\n  const root = getDocumentElement(element);\n  function cleanup() {\n    var _io;\n    clearTimeout(timeoutId);\n    (_io = io) == null || _io.disconnect();\n    io = null;\n  }\n  function refresh(skip, threshold) {\n    if (skip === void 0) {\n      skip = false;\n    }\n    if (threshold === void 0) {\n      threshold = 1;\n    }\n    cleanup();\n    const {\n      left,\n      top,\n      width,\n      height\n    } = element.getBoundingClientRect();\n    if (!skip) {\n      onMove();\n    }\n    if (!width || !height) {\n      return;\n    }\n    const insetTop = floor(top);\n    const insetRight = floor(root.clientWidth - (left + width));\n    const insetBottom = floor(root.clientHeight - (top + height));\n    const insetLeft = floor(left);\n    const rootMargin = -insetTop + \"px \" + -insetRight + \"px \" + -insetBottom + \"px \" + -insetLeft + \"px\";\n    const options = {\n      rootMargin,\n      threshold: max(0, min(1, threshold)) || 1\n    };\n    let isFirstUpdate = true;\n    function handleObserve(entries) {\n      const ratio = entries[0].intersectionRatio;\n      if (ratio !== threshold) {\n        if (!isFirstUpdate) {\n          return refresh();\n        }\n        if (!ratio) {\n          // If the reference is clipped, the ratio is 0. Throttle the refresh\n          // to prevent an infinite loop of updates.\n          timeoutId = setTimeout(() => {\n            refresh(false, 1e-7);\n          }, 1000);\n        } else {\n          refresh(false, ratio);\n        }\n      }\n      isFirstUpdate = false;\n    }\n\n    // Older browsers don't support a `document` as the root and will throw an\n    // error.\n    try {\n      io = new IntersectionObserver(handleObserve, {\n        ...options,\n        // Handle <iframe>s\n        root: root.ownerDocument\n      });\n    } catch (e) {\n      io = new IntersectionObserver(handleObserve, options);\n    }\n    io.observe(element);\n  }\n  refresh(true);\n  return cleanup;\n}\n\n/**\n * Automatically updates the position of the floating element when necessary.\n * Should only be called when the floating element is mounted on the DOM or\n * visible on the screen.\n * @returns cleanup function that should be invoked when the floating element is\n * removed from the DOM or hidden from the screen.\n * @see https://floating-ui.com/docs/autoUpdate\n */\nfunction autoUpdate(reference, floating, update, options) {\n  if (options === void 0) {\n    options = {};\n  }\n  const {\n    ancestorScroll = true,\n    ancestorResize = true,\n    elementResize = typeof ResizeObserver === 'function',\n    layoutShift = typeof IntersectionObserver === 'function',\n    animationFrame = false\n  } = options;\n  const referenceEl = unwrapElement(reference);\n  const ancestors = ancestorScroll || ancestorResize ? [...(referenceEl ? getOverflowAncestors(referenceEl) : []), ...getOverflowAncestors(floating)] : [];\n  ancestors.forEach(ancestor => {\n    ancestorScroll && ancestor.addEventListener('scroll', update, {\n      passive: true\n    });\n    ancestorResize && ancestor.addEventListener('resize', update);\n  });\n  const cleanupIo = referenceEl && layoutShift ? observeMove(referenceEl, update) : null;\n  let reobserveFrame = -1;\n  let resizeObserver = null;\n  if (elementResize) {\n    resizeObserver = new ResizeObserver(_ref => {\n      let [firstEntry] = _ref;\n      if (firstEntry && firstEntry.target === referenceEl && resizeObserver) {\n        // Prevent update loops when using the `size` middleware.\n        // https://github.com/floating-ui/floating-ui/issues/1740\n        resizeObserver.unobserve(floating);\n        cancelAnimationFrame(reobserveFrame);\n        reobserveFrame = requestAnimationFrame(() => {\n          var _resizeObserver;\n          (_resizeObserver = resizeObserver) == null || _resizeObserver.observe(floating);\n        });\n      }\n      update();\n    });\n    if (referenceEl && !animationFrame) {\n      resizeObserver.observe(referenceEl);\n    }\n    resizeObserver.observe(floating);\n  }\n  let frameId;\n  let prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;\n  if (animationFrame) {\n    frameLoop();\n  }\n  function frameLoop() {\n    const nextRefRect = getBoundingClientRect(reference);\n    if (prevRefRect && (nextRefRect.x !== prevRefRect.x || nextRefRect.y !== prevRefRect.y || nextRefRect.width !== prevRefRect.width || nextRefRect.height !== prevRefRect.height)) {\n      update();\n    }\n    prevRefRect = nextRefRect;\n    frameId = requestAnimationFrame(frameLoop);\n  }\n  update();\n  return () => {\n    var _resizeObserver2;\n    ancestors.forEach(ancestor => {\n      ancestorScroll && ancestor.removeEventListener('scroll', update);\n      ancestorResize && ancestor.removeEventListener('resize', update);\n    });\n    cleanupIo == null || cleanupIo();\n    (_resizeObserver2 = resizeObserver) == null || _resizeObserver2.disconnect();\n    resizeObserver = null;\n    if (animationFrame) {\n      cancelAnimationFrame(frameId);\n    }\n  };\n}\n\n/**\n * Resolves with an object of overflow side offsets that determine how much the\n * element is overflowing a given clipping boundary on each side.\n * - positive = overflowing the boundary by that number of pixels\n * - negative = how many pixels left before it will overflow\n * - 0 = lies flush with the boundary\n * @see https://floating-ui.com/docs/detectOverflow\n */\nconst detectOverflow = detectOverflow$1;\n\n/**\n * Modifies the placement by translating the floating element along the\n * specified axes.\n * A number (shorthand for `mainAxis` or distance), or an axes configuration\n * object may be passed.\n * @see https://floating-ui.com/docs/offset\n */\nconst offset = offset$1;\n\n/**\n * Optimizes the visibility of the floating element by choosing the placement\n * that has the most space available automatically, without needing to specify a\n * preferred placement. Alternative to `flip`.\n * @see https://floating-ui.com/docs/autoPlacement\n */\nconst autoPlacement = autoPlacement$1;\n\n/**\n * Optimizes the visibility of the floating element by shifting it in order to\n * keep it in view when it will overflow the clipping boundary.\n * @see https://floating-ui.com/docs/shift\n */\nconst shift = shift$1;\n\n/**\n * Optimizes the visibility of the floating element by flipping the `placement`\n * in order to keep it in view when the preferred placement(s) will overflow the\n * clipping boundary. Alternative to `autoPlacement`.\n * @see https://floating-ui.com/docs/flip\n */\nconst flip = flip$1;\n\n/**\n * Provides data that allows you to change the size of the floating element \n * for instance, prevent it from overflowing the clipping boundary or match the\n * width of the reference element.\n * @see https://floating-ui.com/docs/size\n */\nconst size = size$1;\n\n/**\n * Provides data to hide the floating element in applicable situations, such as\n * when it is not in the same clipping context as the reference element.\n * @see https://floating-ui.com/docs/hide\n */\nconst hide = hide$1;\n\n/**\n * Provides data to position an inner element of the floating element so that it\n * appears centered to the reference element.\n * @see https://floating-ui.com/docs/arrow\n */\nconst arrow = arrow$1;\n\n/**\n * Provides improved positioning for inline reference elements that can span\n * over multiple lines, such as hyperlinks or range selections.\n * @see https://floating-ui.com/docs/inline\n */\nconst inline = inline$1;\n\n/**\n * Built-in `limiter` that will stop `shift()` at a certain point.\n */\nconst limitShift = limitShift$1;\n\n/**\n * Computes the `x` and `y` coordinates that will place the floating element\n * next to a given reference element.\n */\nconst computePosition = (reference, floating, options) => {\n  // This caches the expensive `getClippingElementAncestors` function so that\n  // multiple lifecycle resets re-use the same result. It only lives for a\n  // single call. If other functions become expensive, we can add them as well.\n  const cache = new Map();\n  const mergedOptions = {\n    platform,\n    ...options\n  };\n  const platformWithCache = {\n    ...mergedOptions.platform,\n    _c: cache\n  };\n  return computePosition$1(reference, floating, {\n    ...mergedOptions,\n    platform: platformWithCache\n  });\n};\n\nexport { arrow, autoPlacement, autoUpdate, computePosition, detectOverflow, flip, hide, inline, limitShift, offset, platform, shift, size };\n","// Modified from Grail UI v0.9.6 (2023-06-10)\n// Source: https://github.com/grail-ui/grail-ui\n// https://github.com/grail-ui/grail-ui/tree/master/packages/grail-ui/src/floating/placement.ts\nimport { flip, offset, arrow, shift, size, computePosition, autoUpdate, } from '@floating-ui/dom';\nimport { isHTMLElement, noop } from '../../helpers/index.js';\nconst defaultConfig = {\n    strategy: 'absolute',\n    placement: 'top',\n    gutter: 5,\n    flip: true,\n    sameWidth: false,\n    overflowPadding: 8,\n};\nconst ARROW_TRANSFORM = {\n    bottom: 'rotate(45deg)',\n    left: 'rotate(135deg)',\n    top: 'rotate(225deg)',\n    right: 'rotate(315deg)',\n};\nconst SIDE_OPTIONS = ['top', 'right', 'bottom', 'left'];\nconst ALIGN_OPTIONS = ['start', 'center', 'end'];\nexport function useFloating(reference, floating, opts = {}) {\n    if (!floating || !reference || opts === null)\n        return {\n            destroy: noop,\n        };\n    const options = { ...defaultConfig, ...opts };\n    const arrowEl = floating.querySelector('[data-arrow=true]');\n    const middleware = [];\n    if (options.flip) {\n        middleware.push(flip({\n            boundary: options.boundary,\n            padding: options.overflowPadding,\n        }));\n    }\n    const arrowOffset = isHTMLElement(arrowEl) ? arrowEl.offsetHeight / 2 : 0;\n    if (options.gutter || options.offset) {\n        const data = options.gutter ? { mainAxis: options.gutter } : options.offset;\n        if (data?.mainAxis != null) {\n            data.mainAxis += arrowOffset;\n        }\n        middleware.push(offset(data));\n    }\n    middleware.push(shift({\n        boundary: options.boundary,\n        crossAxis: options.overlap,\n        padding: options.overflowPadding,\n    }));\n    if (arrowEl) {\n        middleware.push(arrow({ element: arrowEl, padding: 8 }));\n    }\n    middleware.push(size({\n        padding: options.overflowPadding,\n        apply({ rects, availableHeight, availableWidth }) {\n            if (options.sameWidth) {\n                Object.assign(floating.style, {\n                    width: `${Math.round(rects.reference.width)}px`,\n                    minWidth: 'unset',\n                });\n            }\n            if (options.fitViewport) {\n                Object.assign(floating.style, {\n                    maxWidth: `${availableWidth}px`,\n                    maxHeight: `${availableHeight}px`,\n                });\n            }\n        },\n    }));\n    function compute() {\n        if (!reference || !floating)\n            return;\n        // if the reference is no longer in the document (e.g. it was removed), ignore it\n        if (isHTMLElement(reference) && !reference.ownerDocument.documentElement.contains(reference))\n            return;\n        const { placement, strategy } = options;\n        computePosition(reference, floating, {\n            placement,\n            middleware,\n            strategy,\n        }).then((data) => {\n            const x = Math.round(data.x);\n            const y = Math.round(data.y);\n            // get the chosen side and align from the placement to apply as attributes\n            // to the floating element and arrow\n            const [side, align] = getSideAndAlignFromPlacement(data.placement);\n            floating.setAttribute('data-side', side);\n            floating.setAttribute('data-align', align);\n            Object.assign(floating.style, {\n                position: options.strategy,\n                top: `${y}px`,\n                left: `${x}px`,\n            });\n            if (isHTMLElement(arrowEl) && data.middlewareData.arrow) {\n                const { x, y } = data.middlewareData.arrow;\n                const dir = data.placement.split('-')[0];\n                arrowEl.setAttribute('data-side', dir);\n                Object.assign(arrowEl.style, {\n                    position: 'absolute',\n                    left: x != null ? `${x}px` : '',\n                    top: y != null ? `${y}px` : '',\n                    [dir]: `calc(100% - ${arrowOffset}px)`,\n                    transform: ARROW_TRANSFORM[dir],\n                    backgroundColor: 'inherit',\n                    zIndex: 'inherit',\n                });\n            }\n            return data;\n        });\n    }\n    // Apply `position` to floating element prior to the computePosition() call.\n    Object.assign(floating.style, {\n        position: options.strategy,\n    });\n    return {\n        destroy: autoUpdate(reference, floating, compute),\n    };\n}\nfunction getSideAndAlignFromPlacement(placement) {\n    const [side, align = 'center'] = placement.split('-');\n    return [side, align];\n}\n","/*!\n* tabbable 6.2.0\n* @license MIT, https://github.com/focus-trap/tabbable/blob/master/LICENSE\n*/\n// NOTE: separate `:not()` selectors has broader browser support than the newer\n//  `:not([inert], [inert] *)` (Feb 2023)\n// CAREFUL: JSDom does not support `:not([inert] *)` as a selector; using it causes\n//  the entire query to fail, resulting in no nodes found, which will break a lot\n//  of things... so we have to rely on JS to identify nodes inside an inert container\nvar candidateSelectors = ['input:not([inert])', 'select:not([inert])', 'textarea:not([inert])', 'a[href]:not([inert])', 'button:not([inert])', '[tabindex]:not(slot):not([inert])', 'audio[controls]:not([inert])', 'video[controls]:not([inert])', '[contenteditable]:not([contenteditable=\"false\"]):not([inert])', 'details>summary:first-of-type:not([inert])', 'details:not([inert])'];\nvar candidateSelector = /* #__PURE__ */candidateSelectors.join(',');\nvar NoElement = typeof Element === 'undefined';\nvar matches = NoElement ? function () {} : Element.prototype.matches || Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;\nvar getRootNode = !NoElement && Element.prototype.getRootNode ? function (element) {\n  var _element$getRootNode;\n  return element === null || element === void 0 ? void 0 : (_element$getRootNode = element.getRootNode) === null || _element$getRootNode === void 0 ? void 0 : _element$getRootNode.call(element);\n} : function (element) {\n  return element === null || element === void 0 ? void 0 : element.ownerDocument;\n};\n\n/**\n * Determines if a node is inert or in an inert ancestor.\n * @param {Element} [node]\n * @param {boolean} [lookUp] If true and `node` is not inert, looks up at ancestors to\n *  see if any of them are inert. If false, only `node` itself is considered.\n * @returns {boolean} True if inert itself or by way of being in an inert ancestor.\n *  False if `node` is falsy.\n */\nvar isInert = function isInert(node, lookUp) {\n  var _node$getAttribute;\n  if (lookUp === void 0) {\n    lookUp = true;\n  }\n  // CAREFUL: JSDom does not support inert at all, so we can't use the `HTMLElement.inert`\n  //  JS API property; we have to check the attribute, which can either be empty or 'true';\n  //  if it's `null` (not specified) or 'false', it's an active element\n  var inertAtt = node === null || node === void 0 ? void 0 : (_node$getAttribute = node.getAttribute) === null || _node$getAttribute === void 0 ? void 0 : _node$getAttribute.call(node, 'inert');\n  var inert = inertAtt === '' || inertAtt === 'true';\n\n  // NOTE: this could also be handled with `node.matches('[inert], :is([inert] *)')`\n  //  if it weren't for `matches()` not being a function on shadow roots; the following\n  //  code works for any kind of node\n  // CAREFUL: JSDom does not appear to support certain selectors like `:not([inert] *)`\n  //  so it likely would not support `:is([inert] *)` either...\n  var result = inert || lookUp && node && isInert(node.parentNode); // recursive\n\n  return result;\n};\n\n/**\n * Determines if a node's content is editable.\n * @param {Element} [node]\n * @returns True if it's content-editable; false if it's not or `node` is falsy.\n */\nvar isContentEditable = function isContentEditable(node) {\n  var _node$getAttribute2;\n  // CAREFUL: JSDom does not support the `HTMLElement.isContentEditable` API so we have\n  //  to use the attribute directly to check for this, which can either be empty or 'true';\n  //  if it's `null` (not specified) or 'false', it's a non-editable element\n  var attValue = node === null || node === void 0 ? void 0 : (_node$getAttribute2 = node.getAttribute) === null || _node$getAttribute2 === void 0 ? void 0 : _node$getAttribute2.call(node, 'contenteditable');\n  return attValue === '' || attValue === 'true';\n};\n\n/**\n * @param {Element} el container to check in\n * @param {boolean} includeContainer add container to check\n * @param {(node: Element) => boolean} filter filter candidates\n * @returns {Element[]}\n */\nvar getCandidates = function getCandidates(el, includeContainer, filter) {\n  // even if `includeContainer=false`, we still have to check it for inertness because\n  //  if it's inert, all its children are inert\n  if (isInert(el)) {\n    return [];\n  }\n  var candidates = Array.prototype.slice.apply(el.querySelectorAll(candidateSelector));\n  if (includeContainer && matches.call(el, candidateSelector)) {\n    candidates.unshift(el);\n  }\n  candidates = candidates.filter(filter);\n  return candidates;\n};\n\n/**\n * @callback GetShadowRoot\n * @param {Element} element to check for shadow root\n * @returns {ShadowRoot|boolean} ShadowRoot if available or boolean indicating if a shadowRoot is attached but not available.\n */\n\n/**\n * @callback ShadowRootFilter\n * @param {Element} shadowHostNode the element which contains shadow content\n * @returns {boolean} true if a shadow root could potentially contain valid candidates.\n */\n\n/**\n * @typedef {Object} CandidateScope\n * @property {Element} scopeParent contains inner candidates\n * @property {Element[]} candidates list of candidates found in the scope parent\n */\n\n/**\n * @typedef {Object} IterativeOptions\n * @property {GetShadowRoot|boolean} getShadowRoot true if shadow support is enabled; falsy if not;\n *  if a function, implies shadow support is enabled and either returns the shadow root of an element\n *  or a boolean stating if it has an undisclosed shadow root\n * @property {(node: Element) => boolean} filter filter candidates\n * @property {boolean} flatten if true then result will flatten any CandidateScope into the returned list\n * @property {ShadowRootFilter} shadowRootFilter filter shadow roots;\n */\n\n/**\n * @param {Element[]} elements list of element containers to match candidates from\n * @param {boolean} includeContainer add container list to check\n * @param {IterativeOptions} options\n * @returns {Array.<Element|CandidateScope>}\n */\nvar getCandidatesIteratively = function getCandidatesIteratively(elements, includeContainer, options) {\n  var candidates = [];\n  var elementsToCheck = Array.from(elements);\n  while (elementsToCheck.length) {\n    var element = elementsToCheck.shift();\n    if (isInert(element, false)) {\n      // no need to look up since we're drilling down\n      // anything inside this container will also be inert\n      continue;\n    }\n    if (element.tagName === 'SLOT') {\n      // add shadow dom slot scope (slot itself cannot be focusable)\n      var assigned = element.assignedElements();\n      var content = assigned.length ? assigned : element.children;\n      var nestedCandidates = getCandidatesIteratively(content, true, options);\n      if (options.flatten) {\n        candidates.push.apply(candidates, nestedCandidates);\n      } else {\n        candidates.push({\n          scopeParent: element,\n          candidates: nestedCandidates\n        });\n      }\n    } else {\n      // check candidate element\n      var validCandidate = matches.call(element, candidateSelector);\n      if (validCandidate && options.filter(element) && (includeContainer || !elements.includes(element))) {\n        candidates.push(element);\n      }\n\n      // iterate over shadow content if possible\n      var shadowRoot = element.shadowRoot ||\n      // check for an undisclosed shadow\n      typeof options.getShadowRoot === 'function' && options.getShadowRoot(element);\n\n      // no inert look up because we're already drilling down and checking for inertness\n      //  on the way down, so all containers to this root node should have already been\n      //  vetted as non-inert\n      var validShadowRoot = !isInert(shadowRoot, false) && (!options.shadowRootFilter || options.shadowRootFilter(element));\n      if (shadowRoot && validShadowRoot) {\n        // add shadow dom scope IIF a shadow root node was given; otherwise, an undisclosed\n        //  shadow exists, so look at light dom children as fallback BUT create a scope for any\n        //  child candidates found because they're likely slotted elements (elements that are\n        //  children of the web component element (which has the shadow), in the light dom, but\n        //  slotted somewhere _inside_ the undisclosed shadow) -- the scope is created below,\n        //  _after_ we return from this recursive call\n        var _nestedCandidates = getCandidatesIteratively(shadowRoot === true ? element.children : shadowRoot.children, true, options);\n        if (options.flatten) {\n          candidates.push.apply(candidates, _nestedCandidates);\n        } else {\n          candidates.push({\n            scopeParent: element,\n            candidates: _nestedCandidates\n          });\n        }\n      } else {\n        // there's not shadow so just dig into the element's (light dom) children\n        //  __without__ giving the element special scope treatment\n        elementsToCheck.unshift.apply(elementsToCheck, element.children);\n      }\n    }\n  }\n  return candidates;\n};\n\n/**\n * @private\n * Determines if the node has an explicitly specified `tabindex` attribute.\n * @param {HTMLElement} node\n * @returns {boolean} True if so; false if not.\n */\nvar hasTabIndex = function hasTabIndex(node) {\n  return !isNaN(parseInt(node.getAttribute('tabindex'), 10));\n};\n\n/**\n * Determine the tab index of a given node.\n * @param {HTMLElement} node\n * @returns {number} Tab order (negative, 0, or positive number).\n * @throws {Error} If `node` is falsy.\n */\nvar getTabIndex = function getTabIndex(node) {\n  if (!node) {\n    throw new Error('No node provided');\n  }\n  if (node.tabIndex < 0) {\n    // in Chrome, <details/>, <audio controls/> and <video controls/> elements get a default\n    // `tabIndex` of -1 when the 'tabindex' attribute isn't specified in the DOM,\n    // yet they are still part of the regular tab order; in FF, they get a default\n    // `tabIndex` of 0; since Chrome still puts those elements in the regular tab\n    // order, consider their tab index to be 0.\n    // Also browsers do not return `tabIndex` correctly for contentEditable nodes;\n    // so if they don't have a tabindex attribute specifically set, assume it's 0.\n    if ((/^(AUDIO|VIDEO|DETAILS)$/.test(node.tagName) || isContentEditable(node)) && !hasTabIndex(node)) {\n      return 0;\n    }\n  }\n  return node.tabIndex;\n};\n\n/**\n * Determine the tab index of a given node __for sort order purposes__.\n * @param {HTMLElement} node\n * @param {boolean} [isScope] True for a custom element with shadow root or slot that, by default,\n *  has tabIndex -1, but needs to be sorted by document order in order for its content to be\n *  inserted into the correct sort position.\n * @returns {number} Tab order (negative, 0, or positive number).\n */\nvar getSortOrderTabIndex = function getSortOrderTabIndex(node, isScope) {\n  var tabIndex = getTabIndex(node);\n  if (tabIndex < 0 && isScope && !hasTabIndex(node)) {\n    return 0;\n  }\n  return tabIndex;\n};\nvar sortOrderedTabbables = function sortOrderedTabbables(a, b) {\n  return a.tabIndex === b.tabIndex ? a.documentOrder - b.documentOrder : a.tabIndex - b.tabIndex;\n};\nvar isInput = function isInput(node) {\n  return node.tagName === 'INPUT';\n};\nvar isHiddenInput = function isHiddenInput(node) {\n  return isInput(node) && node.type === 'hidden';\n};\nvar isDetailsWithSummary = function isDetailsWithSummary(node) {\n  var r = node.tagName === 'DETAILS' && Array.prototype.slice.apply(node.children).some(function (child) {\n    return child.tagName === 'SUMMARY';\n  });\n  return r;\n};\nvar getCheckedRadio = function getCheckedRadio(nodes, form) {\n  for (var i = 0; i < nodes.length; i++) {\n    if (nodes[i].checked && nodes[i].form === form) {\n      return nodes[i];\n    }\n  }\n};\nvar isTabbableRadio = function isTabbableRadio(node) {\n  if (!node.name) {\n    return true;\n  }\n  var radioScope = node.form || getRootNode(node);\n  var queryRadios = function queryRadios(name) {\n    return radioScope.querySelectorAll('input[type=\"radio\"][name=\"' + name + '\"]');\n  };\n  var radioSet;\n  if (typeof window !== 'undefined' && typeof window.CSS !== 'undefined' && typeof window.CSS.escape === 'function') {\n    radioSet = queryRadios(window.CSS.escape(node.name));\n  } else {\n    try {\n      radioSet = queryRadios(node.name);\n    } catch (err) {\n      // eslint-disable-next-line no-console\n      console.error('Looks like you have a radio button with a name attribute containing invalid CSS selector characters and need the CSS.escape polyfill: %s', err.message);\n      return false;\n    }\n  }\n  var checked = getCheckedRadio(radioSet, node.form);\n  return !checked || checked === node;\n};\nvar isRadio = function isRadio(node) {\n  return isInput(node) && node.type === 'radio';\n};\nvar isNonTabbableRadio = function isNonTabbableRadio(node) {\n  return isRadio(node) && !isTabbableRadio(node);\n};\n\n// determines if a node is ultimately attached to the window's document\nvar isNodeAttached = function isNodeAttached(node) {\n  var _nodeRoot;\n  // The root node is the shadow root if the node is in a shadow DOM; some document otherwise\n  //  (but NOT _the_ document; see second 'If' comment below for more).\n  // If rootNode is shadow root, it'll have a host, which is the element to which the shadow\n  //  is attached, and the one we need to check if it's in the document or not (because the\n  //  shadow, and all nodes it contains, is never considered in the document since shadows\n  //  behave like self-contained DOMs; but if the shadow's HOST, which is part of the document,\n  //  is hidden, or is not in the document itself but is detached, it will affect the shadow's\n  //  visibility, including all the nodes it contains). The host could be any normal node,\n  //  or a custom element (i.e. web component). Either way, that's the one that is considered\n  //  part of the document, not the shadow root, nor any of its children (i.e. the node being\n  //  tested).\n  // To further complicate things, we have to look all the way up until we find a shadow HOST\n  //  that is attached (or find none) because the node might be in nested shadows...\n  // If rootNode is not a shadow root, it won't have a host, and so rootNode should be the\n  //  document (per the docs) and while it's a Document-type object, that document does not\n  //  appear to be the same as the node's `ownerDocument` for some reason, so it's safer\n  //  to ignore the rootNode at this point, and use `node.ownerDocument`. Otherwise,\n  //  using `rootNode.contains(node)` will _always_ be true we'll get false-positives when\n  //  node is actually detached.\n  // NOTE: If `nodeRootHost` or `node` happens to be the `document` itself (which is possible\n  //  if a tabbable/focusable node was quickly added to the DOM, focused, and then removed\n  //  from the DOM as in https://github.com/focus-trap/focus-trap-react/issues/905), then\n  //  `ownerDocument` will be `null`, hence the optional chaining on it.\n  var nodeRoot = node && getRootNode(node);\n  var nodeRootHost = (_nodeRoot = nodeRoot) === null || _nodeRoot === void 0 ? void 0 : _nodeRoot.host;\n\n  // in some cases, a detached node will return itself as the root instead of a document or\n  //  shadow root object, in which case, we shouldn't try to look further up the host chain\n  var attached = false;\n  if (nodeRoot && nodeRoot !== node) {\n    var _nodeRootHost, _nodeRootHost$ownerDo, _node$ownerDocument;\n    attached = !!((_nodeRootHost = nodeRootHost) !== null && _nodeRootHost !== void 0 && (_nodeRootHost$ownerDo = _nodeRootHost.ownerDocument) !== null && _nodeRootHost$ownerDo !== void 0 && _nodeRootHost$ownerDo.contains(nodeRootHost) || node !== null && node !== void 0 && (_node$ownerDocument = node.ownerDocument) !== null && _node$ownerDocument !== void 0 && _node$ownerDocument.contains(node));\n    while (!attached && nodeRootHost) {\n      var _nodeRoot2, _nodeRootHost2, _nodeRootHost2$ownerD;\n      // since it's not attached and we have a root host, the node MUST be in a nested shadow DOM,\n      //  which means we need to get the host's host and check if that parent host is contained\n      //  in (i.e. attached to) the document\n      nodeRoot = getRootNode(nodeRootHost);\n      nodeRootHost = (_nodeRoot2 = nodeRoot) === null || _nodeRoot2 === void 0 ? void 0 : _nodeRoot2.host;\n      attached = !!((_nodeRootHost2 = nodeRootHost) !== null && _nodeRootHost2 !== void 0 && (_nodeRootHost2$ownerD = _nodeRootHost2.ownerDocument) !== null && _nodeRootHost2$ownerD !== void 0 && _nodeRootHost2$ownerD.contains(nodeRootHost));\n    }\n  }\n  return attached;\n};\nvar isZeroArea = function isZeroArea(node) {\n  var _node$getBoundingClie = node.getBoundingClientRect(),\n    width = _node$getBoundingClie.width,\n    height = _node$getBoundingClie.height;\n  return width === 0 && height === 0;\n};\nvar isHidden = function isHidden(node, _ref) {\n  var displayCheck = _ref.displayCheck,\n    getShadowRoot = _ref.getShadowRoot;\n  // NOTE: visibility will be `undefined` if node is detached from the document\n  //  (see notes about this further down), which means we will consider it visible\n  //  (this is legacy behavior from a very long way back)\n  // NOTE: we check this regardless of `displayCheck=\"none\"` because this is a\n  //  _visibility_ check, not a _display_ check\n  if (getComputedStyle(node).visibility === 'hidden') {\n    return true;\n  }\n  var isDirectSummary = matches.call(node, 'details>summary:first-of-type');\n  var nodeUnderDetails = isDirectSummary ? node.parentElement : node;\n  if (matches.call(nodeUnderDetails, 'details:not([open]) *')) {\n    return true;\n  }\n  if (!displayCheck || displayCheck === 'full' || displayCheck === 'legacy-full') {\n    if (typeof getShadowRoot === 'function') {\n      // figure out if we should consider the node to be in an undisclosed shadow and use the\n      //  'non-zero-area' fallback\n      var originalNode = node;\n      while (node) {\n        var parentElement = node.parentElement;\n        var rootNode = getRootNode(node);\n        if (parentElement && !parentElement.shadowRoot && getShadowRoot(parentElement) === true // check if there's an undisclosed shadow\n        ) {\n          // node has an undisclosed shadow which means we can only treat it as a black box, so we\n          //  fall back to a non-zero-area test\n          return isZeroArea(node);\n        } else if (node.assignedSlot) {\n          // iterate up slot\n          node = node.assignedSlot;\n        } else if (!parentElement && rootNode !== node.ownerDocument) {\n          // cross shadow boundary\n          node = rootNode.host;\n        } else {\n          // iterate up normal dom\n          node = parentElement;\n        }\n      }\n      node = originalNode;\n    }\n    // else, `getShadowRoot` might be true, but all that does is enable shadow DOM support\n    //  (i.e. it does not also presume that all nodes might have undisclosed shadows); or\n    //  it might be a falsy value, which means shadow DOM support is disabled\n\n    // Since we didn't find it sitting in an undisclosed shadow (or shadows are disabled)\n    //  now we can just test to see if it would normally be visible or not, provided it's\n    //  attached to the main document.\n    // NOTE: We must consider case where node is inside a shadow DOM and given directly to\n    //  `isTabbable()` or `isFocusable()` -- regardless of `getShadowRoot` option setting.\n\n    if (isNodeAttached(node)) {\n      // this works wherever the node is: if there's at least one client rect, it's\n      //  somehow displayed; it also covers the CSS 'display: contents' case where the\n      //  node itself is hidden in place of its contents; and there's no need to search\n      //  up the hierarchy either\n      return !node.getClientRects().length;\n    }\n\n    // Else, the node isn't attached to the document, which means the `getClientRects()`\n    //  API will __always__ return zero rects (this can happen, for example, if React\n    //  is used to render nodes onto a detached tree, as confirmed in this thread:\n    //  https://github.com/facebook/react/issues/9117#issuecomment-284228870)\n    //\n    // It also means that even window.getComputedStyle(node).display will return `undefined`\n    //  because styles are only computed for nodes that are in the document.\n    //\n    // NOTE: THIS HAS BEEN THE CASE FOR YEARS. It is not new, nor is it caused by tabbable\n    //  somehow. Though it was never stated officially, anyone who has ever used tabbable\n    //  APIs on nodes in detached containers has actually implicitly used tabbable in what\n    //  was later (as of v5.2.0 on Apr 9, 2021) called `displayCheck=\"none\"` mode -- essentially\n    //  considering __everything__ to be visible because of the innability to determine styles.\n    //\n    // v6.0.0: As of this major release, the default 'full' option __no longer treats detached\n    //  nodes as visible with the 'none' fallback.__\n    if (displayCheck !== 'legacy-full') {\n      return true; // hidden\n    }\n    // else, fallback to 'none' mode and consider the node visible\n  } else if (displayCheck === 'non-zero-area') {\n    // NOTE: Even though this tests that the node's client rect is non-zero to determine\n    //  whether it's displayed, and that a detached node will __always__ have a zero-area\n    //  client rect, we don't special-case for whether the node is attached or not. In\n    //  this mode, we do want to consider nodes that have a zero area to be hidden at all\n    //  times, and that includes attached or not.\n    return isZeroArea(node);\n  }\n\n  // visible, as far as we can tell, or per current `displayCheck=none` mode, we assume\n  //  it's visible\n  return false;\n};\n\n// form fields (nested) inside a disabled fieldset are not focusable/tabbable\n//  unless they are in the _first_ <legend> element of the top-most disabled\n//  fieldset\nvar isDisabledFromFieldset = function isDisabledFromFieldset(node) {\n  if (/^(INPUT|BUTTON|SELECT|TEXTAREA)$/.test(node.tagName)) {\n    var parentNode = node.parentElement;\n    // check if `node` is contained in a disabled <fieldset>\n    while (parentNode) {\n      if (parentNode.tagName === 'FIELDSET' && parentNode.disabled) {\n        // look for the first <legend> among the children of the disabled <fieldset>\n        for (var i = 0; i < parentNode.children.length; i++) {\n          var child = parentNode.children.item(i);\n          // when the first <legend> (in document order) is found\n          if (child.tagName === 'LEGEND') {\n            // if its parent <fieldset> is not nested in another disabled <fieldset>,\n            // return whether `node` is a descendant of its first <legend>\n            return matches.call(parentNode, 'fieldset[disabled] *') ? true : !child.contains(node);\n          }\n        }\n        // the disabled <fieldset> containing `node` has no <legend>\n        return true;\n      }\n      parentNode = parentNode.parentElement;\n    }\n  }\n\n  // else, node's tabbable/focusable state should not be affected by a fieldset's\n  //  enabled/disabled state\n  return false;\n};\nvar isNodeMatchingSelectorFocusable = function isNodeMatchingSelectorFocusable(options, node) {\n  if (node.disabled ||\n  // we must do an inert look up to filter out any elements inside an inert ancestor\n  //  because we're limited in the type of selectors we can use in JSDom (see related\n  //  note related to `candidateSelectors`)\n  isInert(node) || isHiddenInput(node) || isHidden(node, options) ||\n  // For a details element with a summary, the summary element gets the focus\n  isDetailsWithSummary(node) || isDisabledFromFieldset(node)) {\n    return false;\n  }\n  return true;\n};\nvar isNodeMatchingSelectorTabbable = function isNodeMatchingSelectorTabbable(options, node) {\n  if (isNonTabbableRadio(node) || getTabIndex(node) < 0 || !isNodeMatchingSelectorFocusable(options, node)) {\n    return false;\n  }\n  return true;\n};\nvar isValidShadowRootTabbable = function isValidShadowRootTabbable(shadowHostNode) {\n  var tabIndex = parseInt(shadowHostNode.getAttribute('tabindex'), 10);\n  if (isNaN(tabIndex) || tabIndex >= 0) {\n    return true;\n  }\n  // If a custom element has an explicit negative tabindex,\n  // browsers will not allow tab targeting said element's children.\n  return false;\n};\n\n/**\n * @param {Array.<Element|CandidateScope>} candidates\n * @returns Element[]\n */\nvar sortByOrder = function sortByOrder(candidates) {\n  var regularTabbables = [];\n  var orderedTabbables = [];\n  candidates.forEach(function (item, i) {\n    var isScope = !!item.scopeParent;\n    var element = isScope ? item.scopeParent : item;\n    var candidateTabindex = getSortOrderTabIndex(element, isScope);\n    var elements = isScope ? sortByOrder(item.candidates) : element;\n    if (candidateTabindex === 0) {\n      isScope ? regularTabbables.push.apply(regularTabbables, elements) : regularTabbables.push(element);\n    } else {\n      orderedTabbables.push({\n        documentOrder: i,\n        tabIndex: candidateTabindex,\n        item: item,\n        isScope: isScope,\n        content: elements\n      });\n    }\n  });\n  return orderedTabbables.sort(sortOrderedTabbables).reduce(function (acc, sortable) {\n    sortable.isScope ? acc.push.apply(acc, sortable.content) : acc.push(sortable.content);\n    return acc;\n  }, []).concat(regularTabbables);\n};\nvar tabbable = function tabbable(container, options) {\n  options = options || {};\n  var candidates;\n  if (options.getShadowRoot) {\n    candidates = getCandidatesIteratively([container], options.includeContainer, {\n      filter: isNodeMatchingSelectorTabbable.bind(null, options),\n      flatten: false,\n      getShadowRoot: options.getShadowRoot,\n      shadowRootFilter: isValidShadowRootTabbable\n    });\n  } else {\n    candidates = getCandidates(container, options.includeContainer, isNodeMatchingSelectorTabbable.bind(null, options));\n  }\n  return sortByOrder(candidates);\n};\nvar focusable = function focusable(container, options) {\n  options = options || {};\n  var candidates;\n  if (options.getShadowRoot) {\n    candidates = getCandidatesIteratively([container], options.includeContainer, {\n      filter: isNodeMatchingSelectorFocusable.bind(null, options),\n      flatten: true,\n      getShadowRoot: options.getShadowRoot\n    });\n  } else {\n    candidates = getCandidates(container, options.includeContainer, isNodeMatchingSelectorFocusable.bind(null, options));\n  }\n  return candidates;\n};\nvar isTabbable = function isTabbable(node, options) {\n  options = options || {};\n  if (!node) {\n    throw new Error('No node provided');\n  }\n  if (matches.call(node, candidateSelector) === false) {\n    return false;\n  }\n  return isNodeMatchingSelectorTabbable(options, node);\n};\nvar focusableCandidateSelector = /* #__PURE__ */candidateSelectors.concat('iframe').join(',');\nvar isFocusable = function isFocusable(node, options) {\n  options = options || {};\n  if (!node) {\n    throw new Error('No node provided');\n  }\n  if (matches.call(node, focusableCandidateSelector) === false) {\n    return false;\n  }\n  return isNodeMatchingSelectorFocusable(options, node);\n};\n\nexport { focusable, getTabIndex, isFocusable, isTabbable, tabbable };\n//# sourceMappingURL=index.esm.js.map\n","/*!\n* focus-trap 7.6.0\n* @license MIT, https://github.com/focus-trap/focus-trap/blob/master/LICENSE\n*/\nimport { isFocusable, tabbable, focusable, isTabbable, getTabIndex } from 'tabbable';\n\nfunction _defineProperty(e, r, t) {\n  return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, {\n    value: t,\n    enumerable: !0,\n    configurable: !0,\n    writable: !0\n  }) : e[r] = t, e;\n}\nfunction ownKeys(e, r) {\n  var t = Object.keys(e);\n  if (Object.getOwnPropertySymbols) {\n    var o = Object.getOwnPropertySymbols(e);\n    r && (o = o.filter(function (r) {\n      return Object.getOwnPropertyDescriptor(e, r).enumerable;\n    })), t.push.apply(t, o);\n  }\n  return t;\n}\nfunction _objectSpread2(e) {\n  for (var r = 1; r < arguments.length; r++) {\n    var t = null != arguments[r] ? arguments[r] : {};\n    r % 2 ? ownKeys(Object(t), !0).forEach(function (r) {\n      _defineProperty(e, r, t[r]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) {\n      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n    });\n  }\n  return e;\n}\nfunction _toPrimitive(t, r) {\n  if (\"object\" != typeof t || !t) return t;\n  var e = t[Symbol.toPrimitive];\n  if (void 0 !== e) {\n    var i = e.call(t, r || \"default\");\n    if (\"object\" != typeof i) return i;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (\"string\" === r ? String : Number)(t);\n}\nfunction _toPropertyKey(t) {\n  var i = _toPrimitive(t, \"string\");\n  return \"symbol\" == typeof i ? i : i + \"\";\n}\n\nvar activeFocusTraps = {\n  activateTrap: function activateTrap(trapStack, trap) {\n    if (trapStack.length > 0) {\n      var activeTrap = trapStack[trapStack.length - 1];\n      if (activeTrap !== trap) {\n        activeTrap.pause();\n      }\n    }\n    var trapIndex = trapStack.indexOf(trap);\n    if (trapIndex === -1) {\n      trapStack.push(trap);\n    } else {\n      // move this existing trap to the front of the queue\n      trapStack.splice(trapIndex, 1);\n      trapStack.push(trap);\n    }\n  },\n  deactivateTrap: function deactivateTrap(trapStack, trap) {\n    var trapIndex = trapStack.indexOf(trap);\n    if (trapIndex !== -1) {\n      trapStack.splice(trapIndex, 1);\n    }\n    if (trapStack.length > 0) {\n      trapStack[trapStack.length - 1].unpause();\n    }\n  }\n};\nvar isSelectableInput = function isSelectableInput(node) {\n  return node.tagName && node.tagName.toLowerCase() === 'input' && typeof node.select === 'function';\n};\nvar isEscapeEvent = function isEscapeEvent(e) {\n  return (e === null || e === void 0 ? void 0 : e.key) === 'Escape' || (e === null || e === void 0 ? void 0 : e.key) === 'Esc' || (e === null || e === void 0 ? void 0 : e.keyCode) === 27;\n};\nvar isTabEvent = function isTabEvent(e) {\n  return (e === null || e === void 0 ? void 0 : e.key) === 'Tab' || (e === null || e === void 0 ? void 0 : e.keyCode) === 9;\n};\n\n// checks for TAB by default\nvar isKeyForward = function isKeyForward(e) {\n  return isTabEvent(e) && !e.shiftKey;\n};\n\n// checks for SHIFT+TAB by default\nvar isKeyBackward = function isKeyBackward(e) {\n  return isTabEvent(e) && e.shiftKey;\n};\nvar delay = function delay(fn) {\n  return setTimeout(fn, 0);\n};\n\n// Array.find/findIndex() are not supported on IE; this replicates enough\n//  of Array.findIndex() for our needs\nvar findIndex = function findIndex(arr, fn) {\n  var idx = -1;\n  arr.every(function (value, i) {\n    if (fn(value)) {\n      idx = i;\n      return false; // break\n    }\n    return true; // next\n  });\n  return idx;\n};\n\n/**\n * Get an option's value when it could be a plain value, or a handler that provides\n *  the value.\n * @param {*} value Option's value to check.\n * @param {...*} [params] Any parameters to pass to the handler, if `value` is a function.\n * @returns {*} The `value`, or the handler's returned value.\n */\nvar valueOrHandler = function valueOrHandler(value) {\n  for (var _len = arguments.length, params = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    params[_key - 1] = arguments[_key];\n  }\n  return typeof value === 'function' ? value.apply(void 0, params) : value;\n};\nvar getActualTarget = function getActualTarget(event) {\n  // NOTE: If the trap is _inside_ a shadow DOM, event.target will always be the\n  //  shadow host. However, event.target.composedPath() will be an array of\n  //  nodes \"clicked\" from inner-most (the actual element inside the shadow) to\n  //  outer-most (the host HTML document). If we have access to composedPath(),\n  //  then use its first element; otherwise, fall back to event.target (and\n  //  this only works for an _open_ shadow DOM; otherwise,\n  //  composedPath()[0] === event.target always).\n  return event.target.shadowRoot && typeof event.composedPath === 'function' ? event.composedPath()[0] : event.target;\n};\n\n// NOTE: this must be _outside_ `createFocusTrap()` to make sure all traps in this\n//  current instance use the same stack if `userOptions.trapStack` isn't specified\nvar internalTrapStack = [];\nvar createFocusTrap = function createFocusTrap(elements, userOptions) {\n  // SSR: a live trap shouldn't be created in this type of environment so this\n  //  should be safe code to execute if the `document` option isn't specified\n  var doc = (userOptions === null || userOptions === void 0 ? void 0 : userOptions.document) || document;\n  var trapStack = (userOptions === null || userOptions === void 0 ? void 0 : userOptions.trapStack) || internalTrapStack;\n  var config = _objectSpread2({\n    returnFocusOnDeactivate: true,\n    escapeDeactivates: true,\n    delayInitialFocus: true,\n    isKeyForward: isKeyForward,\n    isKeyBackward: isKeyBackward\n  }, userOptions);\n  var state = {\n    // containers given to createFocusTrap()\n    // @type {Array<HTMLElement>}\n    containers: [],\n    // list of objects identifying tabbable nodes in `containers` in the trap\n    // NOTE: it's possible that a group has no tabbable nodes if nodes get removed while the trap\n    //  is active, but the trap should never get to a state where there isn't at least one group\n    //  with at least one tabbable node in it (that would lead to an error condition that would\n    //  result in an error being thrown)\n    // @type {Array<{\n    //   container: HTMLElement,\n    //   tabbableNodes: Array<HTMLElement>, // empty if none\n    //   focusableNodes: Array<HTMLElement>, // empty if none\n    //   posTabIndexesFound: boolean,\n    //   firstTabbableNode: HTMLElement|undefined,\n    //   lastTabbableNode: HTMLElement|undefined,\n    //   firstDomTabbableNode: HTMLElement|undefined,\n    //   lastDomTabbableNode: HTMLElement|undefined,\n    //   nextTabbableNode: (node: HTMLElement, forward: boolean) => HTMLElement|undefined\n    // }>}\n    containerGroups: [],\n    // same order/length as `containers` list\n\n    // references to objects in `containerGroups`, but only those that actually have\n    //  tabbable nodes in them\n    // NOTE: same order as `containers` and `containerGroups`, but __not necessarily__\n    //  the same length\n    tabbableGroups: [],\n    nodeFocusedBeforeActivation: null,\n    mostRecentlyFocusedNode: null,\n    active: false,\n    paused: false,\n    // timer ID for when delayInitialFocus is true and initial focus in this trap\n    //  has been delayed during activation\n    delayInitialFocusTimer: undefined,\n    // the most recent KeyboardEvent for the configured nav key (typically [SHIFT+]TAB), if any\n    recentNavEvent: undefined\n  };\n  var trap; // eslint-disable-line prefer-const -- some private functions reference it, and its methods reference private functions, so we must declare here and define later\n\n  /**\n   * Gets a configuration option value.\n   * @param {Object|undefined} configOverrideOptions If true, and option is defined in this set,\n   *  value will be taken from this object. Otherwise, value will be taken from base configuration.\n   * @param {string} optionName Name of the option whose value is sought.\n   * @param {string|undefined} [configOptionName] Name of option to use __instead of__ `optionName`\n   *  IIF `configOverrideOptions` is not defined. Otherwise, `optionName` is used.\n   */\n  var getOption = function getOption(configOverrideOptions, optionName, configOptionName) {\n    return configOverrideOptions && configOverrideOptions[optionName] !== undefined ? configOverrideOptions[optionName] : config[configOptionName || optionName];\n  };\n\n  /**\n   * Finds the index of the container that contains the element.\n   * @param {HTMLElement} element\n   * @param {Event} [event] If available, and `element` isn't directly found in any container,\n   *  the event's composed path is used to see if includes any known trap containers in the\n   *  case where the element is inside a Shadow DOM.\n   * @returns {number} Index of the container in either `state.containers` or\n   *  `state.containerGroups` (the order/length of these lists are the same); -1\n   *  if the element isn't found.\n   */\n  var findContainerIndex = function findContainerIndex(element, event) {\n    var composedPath = typeof (event === null || event === void 0 ? void 0 : event.composedPath) === 'function' ? event.composedPath() : undefined;\n    // NOTE: search `containerGroups` because it's possible a group contains no tabbable\n    //  nodes, but still contains focusable nodes (e.g. if they all have `tabindex=-1`)\n    //  and we still need to find the element in there\n    return state.containerGroups.findIndex(function (_ref) {\n      var container = _ref.container,\n        tabbableNodes = _ref.tabbableNodes;\n      return container.contains(element) || ( // fall back to explicit tabbable search which will take into consideration any\n      //  web components if the `tabbableOptions.getShadowRoot` option was used for\n      //  the trap, enabling shadow DOM support in tabbable (`Node.contains()` doesn't\n      //  look inside web components even if open)\n      composedPath === null || composedPath === void 0 ? void 0 : composedPath.includes(container)) || tabbableNodes.find(function (node) {\n        return node === element;\n      });\n    });\n  };\n\n  /**\n   * Gets the node for the given option, which is expected to be an option that\n   *  can be either a DOM node, a string that is a selector to get a node, `false`\n   *  (if a node is explicitly NOT given), or a function that returns any of these\n   *  values.\n   * @param {string} optionName\n   * @returns {undefined | false | HTMLElement | SVGElement} Returns\n   *  `undefined` if the option is not specified; `false` if the option\n   *  resolved to `false` (node explicitly not given); otherwise, the resolved\n   *  DOM node.\n   * @throws {Error} If the option is set, not `false`, and is not, or does not\n   *  resolve to a node.\n   */\n  var getNodeForOption = function getNodeForOption(optionName) {\n    var optionValue = config[optionName];\n    if (typeof optionValue === 'function') {\n      for (var _len2 = arguments.length, params = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n        params[_key2 - 1] = arguments[_key2];\n      }\n      optionValue = optionValue.apply(void 0, params);\n    }\n    if (optionValue === true) {\n      optionValue = undefined; // use default value\n    }\n    if (!optionValue) {\n      if (optionValue === undefined || optionValue === false) {\n        return optionValue;\n      }\n      // else, empty string (invalid), null (invalid), 0 (invalid)\n\n      throw new Error(\"`\".concat(optionName, \"` was specified but was not a node, or did not return a node\"));\n    }\n    var node = optionValue; // could be HTMLElement, SVGElement, or non-empty string at this point\n\n    if (typeof optionValue === 'string') {\n      node = doc.querySelector(optionValue); // resolve to node, or null if fails\n      if (!node) {\n        throw new Error(\"`\".concat(optionName, \"` as selector refers to no known node\"));\n      }\n    }\n    return node;\n  };\n  var getInitialFocusNode = function getInitialFocusNode() {\n    var node = getNodeForOption('initialFocus');\n\n    // false explicitly indicates we want no initialFocus at all\n    if (node === false) {\n      return false;\n    }\n    if (node === undefined || !isFocusable(node, config.tabbableOptions)) {\n      // option not specified nor focusable: use fallback options\n      if (findContainerIndex(doc.activeElement) >= 0) {\n        node = doc.activeElement;\n      } else {\n        var firstTabbableGroup = state.tabbableGroups[0];\n        var firstTabbableNode = firstTabbableGroup && firstTabbableGroup.firstTabbableNode;\n\n        // NOTE: `fallbackFocus` option function cannot return `false` (not supported)\n        node = firstTabbableNode || getNodeForOption('fallbackFocus');\n      }\n    }\n    if (!node) {\n      throw new Error('Your focus-trap needs to have at least one focusable element');\n    }\n    return node;\n  };\n  var updateTabbableNodes = function updateTabbableNodes() {\n    state.containerGroups = state.containers.map(function (container) {\n      var tabbableNodes = tabbable(container, config.tabbableOptions);\n\n      // NOTE: if we have tabbable nodes, we must have focusable nodes; focusable nodes\n      //  are a superset of tabbable nodes since nodes with negative `tabindex` attributes\n      //  are focusable but not tabbable\n      var focusableNodes = focusable(container, config.tabbableOptions);\n      var firstTabbableNode = tabbableNodes.length > 0 ? tabbableNodes[0] : undefined;\n      var lastTabbableNode = tabbableNodes.length > 0 ? tabbableNodes[tabbableNodes.length - 1] : undefined;\n      var firstDomTabbableNode = focusableNodes.find(function (node) {\n        return isTabbable(node);\n      });\n      var lastDomTabbableNode = focusableNodes.slice().reverse().find(function (node) {\n        return isTabbable(node);\n      });\n      var posTabIndexesFound = !!tabbableNodes.find(function (node) {\n        return getTabIndex(node) > 0;\n      });\n      return {\n        container: container,\n        tabbableNodes: tabbableNodes,\n        focusableNodes: focusableNodes,\n        /** True if at least one node with positive `tabindex` was found in this container. */\n        posTabIndexesFound: posTabIndexesFound,\n        /** First tabbable node in container, __tabindex__ order; `undefined` if none. */\n        firstTabbableNode: firstTabbableNode,\n        /** Last tabbable node in container, __tabindex__ order; `undefined` if none. */\n        lastTabbableNode: lastTabbableNode,\n        // NOTE: DOM order is NOT NECESSARILY \"document position\" order, but figuring that out\n        //  would require more than just https://developer.mozilla.org/en-US/docs/Web/API/Node/compareDocumentPosition\n        //  because that API doesn't work with Shadow DOM as well as it should (@see\n        //  https://github.com/whatwg/dom/issues/320) and since this first/last is only needed, so far,\n        //  to address an edge case related to positive tabindex support, this seems like a much easier,\n        //  \"close enough most of the time\" alternative for positive tabindexes which should generally\n        //  be avoided anyway...\n        /** First tabbable node in container, __DOM__ order; `undefined` if none. */\n        firstDomTabbableNode: firstDomTabbableNode,\n        /** Last tabbable node in container, __DOM__ order; `undefined` if none. */\n        lastDomTabbableNode: lastDomTabbableNode,\n        /**\n         * Finds the __tabbable__ node that follows the given node in the specified direction,\n         *  in this container, if any.\n         * @param {HTMLElement} node\n         * @param {boolean} [forward] True if going in forward tab order; false if going\n         *  in reverse.\n         * @returns {HTMLElement|undefined} The next tabbable node, if any.\n         */\n        nextTabbableNode: function nextTabbableNode(node) {\n          var forward = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n          var nodeIdx = tabbableNodes.indexOf(node);\n          if (nodeIdx < 0) {\n            // either not tabbable nor focusable, or was focused but not tabbable (negative tabindex):\n            //  since `node` should at least have been focusable, we assume that's the case and mimic\n            //  what browsers do, which is set focus to the next node in __document position order__,\n            //  regardless of positive tabindexes, if any -- and for reasons explained in the NOTE\n            //  above related to `firstDomTabbable` and `lastDomTabbable` properties, we fall back to\n            //  basic DOM order\n            if (forward) {\n              return focusableNodes.slice(focusableNodes.indexOf(node) + 1).find(function (el) {\n                return isTabbable(el);\n              });\n            }\n            return focusableNodes.slice(0, focusableNodes.indexOf(node)).reverse().find(function (el) {\n              return isTabbable(el);\n            });\n          }\n          return tabbableNodes[nodeIdx + (forward ? 1 : -1)];\n        }\n      };\n    });\n    state.tabbableGroups = state.containerGroups.filter(function (group) {\n      return group.tabbableNodes.length > 0;\n    });\n\n    // throw if no groups have tabbable nodes and we don't have a fallback focus node either\n    if (state.tabbableGroups.length <= 0 && !getNodeForOption('fallbackFocus') // returning false not supported for this option\n    ) {\n      throw new Error('Your focus-trap must have at least one container with at least one tabbable node in it at all times');\n    }\n\n    // NOTE: Positive tabindexes are only properly supported in single-container traps because\n    //  doing it across multiple containers where tabindexes could be all over the place\n    //  would require Tabbable to support multiple containers, would require additional\n    //  specialized Shadow DOM support, and would require Tabbable's multi-container support\n    //  to look at those containers in document position order rather than user-provided\n    //  order (as they are treated in Focus-trap, for legacy reasons). See discussion on\n    //  https://github.com/focus-trap/focus-trap/issues/375 for more details.\n    if (state.containerGroups.find(function (g) {\n      return g.posTabIndexesFound;\n    }) && state.containerGroups.length > 1) {\n      throw new Error(\"At least one node with a positive tabindex was found in one of your focus-trap's multiple containers. Positive tabindexes are only supported in single-container focus-traps.\");\n    }\n  };\n\n  /**\n   * Gets the current activeElement. If it's a web-component and has open shadow-root\n   * it will recursively search inside shadow roots for the \"true\" activeElement.\n   *\n   * @param {Document | ShadowRoot} el\n   *\n   * @returns {HTMLElement} The element that currently has the focus\n   **/\n  var _getActiveElement = function getActiveElement(el) {\n    var activeElement = el.activeElement;\n    if (!activeElement) {\n      return;\n    }\n    if (activeElement.shadowRoot && activeElement.shadowRoot.activeElement !== null) {\n      return _getActiveElement(activeElement.shadowRoot);\n    }\n    return activeElement;\n  };\n  var _tryFocus = function tryFocus(node) {\n    if (node === false) {\n      return;\n    }\n    if (node === _getActiveElement(document)) {\n      return;\n    }\n    if (!node || !node.focus) {\n      _tryFocus(getInitialFocusNode());\n      return;\n    }\n    node.focus({\n      preventScroll: !!config.preventScroll\n    });\n    // NOTE: focus() API does not trigger focusIn event so set MRU node manually\n    state.mostRecentlyFocusedNode = node;\n    if (isSelectableInput(node)) {\n      node.select();\n    }\n  };\n  var getReturnFocusNode = function getReturnFocusNode(previousActiveElement) {\n    var node = getNodeForOption('setReturnFocus', previousActiveElement);\n    return node ? node : node === false ? false : previousActiveElement;\n  };\n\n  /**\n   * Finds the next node (in either direction) where focus should move according to a\n   *  keyboard focus-in event.\n   * @param {Object} params\n   * @param {Node} [params.target] Known target __from which__ to navigate, if any.\n   * @param {KeyboardEvent|FocusEvent} [params.event] Event to use if `target` isn't known (event\n   *  will be used to determine the `target`). Ignored if `target` is specified.\n   * @param {boolean} [params.isBackward] True if focus should move backward.\n   * @returns {Node|undefined} The next node, or `undefined` if a next node couldn't be\n   *  determined given the current state of the trap.\n   */\n  var findNextNavNode = function findNextNavNode(_ref2) {\n    var target = _ref2.target,\n      event = _ref2.event,\n      _ref2$isBackward = _ref2.isBackward,\n      isBackward = _ref2$isBackward === void 0 ? false : _ref2$isBackward;\n    target = target || getActualTarget(event);\n    updateTabbableNodes();\n    var destinationNode = null;\n    if (state.tabbableGroups.length > 0) {\n      // make sure the target is actually contained in a group\n      // NOTE: the target may also be the container itself if it's focusable\n      //  with tabIndex='-1' and was given initial focus\n      var containerIndex = findContainerIndex(target, event);\n      var containerGroup = containerIndex >= 0 ? state.containerGroups[containerIndex] : undefined;\n      if (containerIndex < 0) {\n        // target not found in any group: quite possible focus has escaped the trap,\n        //  so bring it back into...\n        if (isBackward) {\n          // ...the last node in the last group\n          destinationNode = state.tabbableGroups[state.tabbableGroups.length - 1].lastTabbableNode;\n        } else {\n          // ...the first node in the first group\n          destinationNode = state.tabbableGroups[0].firstTabbableNode;\n        }\n      } else if (isBackward) {\n        // REVERSE\n\n        // is the target the first tabbable node in a group?\n        var startOfGroupIndex = findIndex(state.tabbableGroups, function (_ref3) {\n          var firstTabbableNode = _ref3.firstTabbableNode;\n          return target === firstTabbableNode;\n        });\n        if (startOfGroupIndex < 0 && (containerGroup.container === target || isFocusable(target, config.tabbableOptions) && !isTabbable(target, config.tabbableOptions) && !containerGroup.nextTabbableNode(target, false))) {\n          // an exception case where the target is either the container itself, or\n          //  a non-tabbable node that was given focus (i.e. tabindex is negative\n          //  and user clicked on it or node was programmatically given focus)\n          //  and is not followed by any other tabbable node, in which\n          //  case, we should handle shift+tab as if focus were on the container's\n          //  first tabbable node, and go to the last tabbable node of the LAST group\n          startOfGroupIndex = containerIndex;\n        }\n        if (startOfGroupIndex >= 0) {\n          // YES: then shift+tab should go to the last tabbable node in the\n          //  previous group (and wrap around to the last tabbable node of\n          //  the LAST group if it's the first tabbable node of the FIRST group)\n          var destinationGroupIndex = startOfGroupIndex === 0 ? state.tabbableGroups.length - 1 : startOfGroupIndex - 1;\n          var destinationGroup = state.tabbableGroups[destinationGroupIndex];\n          destinationNode = getTabIndex(target) >= 0 ? destinationGroup.lastTabbableNode : destinationGroup.lastDomTabbableNode;\n        } else if (!isTabEvent(event)) {\n          // user must have customized the nav keys so we have to move focus manually _within_\n          //  the active group: do this based on the order determined by tabbable()\n          destinationNode = containerGroup.nextTabbableNode(target, false);\n        }\n      } else {\n        // FORWARD\n\n        // is the target the last tabbable node in a group?\n        var lastOfGroupIndex = findIndex(state.tabbableGroups, function (_ref4) {\n          var lastTabbableNode = _ref4.lastTabbableNode;\n          return target === lastTabbableNode;\n        });\n        if (lastOfGroupIndex < 0 && (containerGroup.container === target || isFocusable(target, config.tabbableOptions) && !isTabbable(target, config.tabbableOptions) && !containerGroup.nextTabbableNode(target))) {\n          // an exception case where the target is the container itself, or\n          //  a non-tabbable node that was given focus (i.e. tabindex is negative\n          //  and user clicked on it or node was programmatically given focus)\n          //  and is not followed by any other tabbable node, in which\n          //  case, we should handle tab as if focus were on the container's\n          //  last tabbable node, and go to the first tabbable node of the FIRST group\n          lastOfGroupIndex = containerIndex;\n        }\n        if (lastOfGroupIndex >= 0) {\n          // YES: then tab should go to the first tabbable node in the next\n          //  group (and wrap around to the first tabbable node of the FIRST\n          //  group if it's the last tabbable node of the LAST group)\n          var _destinationGroupIndex = lastOfGroupIndex === state.tabbableGroups.length - 1 ? 0 : lastOfGroupIndex + 1;\n          var _destinationGroup = state.tabbableGroups[_destinationGroupIndex];\n          destinationNode = getTabIndex(target) >= 0 ? _destinationGroup.firstTabbableNode : _destinationGroup.firstDomTabbableNode;\n        } else if (!isTabEvent(event)) {\n          // user must have customized the nav keys so we have to move focus manually _within_\n          //  the active group: do this based on the order determined by tabbable()\n          destinationNode = containerGroup.nextTabbableNode(target);\n        }\n      }\n    } else {\n      // no groups available\n      // NOTE: the fallbackFocus option does not support returning false to opt-out\n      destinationNode = getNodeForOption('fallbackFocus');\n    }\n    return destinationNode;\n  };\n\n  // This needs to be done on mousedown and touchstart instead of click\n  // so that it precedes the focus event.\n  var checkPointerDown = function checkPointerDown(e) {\n    var target = getActualTarget(e);\n    if (findContainerIndex(target, e) >= 0) {\n      // allow the click since it ocurred inside the trap\n      return;\n    }\n    if (valueOrHandler(config.clickOutsideDeactivates, e)) {\n      // immediately deactivate the trap\n      trap.deactivate({\n        // NOTE: by setting `returnFocus: false`, deactivate() will do nothing,\n        //  which will result in the outside click setting focus to the node\n        //  that was clicked (and if not focusable, to \"nothing\"); by setting\n        //  `returnFocus: true`, we'll attempt to re-focus the node originally-focused\n        //  on activation (or the configured `setReturnFocus` node), whether the\n        //  outside click was on a focusable node or not\n        returnFocus: config.returnFocusOnDeactivate\n      });\n      return;\n    }\n\n    // This is needed for mobile devices.\n    // (If we'll only let `click` events through,\n    // then on mobile they will be blocked anyways if `touchstart` is blocked.)\n    if (valueOrHandler(config.allowOutsideClick, e)) {\n      // allow the click outside the trap to take place\n      return;\n    }\n\n    // otherwise, prevent the click\n    e.preventDefault();\n  };\n\n  // In case focus escapes the trap for some strange reason, pull it back in.\n  // NOTE: the focusIn event is NOT cancelable, so if focus escapes, it may cause unexpected\n  //  scrolling if the node that got focused was out of view; there's nothing we can do to\n  //  prevent that from happening by the time we discover that focus escaped\n  var checkFocusIn = function checkFocusIn(event) {\n    var target = getActualTarget(event);\n    var targetContained = findContainerIndex(target, event) >= 0;\n\n    // In Firefox when you Tab out of an iframe the Document is briefly focused.\n    if (targetContained || target instanceof Document) {\n      if (targetContained) {\n        state.mostRecentlyFocusedNode = target;\n      }\n    } else {\n      // escaped! pull it back in to where it just left\n      event.stopImmediatePropagation();\n\n      // focus will escape if the MRU node had a positive tab index and user tried to nav forward;\n      //  it will also escape if the MRU node had a 0 tab index and user tried to nav backward\n      //  toward a node with a positive tab index\n      var nextNode; // next node to focus, if we find one\n      var navAcrossContainers = true;\n      if (state.mostRecentlyFocusedNode) {\n        if (getTabIndex(state.mostRecentlyFocusedNode) > 0) {\n          // MRU container index must be >=0 otherwise we wouldn't have it as an MRU node...\n          var mruContainerIdx = findContainerIndex(state.mostRecentlyFocusedNode);\n          // there MAY not be any tabbable nodes in the container if there are at least 2 containers\n          //  and the MRU node is focusable but not tabbable (focus-trap requires at least 1 container\n          //  with at least one tabbable node in order to function, so this could be the other container\n          //  with nothing tabbable in it)\n          var tabbableNodes = state.containerGroups[mruContainerIdx].tabbableNodes;\n          if (tabbableNodes.length > 0) {\n            // MRU tab index MAY not be found if the MRU node is focusable but not tabbable\n            var mruTabIdx = tabbableNodes.findIndex(function (node) {\n              return node === state.mostRecentlyFocusedNode;\n            });\n            if (mruTabIdx >= 0) {\n              if (config.isKeyForward(state.recentNavEvent)) {\n                if (mruTabIdx + 1 < tabbableNodes.length) {\n                  nextNode = tabbableNodes[mruTabIdx + 1];\n                  navAcrossContainers = false;\n                }\n                // else, don't wrap within the container as focus should move to next/previous\n                //  container\n              } else {\n                if (mruTabIdx - 1 >= 0) {\n                  nextNode = tabbableNodes[mruTabIdx - 1];\n                  navAcrossContainers = false;\n                }\n                // else, don't wrap within the container as focus should move to next/previous\n                //  container\n              }\n              // else, don't find in container order without considering direction too\n            }\n          }\n          // else, no tabbable nodes in that container (which means we must have at least one other\n          //  container with at least one tabbable node in it, otherwise focus-trap would've thrown\n          //  an error the last time updateTabbableNodes() was run): find next node among all known\n          //  containers\n        } else {\n          // check to see if there's at least one tabbable node with a positive tab index inside\n          //  the trap because focus seems to escape when navigating backward from a tabbable node\n          //  with tabindex=0 when this is the case (instead of wrapping to the tabbable node with\n          //  the greatest positive tab index like it should)\n          if (!state.containerGroups.some(function (g) {\n            return g.tabbableNodes.some(function (n) {\n              return getTabIndex(n) > 0;\n            });\n          })) {\n            // no containers with tabbable nodes with positive tab indexes which means the focus\n            //  escaped for some other reason and we should just execute the fallback to the\n            //  MRU node or initial focus node, if any\n            navAcrossContainers = false;\n          }\n        }\n      } else {\n        // no MRU node means we're likely in some initial condition when the trap has just\n        //  been activated and initial focus hasn't been given yet, in which case we should\n        //  fall through to trying to focus the initial focus node, which is what should\n        //  happen below at this point in the logic\n        navAcrossContainers = false;\n      }\n      if (navAcrossContainers) {\n        nextNode = findNextNavNode({\n          // move FROM the MRU node, not event-related node (which will be the node that is\n          //  outside the trap causing the focus escape we're trying to fix)\n          target: state.mostRecentlyFocusedNode,\n          isBackward: config.isKeyBackward(state.recentNavEvent)\n        });\n      }\n      if (nextNode) {\n        _tryFocus(nextNode);\n      } else {\n        _tryFocus(state.mostRecentlyFocusedNode || getInitialFocusNode());\n      }\n    }\n    state.recentNavEvent = undefined; // clear\n  };\n\n  // Hijack key nav events on the first and last focusable nodes of the trap,\n  // in order to prevent focus from escaping. If it escapes for even a\n  // moment it can end up scrolling the page and causing confusion so we\n  // kind of need to capture the action at the keydown phase.\n  var checkKeyNav = function checkKeyNav(event) {\n    var isBackward = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    state.recentNavEvent = event;\n    var destinationNode = findNextNavNode({\n      event: event,\n      isBackward: isBackward\n    });\n    if (destinationNode) {\n      if (isTabEvent(event)) {\n        // since tab natively moves focus, we wouldn't have a destination node unless we\n        //  were on the edge of a container and had to move to the next/previous edge, in\n        //  which case we want to prevent default to keep the browser from moving focus\n        //  to where it normally would\n        event.preventDefault();\n      }\n      _tryFocus(destinationNode);\n    }\n    // else, let the browser take care of [shift+]tab and move the focus\n  };\n  var checkTabKey = function checkTabKey(event) {\n    if (config.isKeyForward(event) || config.isKeyBackward(event)) {\n      checkKeyNav(event, config.isKeyBackward(event));\n    }\n  };\n\n  // we use a different event phase for the Escape key to allow canceling the event and checking for this in escapeDeactivates\n  var checkEscapeKey = function checkEscapeKey(event) {\n    if (isEscapeEvent(event) && valueOrHandler(config.escapeDeactivates, event) !== false) {\n      event.preventDefault();\n      trap.deactivate();\n    }\n  };\n  var checkClick = function checkClick(e) {\n    var target = getActualTarget(e);\n    if (findContainerIndex(target, e) >= 0) {\n      return;\n    }\n    if (valueOrHandler(config.clickOutsideDeactivates, e)) {\n      return;\n    }\n    if (valueOrHandler(config.allowOutsideClick, e)) {\n      return;\n    }\n    e.preventDefault();\n    e.stopImmediatePropagation();\n  };\n\n  //\n  // EVENT LISTENERS\n  //\n\n  var addListeners = function addListeners() {\n    if (!state.active) {\n      return;\n    }\n\n    // There can be only one listening focus trap at a time\n    activeFocusTraps.activateTrap(trapStack, trap);\n\n    // Delay ensures that the focused element doesn't capture the event\n    // that caused the focus trap activation.\n    state.delayInitialFocusTimer = config.delayInitialFocus ? delay(function () {\n      _tryFocus(getInitialFocusNode());\n    }) : _tryFocus(getInitialFocusNode());\n    doc.addEventListener('focusin', checkFocusIn, true);\n    doc.addEventListener('mousedown', checkPointerDown, {\n      capture: true,\n      passive: false\n    });\n    doc.addEventListener('touchstart', checkPointerDown, {\n      capture: true,\n      passive: false\n    });\n    doc.addEventListener('click', checkClick, {\n      capture: true,\n      passive: false\n    });\n    doc.addEventListener('keydown', checkTabKey, {\n      capture: true,\n      passive: false\n    });\n    doc.addEventListener('keydown', checkEscapeKey);\n    return trap;\n  };\n  var removeListeners = function removeListeners() {\n    if (!state.active) {\n      return;\n    }\n    doc.removeEventListener('focusin', checkFocusIn, true);\n    doc.removeEventListener('mousedown', checkPointerDown, true);\n    doc.removeEventListener('touchstart', checkPointerDown, true);\n    doc.removeEventListener('click', checkClick, true);\n    doc.removeEventListener('keydown', checkTabKey, true);\n    doc.removeEventListener('keydown', checkEscapeKey);\n    return trap;\n  };\n\n  //\n  // MUTATION OBSERVER\n  //\n\n  var checkDomRemoval = function checkDomRemoval(mutations) {\n    var isFocusedNodeRemoved = mutations.some(function (mutation) {\n      var removedNodes = Array.from(mutation.removedNodes);\n      return removedNodes.some(function (node) {\n        return node === state.mostRecentlyFocusedNode;\n      });\n    });\n\n    // If the currently focused is removed then browsers will move focus to the\n    // <body> element. If this happens, try to move focus back into the trap.\n    if (isFocusedNodeRemoved) {\n      _tryFocus(getInitialFocusNode());\n    }\n  };\n\n  // Use MutationObserver - if supported - to detect if focused node is removed\n  // from the DOM.\n  var mutationObserver = typeof window !== 'undefined' && 'MutationObserver' in window ? new MutationObserver(checkDomRemoval) : undefined;\n  var updateObservedNodes = function updateObservedNodes() {\n    if (!mutationObserver) {\n      return;\n    }\n    mutationObserver.disconnect();\n    if (state.active && !state.paused) {\n      state.containers.map(function (container) {\n        mutationObserver.observe(container, {\n          subtree: true,\n          childList: true\n        });\n      });\n    }\n  };\n\n  //\n  // TRAP DEFINITION\n  //\n\n  trap = {\n    get active() {\n      return state.active;\n    },\n    get paused() {\n      return state.paused;\n    },\n    activate: function activate(activateOptions) {\n      if (state.active) {\n        return this;\n      }\n      var onActivate = getOption(activateOptions, 'onActivate');\n      var onPostActivate = getOption(activateOptions, 'onPostActivate');\n      var checkCanFocusTrap = getOption(activateOptions, 'checkCanFocusTrap');\n      if (!checkCanFocusTrap) {\n        updateTabbableNodes();\n      }\n      state.active = true;\n      state.paused = false;\n      state.nodeFocusedBeforeActivation = doc.activeElement;\n      onActivate === null || onActivate === void 0 || onActivate();\n      var finishActivation = function finishActivation() {\n        if (checkCanFocusTrap) {\n          updateTabbableNodes();\n        }\n        addListeners();\n        updateObservedNodes();\n        onPostActivate === null || onPostActivate === void 0 || onPostActivate();\n      };\n      if (checkCanFocusTrap) {\n        checkCanFocusTrap(state.containers.concat()).then(finishActivation, finishActivation);\n        return this;\n      }\n      finishActivation();\n      return this;\n    },\n    deactivate: function deactivate(deactivateOptions) {\n      if (!state.active) {\n        return this;\n      }\n      var options = _objectSpread2({\n        onDeactivate: config.onDeactivate,\n        onPostDeactivate: config.onPostDeactivate,\n        checkCanReturnFocus: config.checkCanReturnFocus\n      }, deactivateOptions);\n      clearTimeout(state.delayInitialFocusTimer); // noop if undefined\n      state.delayInitialFocusTimer = undefined;\n      removeListeners();\n      state.active = false;\n      state.paused = false;\n      updateObservedNodes();\n      activeFocusTraps.deactivateTrap(trapStack, trap);\n      var onDeactivate = getOption(options, 'onDeactivate');\n      var onPostDeactivate = getOption(options, 'onPostDeactivate');\n      var checkCanReturnFocus = getOption(options, 'checkCanReturnFocus');\n      var returnFocus = getOption(options, 'returnFocus', 'returnFocusOnDeactivate');\n      onDeactivate === null || onDeactivate === void 0 || onDeactivate();\n      var finishDeactivation = function finishDeactivation() {\n        delay(function () {\n          if (returnFocus) {\n            _tryFocus(getReturnFocusNode(state.nodeFocusedBeforeActivation));\n          }\n          onPostDeactivate === null || onPostDeactivate === void 0 || onPostDeactivate();\n        });\n      };\n      if (returnFocus && checkCanReturnFocus) {\n        checkCanReturnFocus(getReturnFocusNode(state.nodeFocusedBeforeActivation)).then(finishDeactivation, finishDeactivation);\n        return this;\n      }\n      finishDeactivation();\n      return this;\n    },\n    pause: function pause(pauseOptions) {\n      if (state.paused || !state.active) {\n        return this;\n      }\n      var onPause = getOption(pauseOptions, 'onPause');\n      var onPostPause = getOption(pauseOptions, 'onPostPause');\n      state.paused = true;\n      onPause === null || onPause === void 0 || onPause();\n      removeListeners();\n      updateObservedNodes();\n      onPostPause === null || onPostPause === void 0 || onPostPause();\n      return this;\n    },\n    unpause: function unpause(unpauseOptions) {\n      if (!state.paused || !state.active) {\n        return this;\n      }\n      var onUnpause = getOption(unpauseOptions, 'onUnpause');\n      var onPostUnpause = getOption(unpauseOptions, 'onPostUnpause');\n      state.paused = false;\n      onUnpause === null || onUnpause === void 0 || onUnpause();\n      updateTabbableNodes();\n      addListeners();\n      updateObservedNodes();\n      onPostUnpause === null || onPostUnpause === void 0 || onPostUnpause();\n      return this;\n    },\n    updateContainerElements: function updateContainerElements(containerElements) {\n      var elementsAsArray = [].concat(containerElements).filter(Boolean);\n      state.containers = elementsAsArray.map(function (element) {\n        return typeof element === 'string' ? doc.querySelector(element) : element;\n      });\n      if (state.active) {\n        updateTabbableNodes();\n      }\n      updateObservedNodes();\n      return this;\n    }\n  };\n\n  // initialize container elements\n  trap.updateContainerElements(elements);\n  return trap;\n};\n\nexport { createFocusTrap };\n//# sourceMappingURL=focus-trap.esm.js.map\n","// Modified from Grail UI v0.9.6 (2023-06-10)\n// Source: https://github.com/grail-ui/grail-ui\n// https://github.com/grail-ui/grail-ui/tree/master/packages/grail-ui/src/focusTrap/focusTrap.ts\nimport { writable, readonly } from 'svelte/store';\nimport { createFocusTrap as _createFocusTrap } from 'focus-trap';\nexport function createFocusTrap(config = {}) {\n    let trap;\n    const { immediate, ...focusTrapOptions } = config;\n    const hasFocus = writable(false);\n    const isPaused = writable(false);\n    const activate = (opts) => trap?.activate(opts);\n    const deactivate = (opts) => {\n        trap?.deactivate(opts);\n    };\n    const pause = () => {\n        if (trap) {\n            trap.pause();\n            isPaused.set(true);\n        }\n    };\n    const unpause = () => {\n        if (trap) {\n            trap.unpause();\n            isPaused.set(false);\n        }\n    };\n    const useFocusTrap = (node) => {\n        trap = _createFocusTrap(node, {\n            ...focusTrapOptions,\n            onActivate() {\n                hasFocus.set(true);\n                config.onActivate?.();\n            },\n            onDeactivate() {\n                hasFocus.set(false);\n                config.onDeactivate?.();\n            },\n        });\n        if (immediate) {\n            activate();\n        }\n        return {\n            destroy() {\n                deactivate();\n                trap = undefined;\n            },\n        };\n    };\n    return {\n        useFocusTrap,\n        hasFocus: readonly(hasFocus),\n        isPaused: readonly(isPaused),\n        activate,\n        deactivate,\n        pause,\n        unpause,\n    };\n}\n","import { isElement, last, noop, sleep } from '../../helpers/index.js';\nimport { useInteractOutside } from '../index.js';\nconst visibleModals = [];\nexport const useModal = ((node, config) => {\n    let unsubInteractOutside = noop;\n    function removeNodeFromVisibleModals() {\n        const index = visibleModals.indexOf(node);\n        if (index >= 0) {\n            visibleModals.splice(index, 1);\n        }\n    }\n    function update(config) {\n        unsubInteractOutside();\n        const { open, onClose, shouldCloseOnInteractOutside, closeOnInteractOutside } = config;\n        sleep(100).then(() => {\n            if (open) {\n                visibleModals.push(node);\n            }\n            else {\n                removeNodeFromVisibleModals();\n            }\n        });\n        function isLastModal() {\n            return last(visibleModals) === node;\n        }\n        function closeModal() {\n            // we only want to call onClose if this is the topmost modal\n            if (isLastModal() && onClose) {\n                onClose();\n                removeNodeFromVisibleModals();\n            }\n        }\n        function onInteractOutsideStart(e) {\n            const target = e.target;\n            if (!isElement(target))\n                return;\n            if (target && isLastModal()) {\n                e.preventDefault();\n                e.stopPropagation();\n                e.stopImmediatePropagation();\n            }\n        }\n        function onInteractOutside(e) {\n            if (shouldCloseOnInteractOutside?.(e) && isLastModal()) {\n                e.preventDefault();\n                e.stopPropagation();\n                e.stopImmediatePropagation();\n                closeModal();\n            }\n        }\n        unsubInteractOutside = useInteractOutside(node, {\n            onInteractOutsideStart,\n            onInteractOutside: closeOnInteractOutside ? onInteractOutside : undefined,\n            enabled: open,\n        }).destroy;\n    }\n    update(config);\n    return {\n        update,\n        destroy() {\n            removeNodeFromVisibleModals();\n            unsubInteractOutside();\n        },\n    };\n});\n","import { createFocusTrap, useEscapeKeydown, useFloating, usePortal, } from '../index.js';\nimport { executeCallbacks, noop, isHTMLElement, } from '../../helpers/index.js';\nimport { useModal } from '../modal/action.js';\nconst defaultConfig = {\n    floating: {},\n    focusTrap: {},\n    modal: {},\n    escapeKeydown: {},\n    portal: 'body',\n};\nexport const usePopper = ((popperElement, args) => {\n    popperElement.dataset.escapee = '';\n    const { anchorElement, open, options } = args;\n    if (!anchorElement || !open || !options) {\n        return { destroy: noop };\n    }\n    const opts = { ...defaultConfig, ...options };\n    const callbacks = [];\n    if (opts.portal !== null) {\n        callbacks.push(usePortal(popperElement, opts.portal).destroy);\n    }\n    callbacks.push(useFloating(anchorElement, popperElement, opts.floating).destroy);\n    if (opts.focusTrap !== null) {\n        const { useFocusTrap } = createFocusTrap({\n            immediate: true,\n            escapeDeactivates: false,\n            allowOutsideClick: true,\n            returnFocusOnDeactivate: false,\n            fallbackFocus: popperElement,\n            ...opts.focusTrap,\n        });\n        callbacks.push(useFocusTrap(popperElement).destroy);\n    }\n    if (opts.modal !== null) {\n        callbacks.push(useModal(popperElement, {\n            onClose: () => {\n                if (isHTMLElement(anchorElement)) {\n                    open.set(false);\n                    anchorElement.focus();\n                }\n            },\n            shouldCloseOnInteractOutside: (e) => {\n                if (e.defaultPrevented)\n                    return false;\n                if (isHTMLElement(anchorElement) && anchorElement.contains(e.target)) {\n                    return false;\n                }\n                return true;\n            },\n            ...opts.modal,\n        }).destroy);\n    }\n    if (opts.escapeKeydown !== null) {\n        callbacks.push(useEscapeKeydown(popperElement, {\n            enabled: open,\n            handler: () => {\n                open.set(false);\n            },\n            ...opts.escapeKeydown,\n        }).destroy);\n    }\n    // @ts-expect-error - This works and is correct, but TS doesn't like it\n    const unsubscribe = executeCallbacks(...callbacks);\n    return {\n        destroy() {\n            unsubscribe();\n        },\n    };\n});\n","import { tick } from 'svelte';\nimport { isHTMLElement, noop } from '../helpers/index.js';\nexport const usePortal = ((el, target = 'body') => {\n    let targetEl;\n    if (!isHTMLElement(target) && typeof target !== 'string') {\n        return {\n            destroy: noop,\n        };\n    }\n    async function update(newTarget) {\n        target = newTarget;\n        if (typeof target === 'string') {\n            targetEl = document.querySelector(target);\n            if (targetEl === null) {\n                await tick();\n                targetEl = document.querySelector(target);\n            }\n            if (targetEl === null) {\n                throw new Error(`No element found matching css selector: \"${target}\"`);\n            }\n        }\n        else if (target instanceof HTMLElement) {\n            targetEl = target;\n        }\n        else {\n            throw new TypeError(`Unknown portal target type: ${target === null ? 'null' : typeof target}. Allowed types: string (CSS selector) or HTMLElement.`);\n        }\n        el.dataset.portal = '';\n        targetEl.appendChild(el);\n        el.hidden = false;\n    }\n    function destroy() {\n        el.remove();\n    }\n    update(target);\n    return {\n        update,\n        destroy,\n    };\n});\n","import { addEventListener, isElement, executeCallbacks, noop, } from '../../helpers/index.js';\nexport const useInteractOutside = ((node, config) => {\n    let unsub = noop;\n    let unsubClick = noop;\n    let isPointerDown = false;\n    let isPointerDownInside = false;\n    let ignoreEmulatedMouseEvents = false;\n    function update(config) {\n        unsub();\n        unsubClick();\n        const { onInteractOutside, onInteractOutsideStart, enabled } = config;\n        if (!enabled)\n            return;\n        function onPointerDown(e) {\n            if (onInteractOutside && isValidEvent(e, node)) {\n                onInteractOutsideStart?.(e);\n            }\n            const target = e.target;\n            if (isElement(target) && isOrContainsTarget(node, target)) {\n                isPointerDownInside = true;\n            }\n            isPointerDown = true;\n        }\n        function triggerInteractOutside(e) {\n            onInteractOutside?.(e);\n        }\n        const documentObj = getOwnerDocument(node);\n        // Use pointer events if available, otherwise use mouse/touch events\n        if (typeof PointerEvent !== 'undefined') {\n            const onPointerUp = (e) => {\n                unsubClick();\n                const handler = (e) => {\n                    if (shouldTriggerInteractOutside(e)) {\n                        triggerInteractOutside(e);\n                    }\n                    resetPointerState();\n                };\n                /**\n                 * On touch devices, we need to wait for a click event because browsers implement\n                 * a delay between the time the user stops touching the display and when the\n                 * browser executes the click event. Without waiting for the click event, the\n                 * browser may execute events on other elements that should have been prevented.\n                 */\n                if (e.pointerType === 'touch') {\n                    unsubClick = addEventListener(documentObj, 'click', handler, {\n                        capture: true,\n                        once: true,\n                    });\n                    return;\n                }\n                handler(e);\n            };\n            unsub = executeCallbacks(addEventListener(documentObj, 'pointerdown', onPointerDown, true), addEventListener(documentObj, 'pointerup', onPointerUp, true));\n        }\n        else {\n            const onMouseUp = (e) => {\n                if (ignoreEmulatedMouseEvents) {\n                    ignoreEmulatedMouseEvents = false;\n                }\n                else if (shouldTriggerInteractOutside(e)) {\n                    triggerInteractOutside(e);\n                }\n                resetPointerState();\n            };\n            const onTouchEnd = (e) => {\n                ignoreEmulatedMouseEvents = true;\n                if (shouldTriggerInteractOutside(e)) {\n                    triggerInteractOutside(e);\n                }\n                resetPointerState();\n            };\n            unsub = executeCallbacks(addEventListener(documentObj, 'mousedown', onPointerDown, true), addEventListener(documentObj, 'mouseup', onMouseUp, true), addEventListener(documentObj, 'touchstart', onPointerDown, true), addEventListener(documentObj, 'touchend', onTouchEnd, true));\n        }\n    }\n    function shouldTriggerInteractOutside(e) {\n        if (isPointerDown && !isPointerDownInside && isValidEvent(e, node)) {\n            return true;\n        }\n        return false;\n    }\n    function resetPointerState() {\n        isPointerDown = false;\n        isPointerDownInside = false;\n    }\n    update(config);\n    return {\n        update,\n        destroy() {\n            unsub();\n            unsubClick();\n        },\n    };\n});\nfunction isValidEvent(e, node) {\n    if ('button' in e && e.button > 0)\n        return false;\n    const target = e.target;\n    if (!isElement(target))\n        return false;\n    // if the target is no longer in the document (e.g. it was removed) ignore it\n    const ownerDocument = target.ownerDocument;\n    if (!ownerDocument || !ownerDocument.documentElement.contains(target)) {\n        return false;\n    }\n    return node && !isOrContainsTarget(node, target);\n}\nfunction isOrContainsTarget(node, target) {\n    return node === target || node.contains(target);\n}\nfunction getOwnerDocument(el) {\n    return el?.ownerDocument ?? document;\n}\n","import { createElHelpers, makeElement } from '../../internal/helpers/makeElement.js';\nimport { readable } from 'svelte/store';\nimport { styleToString } from '../../internal/helpers/style.js';\nimport { toReadableStores } from '../../internal/helpers/store/toReadableStores.js';\nimport { omit } from '../../internal/helpers/object.js';\nimport { removeUndefined } from '../../internal/helpers/object.js';\nconst defaults = {\n    prefix: '',\n    disabled: readable(false),\n    required: readable(false),\n    name: readable(undefined),\n};\nexport function createHiddenInput(props) {\n    const withDefaults = {\n        ...defaults,\n        ...removeUndefined(props),\n    };\n    const { name: elName } = createElHelpers(withDefaults.prefix);\n    const { value, name, disabled, required } = toReadableStores(omit(withDefaults, 'prefix'));\n    const nameStore = name; // TODO: Remove this cast when types are fixed\n    const hiddenInput = makeElement(elName('hidden-input'), {\n        stores: [value, nameStore, disabled, required],\n        returned: ([$value, $name, $disabled, $required]) => {\n            return {\n                name: $name,\n                value: $value?.toString(),\n                'aria-hidden': 'true',\n                hidden: true,\n                disabled: $disabled,\n                required: $required,\n                tabIndex: -1,\n                style: styleToString({\n                    position: 'absolute',\n                    opacity: 0,\n                    'pointer-events': 'none',\n                    margin: 0,\n                    transform: 'translateX(-100%)',\n                }),\n            };\n        },\n        action: (node) => {\n            // When value changes, emit a change event\n            const unsub = value.subscribe((newValue) => {\n                node.value = newValue;\n                node.dispatchEvent(new Event('change', { bubbles: true }));\n            });\n            return {\n                destroy: unsub,\n            };\n        },\n    });\n    return hiddenInput;\n}\n","import { createSeparator } from '../index.js';\nimport { useEscapeKeydown, usePopper, usePortal } from '../../internal/actions/index.js';\nimport { FIRST_LAST_KEYS, SELECTION_KEYS, addEventListener, addHighlight, addMeltEventListener, makeElement, createElHelpers, createTypeaheadSearch, derivedVisible, disabledAttr, effect, executeCallbacks, generateIds, getNextFocusable, getPortalDestination, getPreviousFocusable, handleFocus, handleRovingFocus, isBrowser, isElementDisabled, isHTMLElement, kbd, noop, omit, overridable, removeHighlight, removeScroll, sleep, styleToString, toWritableStores, portalAttr, } from '../../internal/helpers/index.js';\nimport { tick } from 'svelte';\nimport { derived, writable } from 'svelte/store';\nimport { safeOnMount } from '../../internal/helpers/lifecycle.js';\nimport { withGet } from '../../internal/helpers/withGet.js';\nexport const SUB_OPEN_KEYS = {\n    ltr: [...SELECTION_KEYS, kbd.ARROW_RIGHT],\n    rtl: [...SELECTION_KEYS, kbd.ARROW_LEFT],\n};\nexport const SUB_CLOSE_KEYS = {\n    ltr: [kbd.ARROW_LEFT],\n    rtl: [kbd.ARROW_RIGHT],\n};\nexport const menuIdParts = ['menu', 'trigger'];\nconst defaults = {\n    arrowSize: 8,\n    positioning: {\n        placement: 'bottom',\n    },\n    preventScroll: true,\n    closeOnEscape: true,\n    closeOnOutsideClick: true,\n    portal: undefined,\n    loop: false,\n    dir: 'ltr',\n    defaultOpen: false,\n    typeahead: true,\n    closeOnItemClick: true,\n    onOutsideClick: undefined,\n};\nexport function createMenuBuilder(opts) {\n    const { name, selector } = createElHelpers(opts.selector);\n    const { preventScroll, arrowSize, positioning, closeOnEscape, closeOnOutsideClick, portal, forceVisible, typeahead, loop, closeFocus, disableFocusFirstItem, closeOnItemClick, onOutsideClick, } = opts.rootOptions;\n    const rootOpen = opts.rootOpen;\n    const rootActiveTrigger = opts.rootActiveTrigger;\n    /**\n     * Keeps track of the next/previous focusable element when the menu closes.\n     * This is because we are portaling the menu to the body and we need\n     * to be able to focus the next element in the DOM when the menu closes.\n     *\n     * Without keeping track of this, the focus would be reset to the top of\n     * the page (or the first focusable element in the body).\n     */\n    const nextFocusable = opts.nextFocusable;\n    const prevFocusable = opts.prevFocusable;\n    /**\n     * Keeps track of if the user is using the keyboard to navigate the menu.\n     * This is used to determine how we handle focus on open behavior differently\n     * than when the user is using the mouse.\n     */\n    const isUsingKeyboard = withGet.writable(false);\n    /**\n     * Stores used to manage the grace area for submenus. This prevents us\n     * from closing a submenu when the user is moving their mouse from the\n     * trigger to the submenu.\n     */\n    const lastPointerX = withGet(writable(0));\n    const pointerGraceIntent = withGet(writable(null));\n    const pointerDir = withGet(writable('right'));\n    /**\n     * Track currently focused item in the menu.\n     */\n    const currentFocusedItem = withGet(writable(null));\n    const pointerMovingToSubmenu = withGet(derived([pointerDir, pointerGraceIntent], ([$pointerDir, $pointerGraceIntent]) => {\n        return (e) => {\n            const isMovingTowards = $pointerDir === $pointerGraceIntent?.side;\n            return isMovingTowards && isPointerInGraceArea(e, $pointerGraceIntent?.area);\n        };\n    }));\n    const { typed, handleTypeaheadSearch } = createTypeaheadSearch();\n    const rootIds = toWritableStores({ ...generateIds(menuIdParts), ...opts.ids });\n    const isVisible = derivedVisible({\n        open: rootOpen,\n        forceVisible,\n        activeTrigger: rootActiveTrigger,\n    });\n    const rootMenu = makeElement(name(), {\n        stores: [isVisible, portal, rootIds.menu, rootIds.trigger],\n        returned: ([$isVisible, $portal, $rootMenuId, $rootTriggerId]) => {\n            return {\n                role: 'menu',\n                hidden: $isVisible ? undefined : true,\n                style: styleToString({\n                    display: $isVisible ? undefined : 'none',\n                }),\n                id: $rootMenuId,\n                'aria-labelledby': $rootTriggerId,\n                'data-state': $isVisible ? 'open' : 'closed',\n                'data-portal': portalAttr($portal),\n                tabindex: -1,\n            };\n        },\n        action: (node) => {\n            let unsubPopper = noop;\n            const unsubDerived = effect([isVisible, rootActiveTrigger, positioning, closeOnOutsideClick, portal, closeOnEscape], ([$isVisible, $rootActiveTrigger, $positioning, $closeOnOutsideClick, $portal, $closeOnEscape,]) => {\n                unsubPopper();\n                if (!$isVisible || !$rootActiveTrigger)\n                    return;\n                tick().then(() => {\n                    unsubPopper();\n                    setMeltMenuAttribute(node, selector);\n                    unsubPopper = usePopper(node, {\n                        anchorElement: $rootActiveTrigger,\n                        open: rootOpen,\n                        options: {\n                            floating: $positioning,\n                            modal: {\n                                closeOnInteractOutside: $closeOnOutsideClick,\n                                shouldCloseOnInteractOutside: (e) => {\n                                    onOutsideClick.get()?.(e);\n                                    if (e.defaultPrevented)\n                                        return false;\n                                    if (isHTMLElement($rootActiveTrigger) &&\n                                        $rootActiveTrigger.contains(e.target)) {\n                                        return false;\n                                    }\n                                    return true;\n                                },\n                                onClose: () => {\n                                    rootOpen.set(false);\n                                    $rootActiveTrigger.focus();\n                                },\n                                open: $isVisible,\n                            },\n                            portal: getPortalDestination(node, $portal),\n                            escapeKeydown: $closeOnEscape ? undefined : null,\n                        },\n                    }).destroy;\n                });\n            });\n            const unsubEvents = executeCallbacks(addMeltEventListener(node, 'keydown', (e) => {\n                const target = e.target;\n                const menuEl = e.currentTarget;\n                if (!isHTMLElement(target) || !isHTMLElement(menuEl))\n                    return;\n                /**\n                 * Submenu key events bubble through portals and\n                 * we only care about key events that happen inside this menu.\n                 */\n                const isKeyDownInside = target.closest('[role=\"menu\"]') === menuEl;\n                if (!isKeyDownInside)\n                    return;\n                if (FIRST_LAST_KEYS.includes(e.key)) {\n                    handleMenuNavigation(e, loop.get() ?? false);\n                }\n                /**\n                 * Menus should not be navigated using tab\n                 * @see https://www.w3.org/WAI/ARIA/apg/practices/keyboard-interface/#kbd_general_within\n                 */\n                if (e.key === kbd.TAB) {\n                    e.preventDefault();\n                    rootOpen.set(false);\n                    handleTabNavigation(e, nextFocusable, prevFocusable);\n                    return;\n                }\n                /**\n                 * Check for typeahead search and handle it.\n                 */\n                const isCharacterKey = e.key.length === 1;\n                const isModifierKey = e.ctrlKey || e.altKey || e.metaKey;\n                if (!isModifierKey && isCharacterKey && typeahead.get() === true) {\n                    handleTypeaheadSearch(e.key, getMenuItems(menuEl));\n                }\n            }));\n            return {\n                destroy() {\n                    unsubDerived();\n                    unsubEvents();\n                    unsubPopper();\n                },\n            };\n        },\n    });\n    const rootTrigger = makeElement(name('trigger'), {\n        stores: [rootOpen, rootIds.menu, rootIds.trigger],\n        returned: ([$rootOpen, $rootMenuId, $rootTriggerId]) => {\n            return {\n                'aria-controls': $rootMenuId,\n                'aria-expanded': $rootOpen,\n                'data-state': $rootOpen ? 'open' : 'closed',\n                id: $rootTriggerId,\n                tabindex: 0,\n            };\n        },\n        action: (node) => {\n            applyAttrsIfDisabled(node);\n            rootActiveTrigger.update((p) => {\n                if (p)\n                    return p;\n                return node;\n            });\n            const unsub = executeCallbacks(addMeltEventListener(node, 'click', (e) => {\n                const $rootOpen = rootOpen.get();\n                const triggerEl = e.currentTarget;\n                if (!isHTMLElement(triggerEl))\n                    return;\n                handleOpen(triggerEl);\n                if (!$rootOpen)\n                    e.preventDefault();\n            }), addMeltEventListener(node, 'keydown', (e) => {\n                const triggerEl = e.currentTarget;\n                if (!isHTMLElement(triggerEl))\n                    return;\n                if (!(SELECTION_KEYS.includes(e.key) || e.key === kbd.ARROW_DOWN))\n                    return;\n                e.preventDefault();\n                handleOpen(triggerEl);\n                const menuId = triggerEl.getAttribute('aria-controls');\n                if (!menuId)\n                    return;\n                const menu = document.getElementById(menuId);\n                if (!menu)\n                    return;\n                const menuItems = getMenuItems(menu);\n                if (!menuItems.length)\n                    return;\n                handleRovingFocus(menuItems[0]);\n            }));\n            return {\n                destroy: unsub,\n            };\n        },\n    });\n    const rootArrow = makeElement(name('arrow'), {\n        stores: arrowSize,\n        returned: ($arrowSize) => ({\n            'data-arrow': true,\n            style: styleToString({\n                position: 'absolute',\n                width: `var(--arrow-size, ${$arrowSize}px)`,\n                height: `var(--arrow-size, ${$arrowSize}px)`,\n            }),\n        }),\n    });\n    const overlay = makeElement(name('overlay'), {\n        stores: [isVisible],\n        returned: ([$isVisible]) => {\n            return {\n                hidden: $isVisible ? undefined : true,\n                tabindex: -1,\n                style: styleToString({\n                    display: $isVisible ? undefined : 'none',\n                }),\n                'aria-hidden': 'true',\n                'data-state': stateAttr($isVisible),\n            };\n        },\n        action: (node) => {\n            let unsubEscapeKeydown = noop;\n            if (closeOnEscape.get()) {\n                const escapeKeydown = useEscapeKeydown(node, {\n                    handler: () => {\n                        rootOpen.set(false);\n                        const $rootActiveTrigger = rootActiveTrigger.get();\n                        if ($rootActiveTrigger)\n                            $rootActiveTrigger.focus();\n                    },\n                });\n                if (escapeKeydown && escapeKeydown.destroy) {\n                    unsubEscapeKeydown = escapeKeydown.destroy;\n                }\n            }\n            const unsubPortal = effect([portal], ([$portal]) => {\n                if ($portal === null)\n                    return noop;\n                const portalDestination = getPortalDestination(node, $portal);\n                if (portalDestination === null)\n                    return noop;\n                return usePortal(node, portalDestination).destroy;\n            });\n            return {\n                destroy() {\n                    unsubEscapeKeydown();\n                    unsubPortal();\n                },\n            };\n        },\n    });\n    const item = makeElement(name('item'), {\n        returned: () => {\n            return {\n                role: 'menuitem',\n                tabindex: -1,\n                'data-orientation': 'vertical',\n            };\n        },\n        action: (node) => {\n            setMeltMenuAttribute(node, selector);\n            applyAttrsIfDisabled(node);\n            const unsub = executeCallbacks(addMeltEventListener(node, 'pointerdown', (e) => {\n                const itemEl = e.currentTarget;\n                if (!isHTMLElement(itemEl))\n                    return;\n                if (isElementDisabled(itemEl)) {\n                    e.preventDefault();\n                    return;\n                }\n            }), addMeltEventListener(node, 'click', (e) => {\n                const itemEl = e.currentTarget;\n                if (!isHTMLElement(itemEl))\n                    return;\n                if (isElementDisabled(itemEl)) {\n                    e.preventDefault();\n                    return;\n                }\n                if (e.defaultPrevented) {\n                    handleRovingFocus(itemEl);\n                    return;\n                }\n                if (closeOnItemClick.get()) {\n                    // Allows forms to submit before the menu is removed from the DOM\n                    sleep(1).then(() => {\n                        rootOpen.set(false);\n                    });\n                }\n            }), addMeltEventListener(node, 'keydown', (e) => {\n                onItemKeyDown(e);\n            }), addMeltEventListener(node, 'pointermove', (e) => {\n                onMenuItemPointerMove(e);\n            }), addMeltEventListener(node, 'pointerleave', (e) => {\n                onMenuItemPointerLeave(e);\n            }), addMeltEventListener(node, 'focusin', (e) => {\n                onItemFocusIn(e);\n            }), addMeltEventListener(node, 'focusout', (e) => {\n                onItemFocusOut(e);\n            }));\n            return {\n                destroy: unsub,\n            };\n        },\n    });\n    const group = makeElement(name('group'), {\n        returned: () => {\n            return (groupId) => ({\n                role: 'group',\n                'aria-labelledby': groupId,\n            });\n        },\n    });\n    const groupLabel = makeElement(name('group-label'), {\n        returned: () => {\n            return (groupId) => ({\n                id: groupId,\n            });\n        },\n    });\n    const checkboxItemDefaults = {\n        defaultChecked: false,\n        disabled: false,\n    };\n    const createCheckboxItem = (props) => {\n        const withDefaults = { ...checkboxItemDefaults, ...props };\n        const checkedWritable = withDefaults.checked ?? writable(withDefaults.defaultChecked ?? null);\n        const checked = overridable(checkedWritable, withDefaults.onCheckedChange);\n        const disabled = writable(withDefaults.disabled);\n        const checkboxItem = makeElement(name('checkbox-item'), {\n            stores: [checked, disabled],\n            returned: ([$checked, $disabled]) => {\n                return {\n                    role: 'menuitemcheckbox',\n                    tabindex: -1,\n                    'data-orientation': 'vertical',\n                    'aria-checked': isIndeterminate($checked) ? 'mixed' : $checked ? 'true' : 'false',\n                    'data-disabled': disabledAttr($disabled),\n                    'data-state': getCheckedState($checked),\n                };\n            },\n            action: (node) => {\n                setMeltMenuAttribute(node, selector);\n                applyAttrsIfDisabled(node);\n                const unsub = executeCallbacks(addMeltEventListener(node, 'pointerdown', (e) => {\n                    const itemEl = e.currentTarget;\n                    if (!isHTMLElement(itemEl))\n                        return;\n                    if (isElementDisabled(itemEl)) {\n                        e.preventDefault();\n                        return;\n                    }\n                }), addMeltEventListener(node, 'click', (e) => {\n                    const itemEl = e.currentTarget;\n                    if (!isHTMLElement(itemEl))\n                        return;\n                    if (isElementDisabled(itemEl)) {\n                        e.preventDefault();\n                        return;\n                    }\n                    if (e.defaultPrevented) {\n                        handleRovingFocus(itemEl);\n                        return;\n                    }\n                    checked.update((prev) => {\n                        if (isIndeterminate(prev))\n                            return true;\n                        return !prev;\n                    });\n                    if (closeOnItemClick.get()) {\n                        // We're waiting for a tick to let the checked store update\n                        // before closing the menu. If we don't, and the user was to hit\n                        // spacebar or enter twice really fast, the menu would close and\n                        // reopen without the checked state being updated.\n                        tick().then(() => {\n                            rootOpen.set(false);\n                        });\n                    }\n                }), addMeltEventListener(node, 'keydown', (e) => {\n                    onItemKeyDown(e);\n                }), addMeltEventListener(node, 'pointermove', (e) => {\n                    const itemEl = e.currentTarget;\n                    if (!isHTMLElement(itemEl))\n                        return;\n                    if (isElementDisabled(itemEl)) {\n                        onItemLeave(e);\n                        return;\n                    }\n                    onMenuItemPointerMove(e, itemEl);\n                }), addMeltEventListener(node, 'pointerleave', (e) => {\n                    onMenuItemPointerLeave(e);\n                }), addMeltEventListener(node, 'focusin', (e) => {\n                    onItemFocusIn(e);\n                }), addMeltEventListener(node, 'focusout', (e) => {\n                    onItemFocusOut(e);\n                }));\n                return {\n                    destroy: unsub,\n                };\n            },\n        });\n        const isChecked = derived(checked, ($checked) => $checked === true);\n        const _isIndeterminate = derived(checked, ($checked) => $checked === 'indeterminate');\n        return {\n            elements: {\n                checkboxItem,\n            },\n            states: {\n                checked,\n            },\n            helpers: {\n                isChecked,\n                isIndeterminate: _isIndeterminate,\n            },\n            options: {\n                disabled,\n            },\n        };\n    };\n    const createMenuRadioGroup = (args = {}) => {\n        const valueWritable = args.value ?? writable(args.defaultValue ?? null);\n        const value = overridable(valueWritable, args.onValueChange);\n        const radioGroup = makeElement(name('radio-group'), {\n            returned: () => ({\n                role: 'group',\n            }),\n        });\n        const radioItemDefaults = {\n            disabled: false,\n        };\n        const radioItem = makeElement(name('radio-item'), {\n            stores: [value],\n            returned: ([$value]) => {\n                return (itemProps) => {\n                    const { value: itemValue, disabled } = { ...radioItemDefaults, ...itemProps };\n                    const checked = $value === itemValue;\n                    return {\n                        disabled,\n                        role: 'menuitemradio',\n                        'data-state': checked ? 'checked' : 'unchecked',\n                        'aria-checked': checked,\n                        'data-disabled': disabledAttr(disabled),\n                        'data-value': itemValue,\n                        'data-orientation': 'vertical',\n                        tabindex: -1,\n                    };\n                };\n            },\n            action: (node) => {\n                setMeltMenuAttribute(node, selector);\n                const unsub = executeCallbacks(addMeltEventListener(node, 'pointerdown', (e) => {\n                    const itemEl = e.currentTarget;\n                    if (!isHTMLElement(itemEl))\n                        return;\n                    const itemValue = node.dataset.value;\n                    const disabled = node.dataset.disabled;\n                    if (disabled || itemValue === undefined) {\n                        e.preventDefault();\n                        return;\n                    }\n                }), addMeltEventListener(node, 'click', (e) => {\n                    const itemEl = e.currentTarget;\n                    if (!isHTMLElement(itemEl))\n                        return;\n                    const itemValue = node.dataset.value;\n                    const disabled = node.dataset.disabled;\n                    if (disabled || itemValue === undefined) {\n                        e.preventDefault();\n                        return;\n                    }\n                    if (e.defaultPrevented) {\n                        if (!isHTMLElement(itemEl))\n                            return;\n                        handleRovingFocus(itemEl);\n                        return;\n                    }\n                    value.set(itemValue);\n                    if (closeOnItemClick.get()) {\n                        // We're waiting for a tick to let the checked store update\n                        // before closing the menu. If we don't, and the user was to hit\n                        // spacebar or enter twice really fast, the menu would close and\n                        // reopen without the checked state being updated.\n                        tick().then(() => {\n                            rootOpen.set(false);\n                        });\n                    }\n                }), addMeltEventListener(node, 'keydown', (e) => {\n                    onItemKeyDown(e);\n                }), addMeltEventListener(node, 'pointermove', (e) => {\n                    const itemEl = e.currentTarget;\n                    if (!isHTMLElement(itemEl))\n                        return;\n                    const itemValue = node.dataset.value;\n                    const disabled = node.dataset.disabled;\n                    if (disabled || itemValue === undefined) {\n                        onItemLeave(e);\n                        return;\n                    }\n                    onMenuItemPointerMove(e, itemEl);\n                }), addMeltEventListener(node, 'pointerleave', (e) => {\n                    onMenuItemPointerLeave(e);\n                }), addMeltEventListener(node, 'focusin', (e) => {\n                    onItemFocusIn(e);\n                }), addMeltEventListener(node, 'focusout', (e) => {\n                    onItemFocusOut(e);\n                }));\n                return {\n                    destroy: unsub,\n                };\n            },\n        });\n        const isChecked = derived(value, ($value) => {\n            return (itemValue) => {\n                return $value === itemValue;\n            };\n        });\n        return {\n            elements: {\n                radioGroup,\n                radioItem,\n            },\n            states: {\n                value,\n            },\n            helpers: {\n                isChecked,\n            },\n        };\n    };\n    const { elements: { root: separator }, } = createSeparator({\n        orientation: 'horizontal',\n    });\n    /* -------------------------------------------------------------------------------------------------\n     * SUBMENU\n     * -----------------------------------------------------------------------------------------------*/\n    const subMenuDefaults = {\n        ...defaults,\n        disabled: false,\n        positioning: {\n            placement: 'right-start',\n            gutter: 8,\n        },\n    };\n    const createSubmenu = (args) => {\n        const withDefaults = { ...subMenuDefaults, ...args };\n        const subOpenWritable = withDefaults.open ?? writable(false);\n        const subOpen = overridable(subOpenWritable, withDefaults?.onOpenChange);\n        // options\n        const options = toWritableStores(omit(withDefaults, 'ids'));\n        const { positioning, arrowSize, disabled } = options;\n        const subActiveTrigger = withGet(writable(null));\n        const subOpenTimer = withGet(writable(null));\n        const pointerGraceTimer = withGet(writable(0));\n        const subIds = toWritableStores({ ...generateIds(menuIdParts), ...withDefaults.ids });\n        safeOnMount(() => {\n            /**\n             * Set active trigger on mount to handle controlled/forceVisible\n             * state.\n             */\n            const subTrigger = document.getElementById(subIds.trigger.get());\n            if (subTrigger) {\n                subActiveTrigger.set(subTrigger);\n            }\n        });\n        const subIsVisible = derivedVisible({\n            open: subOpen,\n            forceVisible,\n            activeTrigger: subActiveTrigger,\n        });\n        const subMenu = makeElement(name('submenu'), {\n            stores: [subIsVisible, subIds.menu, subIds.trigger],\n            returned: ([$subIsVisible, $subMenuId, $subTriggerId]) => {\n                return {\n                    role: 'menu',\n                    hidden: $subIsVisible ? undefined : true,\n                    style: styleToString({\n                        display: $subIsVisible ? undefined : 'none',\n                    }),\n                    id: $subMenuId,\n                    'aria-labelledby': $subTriggerId,\n                    'data-state': $subIsVisible ? 'open' : 'closed',\n                    // unit tests fail on `.closest` if the id starts with a number\n                    // so using a data attribute\n                    'data-id': $subMenuId,\n                    tabindex: -1,\n                };\n            },\n            action: (node) => {\n                let unsubPopper = noop;\n                const unsubDerived = effect([subIsVisible, positioning], ([$subIsVisible, $positioning]) => {\n                    unsubPopper();\n                    if (!$subIsVisible)\n                        return;\n                    const activeTrigger = subActiveTrigger.get();\n                    if (!activeTrigger)\n                        return;\n                    tick().then(() => {\n                        unsubPopper();\n                        const parentMenuEl = getParentMenu(activeTrigger);\n                        unsubPopper = usePopper(node, {\n                            anchorElement: activeTrigger,\n                            open: subOpen,\n                            options: {\n                                floating: $positioning,\n                                portal: isHTMLElement(parentMenuEl) ? parentMenuEl : undefined,\n                                modal: null,\n                                focusTrap: null,\n                                escapeKeydown: null,\n                            },\n                        }).destroy;\n                    });\n                });\n                const unsubEvents = executeCallbacks(addMeltEventListener(node, 'keydown', (e) => {\n                    if (e.key === kbd.ESCAPE) {\n                        return;\n                    }\n                    // Submenu key events bubble through portals.\n                    // We only want the keys in this menu.\n                    const target = e.target;\n                    const menuEl = e.currentTarget;\n                    if (!isHTMLElement(target) || !isHTMLElement(menuEl))\n                        return;\n                    const isKeyDownInside = target.closest('[role=\"menu\"]') === menuEl;\n                    if (!isKeyDownInside)\n                        return;\n                    if (FIRST_LAST_KEYS.includes(e.key)) {\n                        // prevent events from bubbling\n                        e.stopImmediatePropagation();\n                        handleMenuNavigation(e, loop.get() ?? false);\n                        return;\n                    }\n                    const isCloseKey = SUB_CLOSE_KEYS['ltr'].includes(e.key);\n                    const isModifierKey = e.ctrlKey || e.altKey || e.metaKey;\n                    const isCharacterKey = e.key.length === 1;\n                    // close the submenu if the user presses a close key\n                    if (isCloseKey) {\n                        const $subActiveTrigger = subActiveTrigger.get();\n                        e.preventDefault();\n                        subOpen.update(() => {\n                            if ($subActiveTrigger) {\n                                handleRovingFocus($subActiveTrigger);\n                            }\n                            return false;\n                        });\n                        return;\n                    }\n                    /**\n                     * Menus should not be navigated using tab, so we prevent it.\n                     * @see https://www.w3.org/WAI/ARIA/apg/practices/keyboard-interface/#kbd_general_within\n                     */\n                    if (e.key === kbd.TAB) {\n                        e.preventDefault();\n                        rootOpen.set(false);\n                        handleTabNavigation(e, nextFocusable, prevFocusable);\n                        return;\n                    }\n                    if (!isModifierKey && isCharacterKey && typeahead.get() === true) {\n                        // typeahead logic\n                        handleTypeaheadSearch(e.key, getMenuItems(menuEl));\n                    }\n                }), addMeltEventListener(node, 'pointermove', (e) => {\n                    onMenuPointerMove(e);\n                }), addMeltEventListener(node, 'focusout', (e) => {\n                    const $subActiveTrigger = subActiveTrigger.get();\n                    if (isUsingKeyboard.get()) {\n                        const target = e.target;\n                        const submenuEl = document.getElementById(subIds.menu.get());\n                        if (!isHTMLElement(submenuEl) || !isHTMLElement(target))\n                            return;\n                        if (!submenuEl.contains(target) && target !== $subActiveTrigger) {\n                            subOpen.set(false);\n                        }\n                    }\n                    else {\n                        const menuEl = e.currentTarget;\n                        const relatedTarget = e.relatedTarget;\n                        if (!isHTMLElement(relatedTarget) || !isHTMLElement(menuEl))\n                            return;\n                        if (!menuEl.contains(relatedTarget) && relatedTarget !== $subActiveTrigger) {\n                            subOpen.set(false);\n                        }\n                    }\n                }));\n                return {\n                    destroy() {\n                        unsubDerived();\n                        unsubPopper();\n                        unsubEvents();\n                    },\n                };\n            },\n        });\n        const subTrigger = makeElement(name('subtrigger'), {\n            stores: [subOpen, disabled, subIds.menu, subIds.trigger],\n            returned: ([$subOpen, $disabled, $subMenuId, $subTriggerId]) => {\n                return {\n                    role: 'menuitem',\n                    id: $subTriggerId,\n                    tabindex: -1,\n                    'aria-controls': $subMenuId,\n                    'aria-expanded': $subOpen,\n                    'data-state': $subOpen ? 'open' : 'closed',\n                    'data-disabled': disabledAttr($disabled),\n                    'aria-haspopop': 'menu',\n                };\n            },\n            action: (node) => {\n                setMeltMenuAttribute(node, selector);\n                applyAttrsIfDisabled(node);\n                subActiveTrigger.update((p) => {\n                    if (p)\n                        return p;\n                    return node;\n                });\n                const unsubTimer = () => {\n                    clearTimerStore(subOpenTimer);\n                    window.clearTimeout(pointerGraceTimer.get());\n                    pointerGraceIntent.set(null);\n                };\n                const unsubEvents = executeCallbacks(addMeltEventListener(node, 'click', (e) => {\n                    if (e.defaultPrevented)\n                        return;\n                    const triggerEl = e.currentTarget;\n                    if (!isHTMLElement(triggerEl) || isElementDisabled(triggerEl))\n                        return;\n                    // Manually focus because iOS Safari doesn't always focus on click (e.g. buttons)\n                    handleRovingFocus(triggerEl);\n                    if (!subOpen.get()) {\n                        subOpen.update((prev) => {\n                            const isAlreadyOpen = prev;\n                            if (!isAlreadyOpen) {\n                                subActiveTrigger.set(triggerEl);\n                                return !prev;\n                            }\n                            return prev;\n                        });\n                    }\n                }), addMeltEventListener(node, 'keydown', (e) => {\n                    const $typed = typed.get();\n                    const triggerEl = e.currentTarget;\n                    if (!isHTMLElement(triggerEl) || isElementDisabled(triggerEl))\n                        return;\n                    const isTypingAhead = $typed.length > 0;\n                    if (isTypingAhead && e.key === kbd.SPACE)\n                        return;\n                    if (SUB_OPEN_KEYS['ltr'].includes(e.key)) {\n                        if (!subOpen.get()) {\n                            triggerEl.click();\n                            e.preventDefault();\n                            return;\n                        }\n                        const menuId = triggerEl.getAttribute('aria-controls');\n                        if (!menuId)\n                            return;\n                        const menuEl = document.getElementById(menuId);\n                        if (!isHTMLElement(menuEl))\n                            return;\n                        const firstItem = getMenuItems(menuEl)[0];\n                        handleRovingFocus(firstItem);\n                    }\n                }), addMeltEventListener(node, 'pointermove', (e) => {\n                    if (!isMouse(e))\n                        return;\n                    onItemEnter(e);\n                    if (e.defaultPrevented)\n                        return;\n                    const triggerEl = e.currentTarget;\n                    if (!isHTMLElement(triggerEl))\n                        return;\n                    if (!isFocusWithinSubmenu(subIds.menu.get())) {\n                        handleRovingFocus(triggerEl);\n                    }\n                    const openTimer = subOpenTimer.get();\n                    if (!subOpen.get() && !openTimer && !isElementDisabled(triggerEl)) {\n                        subOpenTimer.set(window.setTimeout(() => {\n                            subOpen.update(() => {\n                                subActiveTrigger.set(triggerEl);\n                                return true;\n                            });\n                            clearTimerStore(subOpenTimer);\n                        }, 100));\n                    }\n                }), addMeltEventListener(node, 'pointerleave', (e) => {\n                    if (!isMouse(e))\n                        return;\n                    clearTimerStore(subOpenTimer);\n                    const submenuEl = document.getElementById(subIds.menu.get());\n                    const contentRect = submenuEl?.getBoundingClientRect();\n                    if (contentRect) {\n                        const side = submenuEl?.dataset.side;\n                        const rightSide = side === 'right';\n                        const bleed = rightSide ? -5 : +5;\n                        const contentNearEdge = contentRect[rightSide ? 'left' : 'right'];\n                        const contentFarEdge = contentRect[rightSide ? 'right' : 'left'];\n                        pointerGraceIntent.set({\n                            area: [\n                                // Apply a bleed on clientX to ensure that our exit point is\n                                // consistently within polygon bounds\n                                { x: e.clientX + bleed, y: e.clientY },\n                                { x: contentNearEdge, y: contentRect.top },\n                                { x: contentFarEdge, y: contentRect.top },\n                                { x: contentFarEdge, y: contentRect.bottom },\n                                { x: contentNearEdge, y: contentRect.bottom },\n                            ],\n                            side,\n                        });\n                        window.clearTimeout(pointerGraceTimer.get());\n                        pointerGraceTimer.set(window.setTimeout(() => {\n                            pointerGraceIntent.set(null);\n                        }, 300));\n                    }\n                    else {\n                        onTriggerLeave(e);\n                        if (e.defaultPrevented)\n                            return;\n                        // There's 100ms where the user may leave an item before the submenu was opened.\n                        pointerGraceIntent.set(null);\n                    }\n                }), addMeltEventListener(node, 'focusout', (e) => {\n                    const triggerEl = e.currentTarget;\n                    if (!isHTMLElement(triggerEl))\n                        return;\n                    removeHighlight(triggerEl);\n                    const relatedTarget = e.relatedTarget;\n                    if (!isHTMLElement(relatedTarget))\n                        return;\n                    const menuId = triggerEl.getAttribute('aria-controls');\n                    if (!menuId)\n                        return;\n                    const menu = document.getElementById(menuId);\n                    if (menu && !menu.contains(relatedTarget)) {\n                        subOpen.set(false);\n                    }\n                }), addMeltEventListener(node, 'focusin', (e) => {\n                    onItemFocusIn(e);\n                }));\n                return {\n                    destroy() {\n                        unsubTimer();\n                        unsubEvents();\n                    },\n                };\n            },\n        });\n        const subArrow = makeElement(name('subarrow'), {\n            stores: arrowSize,\n            returned: ($arrowSize) => ({\n                'data-arrow': true,\n                style: styleToString({\n                    position: 'absolute',\n                    width: `var(--arrow-size, ${$arrowSize}px)`,\n                    height: `var(--arrow-size, ${$arrowSize}px)`,\n                }),\n            }),\n        });\n        /* -------------------------------------------------------------------------------------------------\n         * Sub Menu Effects\n         * -----------------------------------------------------------------------------------------------*/\n        effect([rootOpen], ([$rootOpen]) => {\n            if (!$rootOpen) {\n                subActiveTrigger.set(null);\n                subOpen.set(false);\n            }\n        });\n        effect([pointerGraceIntent], ([$pointerGraceIntent]) => {\n            if (!isBrowser || $pointerGraceIntent)\n                return;\n            window.clearTimeout(pointerGraceTimer.get());\n        });\n        effect([subOpen], ([$subOpen]) => {\n            if (!isBrowser)\n                return;\n            if ($subOpen && isUsingKeyboard.get()) {\n                sleep(1).then(() => {\n                    const menuEl = document.getElementById(subIds.menu.get());\n                    if (!menuEl)\n                        return;\n                    const menuItems = getMenuItems(menuEl);\n                    if (!menuItems.length)\n                        return;\n                    handleRovingFocus(menuItems[0]);\n                });\n            }\n            if (!$subOpen) {\n                const focusedItem = currentFocusedItem.get();\n                const subTriggerEl = document.getElementById(subIds.trigger.get());\n                if (focusedItem) {\n                    sleep(1).then(() => {\n                        const menuEl = document.getElementById(subIds.menu.get());\n                        if (!menuEl)\n                            return;\n                        if (menuEl.contains(focusedItem)) {\n                            removeHighlight(focusedItem);\n                        }\n                    });\n                }\n                if (!subTriggerEl || document.activeElement === subTriggerEl)\n                    return;\n                removeHighlight(subTriggerEl);\n            }\n        });\n        return {\n            ids: subIds,\n            elements: {\n                subTrigger,\n                subMenu,\n                subArrow,\n            },\n            states: {\n                subOpen,\n            },\n            options,\n        };\n    };\n    safeOnMount(() => {\n        /**\n         * We need to set the active trigger on mount to cover the\n         * case where the user sets the `open` store to `true` without\n         * clicking on the trigger.\n         */\n        const triggerEl = document.getElementById(rootIds.trigger.get());\n        if (isHTMLElement(triggerEl) && rootOpen.get()) {\n            rootActiveTrigger.set(triggerEl);\n        }\n        const unsubs = [];\n        const handlePointer = () => isUsingKeyboard.set(false);\n        const handleKeyDown = () => {\n            isUsingKeyboard.set(true);\n            unsubs.push(executeCallbacks(addEventListener(document, 'pointerdown', handlePointer, { capture: true, once: true }), addEventListener(document, 'pointermove', handlePointer, { capture: true, once: true })));\n        };\n        const keydownListener = (e) => {\n            if (e.key === kbd.ESCAPE && closeOnEscape.get()) {\n                rootOpen.set(false);\n                return;\n            }\n        };\n        unsubs.push(addEventListener(document, 'keydown', handleKeyDown, { capture: true }));\n        unsubs.push(addEventListener(document, 'keydown', keydownListener));\n        return () => {\n            unsubs.forEach((unsub) => unsub());\n        };\n    });\n    /* -------------------------------------------------------------------------------------------------\n     * Root Effects\n     * -----------------------------------------------------------------------------------------------*/\n    effect([rootOpen, currentFocusedItem], ([$rootOpen, $currentFocusedItem]) => {\n        if (!$rootOpen && $currentFocusedItem) {\n            removeHighlight($currentFocusedItem);\n        }\n    });\n    effect([rootOpen], ([$rootOpen]) => {\n        if (!isBrowser)\n            return;\n        if (!$rootOpen) {\n            const $rootActiveTrigger = rootActiveTrigger.get();\n            if (!$rootActiveTrigger)\n                return;\n            const $closeFocus = closeFocus.get();\n            if (!$rootOpen && $rootActiveTrigger) {\n                handleFocus({ prop: $closeFocus, defaultEl: $rootActiveTrigger });\n            }\n        }\n    });\n    effect([rootOpen, preventScroll], ([$rootOpen, $preventScroll]) => {\n        if (!isBrowser)\n            return;\n        const unsubs = [];\n        if (opts.removeScroll && $rootOpen && $preventScroll) {\n            unsubs.push(removeScroll());\n        }\n        // if the menu is open, we'll sleep for a sec so the menu can render\n        // before we focus on either the first item or the menu itself.\n        sleep(1).then(() => {\n            const menuEl = document.getElementById(rootIds.menu.get());\n            if (menuEl && $rootOpen && isUsingKeyboard.get()) {\n                if (disableFocusFirstItem.get()) {\n                    handleRovingFocus(menuEl);\n                    return;\n                }\n                // Get menu items belonging to the root menu\n                const menuItems = getMenuItems(menuEl);\n                if (!menuItems.length)\n                    return;\n                // Focus on first menu item\n                handleRovingFocus(menuItems[0]);\n            }\n        });\n        return () => {\n            unsubs.forEach((unsub) => unsub());\n        };\n    });\n    effect(rootOpen, ($rootOpen) => {\n        if (!isBrowser)\n            return;\n        const handlePointer = () => isUsingKeyboard.set(false);\n        const handleKeyDown = (e) => {\n            isUsingKeyboard.set(true);\n            if (e.key === kbd.ESCAPE && $rootOpen && closeOnEscape.get()) {\n                rootOpen.set(false);\n                return;\n            }\n        };\n        return executeCallbacks(addEventListener(document, 'pointerdown', handlePointer, { capture: true, once: true }), addEventListener(document, 'pointermove', handlePointer, { capture: true, once: true }), addEventListener(document, 'keydown', handleKeyDown, { capture: true }));\n    });\n    function handleOpen(triggerEl) {\n        rootOpen.update((prev) => {\n            const isOpen = !prev;\n            if (isOpen) {\n                nextFocusable.set(getNextFocusable(triggerEl));\n                prevFocusable.set(getPreviousFocusable(triggerEl));\n                rootActiveTrigger.set(triggerEl);\n            }\n            return isOpen;\n        });\n    }\n    /* -------------------------------------------------------------------------------------------------\n     * Pointer Event Effects\n     * -----------------------------------------------------------------------------------------------*/\n    function onItemFocusIn(e) {\n        const itemEl = e.currentTarget;\n        if (!isHTMLElement(itemEl))\n            return;\n        const $currentFocusedItem = currentFocusedItem.get();\n        if ($currentFocusedItem) {\n            removeHighlight($currentFocusedItem);\n        }\n        addHighlight(itemEl);\n        /**\n         * Accomodates for Firefox focus event behavior, which differs\n         * from other browsers. We're setting the current focused item\n         * so when we close the menu, we can remove the data-highlighted\n         * attribute from the item, since a blur nor focusout event will be fired\n         * when the menu is closed via `clickOutside` or the ESC key.\n         */\n        currentFocusedItem.set(itemEl);\n    }\n    /**\n     * Each of the menu items share the same focusout event handler.\n     */\n    function onItemFocusOut(e) {\n        const itemEl = e.currentTarget;\n        if (!isHTMLElement(itemEl))\n            return;\n        removeHighlight(itemEl);\n    }\n    function onItemEnter(e) {\n        if (isPointerMovingToSubmenu(e)) {\n            e.preventDefault();\n        }\n    }\n    function onItemLeave(e) {\n        if (isPointerMovingToSubmenu(e)) {\n            return;\n        }\n        const target = e.target;\n        if (!isHTMLElement(target))\n            return;\n        const parentMenuEl = getParentMenu(target);\n        if (!parentMenuEl)\n            return;\n        handleRovingFocus(parentMenuEl);\n    }\n    function onTriggerLeave(e) {\n        if (isPointerMovingToSubmenu(e)) {\n            e.preventDefault();\n        }\n    }\n    function onMenuPointerMove(e) {\n        if (!isMouse(e))\n            return;\n        const target = e.target;\n        const currentTarget = e.currentTarget;\n        if (!isHTMLElement(currentTarget) || !isHTMLElement(target))\n            return;\n        const $lastPointerX = lastPointerX.get();\n        const pointerXHasChanged = $lastPointerX !== e.clientX;\n        // We don't use `e.movementX` for this check because Safari will\n        // always return `0` on a pointer e.\n        if (currentTarget.contains(target) && pointerXHasChanged) {\n            const newDir = e.clientX > $lastPointerX ? 'right' : 'left';\n            pointerDir.set(newDir);\n            lastPointerX.set(e.clientX);\n        }\n    }\n    function onMenuItemPointerMove(e, currTarget = null) {\n        if (!isMouse(e))\n            return;\n        onItemEnter(e);\n        if (e.defaultPrevented)\n            return;\n        // if we've already checked the current target, we don't need to again\n        if (currTarget) {\n            handleRovingFocus(currTarget);\n            return;\n        }\n        // otherwise we will\n        const currentTarget = e.currentTarget;\n        if (!isHTMLElement(currentTarget))\n            return;\n        // focus on the current menu item\n        handleRovingFocus(currentTarget);\n    }\n    function onMenuItemPointerLeave(e) {\n        if (!isMouse(e))\n            return;\n        onItemLeave(e);\n    }\n    /* -------------------------------------------------------------------------------------------------\n     * Helper Functions\n     * -----------------------------------------------------------------------------------------------*/\n    function onItemKeyDown(e) {\n        const $typed = typed.get();\n        const isTypingAhead = $typed.length > 0;\n        if (isTypingAhead && e.key === kbd.SPACE) {\n            e.preventDefault();\n            return;\n        }\n        if (SELECTION_KEYS.includes(e.key)) {\n            /**\n             * We prevent default browser behaviour for selection keys as they should trigger\n             * a selection only:\n             * - prevents space from scrolling the page.\n             * - if keydown causes focus to move, prevents keydown from firing on the new target.\n             */\n            e.preventDefault();\n            const itemEl = e.currentTarget;\n            if (!isHTMLElement(itemEl))\n                return;\n            itemEl.click();\n        }\n    }\n    function isIndeterminate(checked) {\n        return checked === 'indeterminate';\n    }\n    function getCheckedState(checked) {\n        return isIndeterminate(checked) ? 'indeterminate' : checked ? 'checked' : 'unchecked';\n    }\n    function isPointerMovingToSubmenu(e) {\n        return pointerMovingToSubmenu.get()(e);\n    }\n    /**\n     * Get the parent menu element for a menu item.\n     * @param element The menu item element\n     */\n    function getParentMenu(element) {\n        const parentMenuEl = element.closest('[role=\"menu\"]');\n        if (!isHTMLElement(parentMenuEl))\n            return null;\n        return parentMenuEl;\n    }\n    return {\n        elements: {\n            trigger: rootTrigger,\n            menu: rootMenu,\n            overlay,\n            item,\n            group,\n            groupLabel,\n            arrow: rootArrow,\n            separator,\n        },\n        builders: {\n            createCheckboxItem,\n            createSubmenu,\n            createMenuRadioGroup,\n        },\n        states: {\n            open: rootOpen,\n        },\n        helpers: {\n            handleTypeaheadSearch,\n        },\n        ids: rootIds,\n        options: opts.rootOptions,\n    };\n}\nexport function handleTabNavigation(e, nextFocusable, prevFocusable) {\n    if (e.shiftKey) {\n        const $prevFocusable = prevFocusable.get();\n        if ($prevFocusable) {\n            e.preventDefault();\n            sleep(1).then(() => $prevFocusable.focus());\n            prevFocusable.set(null);\n        }\n    }\n    else {\n        const $nextFocusable = nextFocusable.get();\n        if ($nextFocusable) {\n            e.preventDefault();\n            sleep(1).then(() => $nextFocusable.focus());\n            nextFocusable.set(null);\n        }\n    }\n}\n/**\n * Get the menu items for a given menu element.\n * This only selects menu items that are direct children of the menu element,\n * not menu items that are nested in submenus.\n * @param element The menu item element\n */\nexport function getMenuItems(menuElement) {\n    return Array.from(menuElement.querySelectorAll(`[data-melt-menu-id=\"${menuElement.id}\"]`)).filter((item) => isHTMLElement(item));\n}\nexport function applyAttrsIfDisabled(element) {\n    if (!element || !isElementDisabled(element))\n        return;\n    element.setAttribute('data-disabled', '');\n    element.setAttribute('aria-disabled', 'true');\n}\n/**\n * Given a timer store, clear the timeout and set the store to null\n * @param openTimer The timer store\n */\nexport function clearTimerStore(timerStore) {\n    if (!isBrowser)\n        return;\n    const timer = timerStore.get();\n    if (timer) {\n        window.clearTimeout(timer);\n        timerStore.set(null);\n    }\n}\n/**\n * Check if the event is a mouse event\n * @param e The pointer event\n */\nfunction isMouse(e) {\n    return e.pointerType === 'mouse';\n}\n/**\n * Set the `data-melt-menu-id` attribute on a menu item element.\n * @param element The menu item element\n */\nexport function setMeltMenuAttribute(element, selector) {\n    if (!element)\n        return;\n    const menuEl = element.closest(`${selector()}, ${selector('submenu')}`);\n    if (!isHTMLElement(menuEl))\n        return;\n    element.setAttribute('data-melt-menu-id', menuEl.id);\n}\n/**\n * Keyboard event handler for menu navigation\n * @param e The keyboard event\n */\nexport function handleMenuNavigation(e, loop) {\n    e.preventDefault();\n    // currently focused menu item\n    const currentFocusedItem = document.activeElement;\n    // menu element being navigated\n    const currentTarget = e.currentTarget;\n    if (!isHTMLElement(currentFocusedItem) || !isHTMLElement(currentTarget))\n        return;\n    // menu items of the current menu\n    const menuItems = getMenuItems(currentTarget);\n    if (!menuItems.length)\n        return;\n    const candidateNodes = menuItems.filter((item) => {\n        if (item.hasAttribute('data-disabled') || item.getAttribute('disabled') === 'true') {\n            return false;\n        }\n        return true;\n    });\n    // Index of the currently focused item in the candidate nodes array\n    const currentIndex = candidateNodes.indexOf(currentFocusedItem);\n    // Calculate the index of the next menu item\n    let nextIndex;\n    switch (e.key) {\n        case kbd.ARROW_DOWN:\n            if (loop) {\n                nextIndex = currentIndex < candidateNodes.length - 1 ? currentIndex + 1 : 0;\n            }\n            else {\n                nextIndex = currentIndex < candidateNodes.length - 1 ? currentIndex + 1 : currentIndex;\n            }\n            break;\n        case kbd.ARROW_UP:\n            if (loop) {\n                nextIndex = currentIndex > 0 ? currentIndex - 1 : candidateNodes.length - 1;\n            }\n            else {\n                nextIndex =\n                    currentIndex < 0 ? candidateNodes.length - 1 : currentIndex > 0 ? currentIndex - 1 : 0;\n            }\n            break;\n        case kbd.HOME:\n            nextIndex = 0;\n            break;\n        case kbd.END:\n            nextIndex = candidateNodes.length - 1;\n            break;\n        default:\n            return;\n    }\n    handleRovingFocus(candidateNodes[nextIndex]);\n}\nfunction isPointerInGraceArea(e, area) {\n    if (!area)\n        return false;\n    const cursorPos = { x: e.clientX, y: e.clientY };\n    return isPointInPolygon(cursorPos, area);\n}\n/**\n * Determine if a point is inside of a polygon.\n *\n * @see https://github.com/substack/point-in-polygon\n */\nfunction isPointInPolygon(point, polygon) {\n    const { x, y } = point;\n    let inside = false;\n    for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {\n        const xi = polygon[i].x;\n        const yi = polygon[i].y;\n        const xj = polygon[j].x;\n        const yj = polygon[j].y;\n        // prettier-ignore\n        const intersect = ((yi > y) !== (yj > y)) && (x < (xj - xi) * (y - yi) / (yj - yi) + xi);\n        if (intersect)\n            inside = !inside;\n    }\n    return inside;\n}\nfunction isFocusWithinSubmenu(submenuId) {\n    const activeEl = document.activeElement;\n    if (!isHTMLElement(activeEl))\n        return false;\n    // unit tests don't allow `.closest(#id)` to start with a number\n    // so we're using a data attribute.\n    const submenuEl = activeEl.closest(`[data-id=\"${submenuId}\"]`);\n    return isHTMLElement(submenuEl);\n}\nfunction stateAttr(open) {\n    return open ? 'open' : 'closed';\n}\n","import { addMeltEventListener, makeElement, createElHelpers, effect, executeCallbacks, generateIds, isBrowser, isHTMLElement, isValidIndex, kbd, omit, overridable, styleToString, toWritableStores, withGet, } from '../../internal/helpers/index.js';\nimport { createFormatter, createMonths, dateStore, getAnnouncer, getDefaultDate, getSelectableCells, isAfter, isBefore, isCalendarCell, parseStringToDateValue, setPlaceholderToNodeValue, toDate, } from '../../internal/helpers/date/index.js';\nimport { getLocalTimeZone, isSameDay, isSameMonth, isToday, } from '@internationalized/date';\nimport { tick } from 'svelte';\nimport { derived, writable } from 'svelte/store';\nexport const defaults = {\n    isDateDisabled: undefined,\n    isDateUnavailable: undefined,\n    value: undefined,\n    preventDeselect: false,\n    numberOfMonths: 1,\n    pagedNavigation: false,\n    weekStartsOn: 0,\n    fixedWeeks: false,\n    calendarLabel: 'Event Date',\n    locale: 'en',\n    minValue: undefined,\n    maxValue: undefined,\n    disabled: false,\n    readonly: false,\n    weekdayFormat: 'narrow',\n};\nconst { name } = createElHelpers('calendar');\nexport const calendarIdParts = ['calendar', 'accessibleHeading'];\nexport function createCalendar(props) {\n    const withDefaults = { ...defaults, ...props };\n    const options = toWritableStores({\n        ...omit(withDefaults, 'value', 'placeholder', 'multiple', 'ids'),\n        multiple: withDefaults.multiple ?? false,\n    });\n    const { preventDeselect, numberOfMonths, pagedNavigation, weekStartsOn, fixedWeeks, calendarLabel, locale, minValue, maxValue, multiple, isDateUnavailable, disabled, readonly, weekdayFormat, } = options;\n    const ids = toWritableStores({ ...generateIds(calendarIdParts), ...withDefaults.ids });\n    const defaultDate = getDefaultDate({\n        defaultPlaceholder: withDefaults.defaultPlaceholder,\n        defaultValue: withDefaults.defaultValue,\n    });\n    const formatter = createFormatter(withDefaults.locale);\n    const valueWritable = withDefaults.value ?? writable(withDefaults.defaultValue);\n    const value = overridable(valueWritable, withDefaults.onValueChange);\n    const placeholderWritable = withDefaults.placeholder ?? writable(withDefaults.defaultPlaceholder ?? defaultDate);\n    const placeholder = dateStore(overridable(placeholderWritable, withDefaults.onPlaceholderChange), withDefaults.defaultPlaceholder ?? defaultDate);\n    /**\n     * A store containing the months to display in the calendar.\n     */\n    const months = withGet(writable(createMonths({\n        dateObj: placeholder.get(),\n        weekStartsOn: withDefaults.weekStartsOn,\n        locale: withDefaults.locale,\n        fixedWeeks: withDefaults.fixedWeeks,\n        numberOfMonths: withDefaults.numberOfMonths,\n    })));\n    /**\n     * A derived store that maintains the currently visible months in the calendar,\n     * which we use to determine how keyboard navigation and if we should apply\n     * `data-outside-month` to cells.\n     */\n    const visibleMonths = withGet.derived([months], ([$months]) => {\n        return $months.map((month) => {\n            return month.value;\n        });\n    });\n    const isOutsideVisibleMonths = derived([visibleMonths], ([$visibleMonths]) => {\n        return (date) => {\n            return !$visibleMonths.some((month) => isSameMonth(date, month));\n        };\n    });\n    const isNextButtonDisabled = withGet.derived([months, maxValue, disabled], ([$months, $maxValue, $disabled]) => {\n        if (!$maxValue || !$months.length)\n            return false;\n        if ($disabled)\n            return true;\n        const lastMonthInView = $months[$months.length - 1].value;\n        const firstMonthOfNextPage = lastMonthInView.add({ months: 1 }).set({ day: 1 });\n        return isAfter(firstMonthOfNextPage, $maxValue);\n    });\n    const isPrevButtonDisabled = withGet.derived([months, minValue, disabled], ([$months, $minValue, $disabled]) => {\n        if (!$minValue || !$months.length)\n            return false;\n        if ($disabled)\n            return true;\n        const firstMonthInView = $months[0].value;\n        const lastMonthOfPrevPage = firstMonthInView.subtract({ months: 1 }).set({ day: 35 });\n        return isBefore(lastMonthOfPrevPage, $minValue);\n    });\n    /**\n     * A derived store function that determines if a date is disabled based\n     * on the `isDateDisabled` prop, `minValue`, and `maxValue` props.\n     */\n    const isDateDisabled = withGet.derived([options.isDateDisabled, minValue, maxValue, disabled], ([$isDateDisabled, $minValue, $maxValue, $disabled]) => {\n        return (date) => {\n            if ($isDateDisabled?.(date) || $disabled)\n                return true;\n            if ($minValue && isBefore(date, $minValue))\n                return true;\n            if ($maxValue && isBefore($maxValue, date))\n                return true;\n            return false;\n        };\n    });\n    const isDateSelected = derived([value], ([$value]) => {\n        return (date) => {\n            if (Array.isArray($value)) {\n                return $value.some((d) => isSameDay(d, date));\n            }\n            else if (!$value) {\n                return false;\n            }\n            else {\n                return isSameDay($value, date);\n            }\n        };\n    });\n    /**\n     * A derived helper store that evaluates to true if a currently selected date is invalid.\n     */\n    const isInvalid = derived([value, isDateDisabled, options.isDateUnavailable], ([$value, $isDateDisabled, $isDateUnavailable]) => {\n        if (Array.isArray($value)) {\n            if (!$value.length)\n                return false;\n            for (const date of $value) {\n                if ($isDateDisabled?.(date))\n                    return true;\n                if ($isDateUnavailable?.(date))\n                    return true;\n            }\n        }\n        else {\n            if (!$value)\n                return false;\n            if ($isDateDisabled?.($value))\n                return true;\n            if ($isDateUnavailable?.($value))\n                return true;\n        }\n        return false;\n    });\n    /**\n     * Initialize the announcer, which currently remains inactive in this context since it will\n     * be server-side rendered, but we'll initialize it in the calendar's action.\n     *\n     * The announcer is in charge of providing `aria-live` announcements for the calendar,\n     * such as when a date is selected.\n     */\n    let announcer = getAnnouncer();\n    /**\n     * The current heading value for the calendar, meant to be utilized with\n     * the {@link heading} builder.\n     * It renders the current displayed month and year, formatted for the current locale.\n     * This value updates automatically as the user navigates the calendar, even when\n     * displaying multiple months using the `numberOfMonths` prop.\n     */\n    const headingValue = withGet.derived([months, locale], ([$months, $locale]) => {\n        if (!$months.length)\n            return '';\n        if ($locale !== formatter.getLocale()) {\n            formatter.setLocale($locale);\n        }\n        if ($months.length === 1) {\n            const month = $months[0].value;\n            return `${formatter.fullMonthAndYear(toDate(month))}`;\n        }\n        const startMonth = toDate($months[0].value);\n        const endMonth = toDate($months[$months.length - 1].value);\n        const startMonthName = formatter.fullMonth(startMonth);\n        const endMonthName = formatter.fullMonth(endMonth);\n        const startMonthYear = formatter.fullYear(startMonth);\n        const endMonthYear = formatter.fullYear(endMonth);\n        const content = startMonthYear === endMonthYear\n            ? `${startMonthName} - ${endMonthName} ${endMonthYear}`\n            : `${startMonthName} ${startMonthYear} - ${endMonthName} ${endMonthYear}`;\n        return content;\n    });\n    /**\n     * The accessible heading label for the calendar, generated by combining the `calendarLabel`\n     * prop and the `headingValue` store to create a label like `Event Date, January 2021`.\n     */\n    const fullCalendarLabel = withGet.derived([headingValue, calendarLabel], ([$headingValue, $calendarLabel]) => {\n        return `${$calendarLabel}, ${$headingValue}`;\n    });\n    /**\n     * The root element of the calendar, capable of housing multiple grids/months\n     * when using paged navigation.\n     */\n    const calendar = makeElement(name(), {\n        stores: [fullCalendarLabel, isInvalid, disabled, readonly, ids.calendar],\n        returned: ([$fullCalendarLabel, $isInvalid, $disabled, $readonly, $calendarId]) => {\n            return {\n                id: $calendarId,\n                role: 'application',\n                'aria-label': $fullCalendarLabel,\n                'data-invalid': $isInvalid ? '' : undefined,\n                'data-disabled': $disabled ? '' : undefined,\n                'data-readonly': $readonly ? '' : undefined,\n            };\n        },\n        action: (node) => {\n            /**\n             * Generates the accessible calendar heading when the grid is mounted.\n             * The label is dynamically updated through an effect whenever there\n             * are changes in the active date or label.\n             */\n            createAccessibleHeading(node, fullCalendarLabel.get());\n            announcer = getAnnouncer();\n            const unsubKb = addMeltEventListener(node, 'keydown', handleCalendarKeydown);\n            return {\n                destroy() {\n                    unsubKb();\n                },\n            };\n        },\n    });\n    /**\n     * The calendar heading, visually displaying the current month and year. This heading\n     * is hidden from screen readers as an accessible heading is automatically generated\n     * for the calendar.\n     *\n     * To customize the accessible heading's prefix, use the `calendarLabel` prop. By default,\n     * the accessible heading reads as `Event Date, January 2021` for January 2021. If you set\n     * the `calendarLabel` prop to 'Booking Date', the accessible heading will be 'Booking Date,\n     * January 2021' for the same month and year.\n     */\n    const heading = makeElement(name('heading'), {\n        stores: [disabled],\n        returned: ([$disabled]) => {\n            return {\n                'aria-hidden': true,\n                'data-disabled': $disabled ? '' : undefined,\n            };\n        },\n    });\n    /**\n     * A grid element that serves as a container for a single month in the calendar.\n     * Grids should be rendered for each month present in the `months` store returned\n     * by the `createCalendar` builder.\n     *\n     * For more details about the structure of the month object, refer to {@link Month}.\n     */\n    const grid = makeElement(name('grid'), {\n        stores: [readonly, disabled],\n        returned: ([$readonly, $disabled]) => {\n            return {\n                tabindex: -1,\n                role: 'grid',\n                'aria-readonly': $readonly ? 'true' : undefined,\n                'aria-disabled': $disabled ? 'true' : undefined,\n                'data-readonly': $readonly ? '' : undefined,\n                'data-disabled': $disabled ? '' : undefined,\n            };\n        },\n    });\n    /**\n     * The 'prev' button for the calendar, enabling navigation to the\n     * previous page. In paged navigation mode, it moves the calendar\n     * back by the number of months specified in the `numberOfMonths` prop.\n     * In non-paged mode, it shifts the calendar back by one month.\n     */\n    const prevButton = makeElement(name('prevButton'), {\n        stores: [isPrevButtonDisabled],\n        returned: ([$isPrevButtonDisabled]) => {\n            const disabled = $isPrevButtonDisabled;\n            return {\n                role: 'button',\n                type: 'button',\n                'aria-label': 'Previous',\n                'aria-disabled': disabled ? 'true' : undefined,\n                'data-disabled': disabled ? '' : undefined,\n                disabled: disabled ? true : undefined,\n            };\n        },\n        action: (node) => {\n            const unsub = executeCallbacks(addMeltEventListener(node, 'click', () => {\n                if (isPrevButtonDisabled.get())\n                    return;\n                prevPage();\n            }));\n            return {\n                destroy: unsub,\n            };\n        },\n    });\n    /**\n     * A button element designed for navigating to the next page of the calendar.\n     * If using paged navigation, it advances the calendar by the number of months\n     * specified in the `numberOfMonths` prop. If not using paged navigation, it\n     * moves the calendar forward by one month.\n     */\n    const nextButton = makeElement(name('nextButton'), {\n        stores: [isNextButtonDisabled],\n        returned: ([$isNextButtonDisabled]) => {\n            const disabled = $isNextButtonDisabled;\n            return {\n                role: 'button',\n                type: 'button',\n                'aria-label': 'Next',\n                'aria-disabled': disabled ? 'true' : undefined,\n                'data-disabled': disabled ? '' : undefined,\n                disabled: disabled ? true : undefined,\n            };\n        },\n        action: (node) => {\n            const unsub = executeCallbacks(addMeltEventListener(node, 'click', () => {\n                if (isNextButtonDisabled.get())\n                    return;\n                nextPage();\n            }));\n            return {\n                destroy: unsub,\n            };\n        },\n    });\n    /**\n     * Represents an individual date cell in the calendar grid,\n     * signifying a single day within the month. Configured with\n     * essential attributes and event handlers for accessibility\n     * and interactivity.\n     */\n    const cell = makeElement(name('cell'), {\n        stores: [\n            isDateSelected,\n            isDateDisabled,\n            isDateUnavailable,\n            isOutsideVisibleMonths,\n            placeholder,\n        ],\n        returned: ([$isDateSelected, $isDateDisabled, $isDateUnavailable, $isOutsideVisibleMonths, $placeholder,]) => {\n            /**\n             * Applies the appropriate attributes to each date cell in the calendar.\n             *\n             * @params cellValue - The `DateValue` for the current cell.\n             * @params monthValue - The `DateValue` for the current month, which is used\n             * to determine if the current cell is outside the current month.\n             */\n            return (cellValue, monthValue) => {\n                const cellDate = toDate(cellValue);\n                const isDisabled = $isDateDisabled?.(cellValue);\n                const isUnavailable = $isDateUnavailable?.(cellValue);\n                const isDateToday = isToday(cellValue, getLocalTimeZone());\n                const isOutsideMonth = !isSameMonth(cellValue, monthValue);\n                const isOutsideVisibleMonths = $isOutsideVisibleMonths(cellValue);\n                const isFocusedDate = isSameDay(cellValue, $placeholder);\n                const isSelectedDate = $isDateSelected(cellValue);\n                const labelText = formatter.custom(cellDate, {\n                    weekday: 'long',\n                    month: 'long',\n                    day: 'numeric',\n                    year: 'numeric',\n                });\n                return {\n                    role: 'button',\n                    'aria-label': labelText,\n                    'aria-selected': isSelectedDate ? true : undefined,\n                    'aria-disabled': isOutsideMonth || isDisabled || isUnavailable ? true : undefined,\n                    'data-selected': isSelectedDate ? true : undefined,\n                    'data-value': cellValue.toString(),\n                    'data-disabled': isDisabled || isOutsideMonth ? '' : undefined,\n                    'data-unavailable': isUnavailable ? '' : undefined,\n                    'data-today': isDateToday ? '' : undefined,\n                    'data-outside-month': isOutsideMonth ? '' : undefined,\n                    'data-outside-visible-months': isOutsideVisibleMonths ? '' : undefined,\n                    'data-focused': isFocusedDate ? '' : undefined,\n                    tabindex: isFocusedDate ? 0 : isOutsideMonth || isDisabled ? undefined : -1,\n                };\n            };\n        },\n        action: (node) => {\n            const getElArgs = () => {\n                const value = node.getAttribute('data-value');\n                const label = node.getAttribute('data-label');\n                const disabled = node.hasAttribute('data-disabled');\n                return {\n                    value,\n                    label: label ?? node.textContent ?? null,\n                    disabled: disabled ? true : false,\n                };\n            };\n            const unsub = executeCallbacks(addMeltEventListener(node, 'click', () => {\n                const args = getElArgs();\n                if (args.disabled)\n                    return;\n                if (!args.value)\n                    return;\n                handleCellClick(parseStringToDateValue(args.value, placeholder.get()));\n            }));\n            return {\n                destroy: unsub,\n            };\n        },\n    });\n    /**\n     * Synchronize the locale used within the formatter to ensure\n     * dynamic updates are reflected in the calendar.\n     */\n    effect([locale], ([$locale]) => {\n        if (formatter.getLocale() === $locale)\n            return;\n        formatter.setLocale($locale);\n    });\n    /**\n     * Updates the displayed months based on changes in the placeholder value,\n     * which determines the months to show in the calendar.\n     */\n    effect([placeholder], ([$placeholder]) => {\n        if (!isBrowser || !$placeholder)\n            return;\n        const $visibleMonths = visibleMonths.get();\n        /**\n         * If the placeholder's month is already in the visible months,\n         * we don't need to do anything.\n         */\n        if ($visibleMonths.some((month) => isSameMonth(month, $placeholder))) {\n            return;\n        }\n        const $weekStartsOn = weekStartsOn.get();\n        const $locale = locale.get();\n        const $fixedWeeks = fixedWeeks.get();\n        const $numberOfMonths = numberOfMonths.get();\n        const defaultMonthProps = {\n            weekStartsOn: $weekStartsOn,\n            locale: $locale,\n            fixedWeeks: $fixedWeeks,\n            numberOfMonths: $numberOfMonths,\n        };\n        months.set(createMonths({\n            ...defaultMonthProps,\n            dateObj: $placeholder,\n        }));\n    });\n    /**\n     * Updates the displayed months based on changes in the the options values,\n     * which determines the months to show in the calendar.\n     */\n    effect([weekStartsOn, locale, fixedWeeks, numberOfMonths], ([$weekStartsOn, $locale, $fixedWeeks, $numberOfMonths]) => {\n        const $placeholder = placeholder.get();\n        if (!isBrowser || !$placeholder)\n            return;\n        const defaultMonthProps = {\n            weekStartsOn: $weekStartsOn,\n            locale: $locale,\n            fixedWeeks: $fixedWeeks,\n            numberOfMonths: $numberOfMonths,\n        };\n        months.set(createMonths({\n            ...defaultMonthProps,\n            dateObj: $placeholder,\n        }));\n    });\n    /**\n     * Update the accessible heading's text content when the\n     * `fullCalendarLabel` store changes.\n     */\n    effect([fullCalendarLabel], ([$fullCalendarLabel]) => {\n        if (!isBrowser)\n            return;\n        const node = document.getElementById(ids.accessibleHeading.get());\n        if (!isHTMLElement(node))\n            return;\n        node.textContent = $fullCalendarLabel;\n    });\n    /**\n     * Synchronizing the placeholder value with the current value.\n     */\n    effect([value], ([$value]) => {\n        if (Array.isArray($value) && $value.length) {\n            const lastValue = $value[$value.length - 1];\n            if (lastValue && placeholder.get() !== lastValue) {\n                placeholder.set(lastValue);\n            }\n        }\n        else if (!Array.isArray($value) && $value && placeholder.get() !== $value) {\n            placeholder.set($value);\n        }\n    });\n    /**\n     * This derived store holds an array of localized day names for the current\n     * locale and calendar view. It dynamically syncs with the 'weekStartsOn' option,\n     * updating its content when the option changes. Using this store to render the\n     * calendar's days of the week is strongly recommended, as it guarantees that\n     * the days are correctly formatted for the current locale and calendar view.\n     *\n     * @example\n     * ```svelte\n     * <table use:melt={$grid} class=\"w-full\">\n     * \t<thead aria-hidden=\"true\">\n     * \t\t<tr>\n     * \t\t\t{#each $weekdays as day}\n     * \t\t\t\t<th class=\"text-sm font-semibold text-magnum-800\">\n     * \t\t\t\t\t<div class=\"flex h-6 w-6 items-center justify-center p-4\">\n     * \t\t\t\t\t\t{day}\n     * \t\t\t\t\t</div>\n     * \t\t\t\t</th>\n     * \t\t\t{/each}\n     * \t\t</tr>\n     * \t</thead>\n     * \t<!-- ... -->\n     * </table>\n     * ```\n     *\n     * If you prefer to format/render the days of the week yourself,\n     * you can do so by accessing the first week of the first month,\n     * and mapping over the dates to get/format each day of the week.\n     *\n     * @example\n     * ```svelte\n     * {#each $months as month}\n     * \t<table use:melt={$grid} class=\"w-full\">\n     * \t\t<thead aria-hidden=\"true\">\n     * \t\t\t<tr>\n     * \t\t\t\t{#each month.weeks[0] as dayOfWeek}\n     * \t\t\t\t\t<th class=\"text-sm font-semibold text-magnum-800\">\n     * \t\t\t\t\t\t<div class=\"flex h-6 w-6 items-center justify-center p-4\">\n     * \t\t\t\t\t\t\t{new Intl.DateTimeFormat('en', { weekday: 'long' }).format\n     * \t\t\t\t\t\t\t(dayOfWeek)}\n     * \t\t\t\t\t\t</div>\n     * \t\t\t\t\t</th>\n     * \t\t\t\t{/each}\n     * \t\t\t</tr>\n     * \t\t</thead>\n     * \t\t<!-- ... -->\n     * \t</table>\n     * {/each}\n     * ```\n     *\n     */\n    const weekdays = derived([months, weekdayFormat, locale], ([$months, $weekdayFormat, _]) => {\n        if (!$months.length)\n            return [];\n        return $months[0].weeks[0].map((date) => {\n            return formatter.dayOfWeek(toDate(date), $weekdayFormat);\n        });\n    });\n    /**\n     * Creates an accessible heading for the calendar, ensuring that\n     * when it is focused by a screen reader, the displayed date range\n     * is announced. This approach maintains accessibility for screen\n     * readers while keeping the heading hidden from the visual design\n     * of the calendar.\n     */\n    function createAccessibleHeading(node, label) {\n        if (!isBrowser)\n            return;\n        const div = document.createElement('div');\n        div.style.cssText = styleToString({\n            border: '0px',\n            clip: 'rect(0px, 0px, 0px, 0px)',\n            'clip-path': 'inset(50%)',\n            height: '1px',\n            margin: '-1px',\n            overflow: 'hidden',\n            padding: '0px',\n            position: 'absolute',\n            'white-space': 'nowrap',\n            width: '1px',\n        });\n        const h2 = document.createElement('div');\n        h2.textContent = label;\n        h2.id = ids.accessibleHeading.get();\n        h2.role = 'heading';\n        h2.ariaLevel = '2';\n        node.insertBefore(div, node.firstChild);\n        div.appendChild(h2);\n    }\n    /**\n     * Navigate to the next page of the calendar.\n     *\n     * @remarks\n     * If using paged navigation, this will move the calendar forward\n     * by the number of months specified in the `numberOfMonths` prop.\n     * If not using paged navigation, this will move the calendar forward\n     * by one month.\n     *\n     * @example\n     * ```svelte\n     * <script>\n     * \timport { createCalendar } from '@melt-ui/svelte';\n     * \tconst { { ... }, helpers: { nextPage } } = createCalendar()\n     * </script>\n     *\n     * <button on:click={nextPage} aria-label=\"Next page\"></button>\n     * ```\n     */\n    function nextPage() {\n        const $months = months.get();\n        const $numberOfMonths = numberOfMonths.get();\n        if (pagedNavigation.get()) {\n            const firstMonth = $months[0].value;\n            placeholder.set(firstMonth.add({ months: $numberOfMonths }));\n        }\n        else {\n            const firstMonth = $months[0].value;\n            const newMonths = createMonths({\n                dateObj: firstMonth.add({ months: 1 }),\n                weekStartsOn: weekStartsOn.get(),\n                locale: locale.get(),\n                fixedWeeks: fixedWeeks.get(),\n                numberOfMonths: $numberOfMonths,\n            });\n            months.set(newMonths);\n            placeholder.set(newMonths[0].value.set({ day: 1 }));\n        }\n    }\n    /**\n     * Navigate to the previous page of the calendar.\n     *\n     * @remarks\n     * A helper function to navigate to the previous page of the calendar.\n     * If using paged navigation, this will move the calendar backwards\n     * by the number of months specified in the `numberOfMonths` prop.\n     * If not using paged navigation, this will move the calendar backwards\n     * by one month.\n     *\n     * @example\n     * ```svelte\n     * <script>\n     * \timport { createCalendar } from '@melt-ui/svelte';\n     * \tconst { { ... }, helpers: { prevPage } } = createCalendar()\n     * </script>\n     *\n     * <button on:click={prevPage} aria-label=\"Previous page\"></button>\n     * ```\n     */\n    function prevPage() {\n        const $months = months.get();\n        const $numberOfMonths = numberOfMonths.get();\n        if (pagedNavigation.get()) {\n            const firstMonth = $months[0].value;\n            placeholder.set(firstMonth.subtract({ months: $numberOfMonths }));\n        }\n        else {\n            const firstMonth = $months[0].value;\n            const newMonths = createMonths({\n                dateObj: firstMonth.subtract({ months: 1 }),\n                weekStartsOn: weekStartsOn.get(),\n                locale: locale.get(),\n                fixedWeeks: fixedWeeks.get(),\n                numberOfMonths: $numberOfMonths,\n            });\n            months.set(newMonths);\n            placeholder.set(newMonths[0].value.set({ day: 1 }));\n        }\n    }\n    /**\n     * Navigate to the next year in the calendar.\n     *\n     * @remarks\n     * A helper function to navigate to the next year in the calendar,\n     * which is useful if you want to extend the calendar to have buttons\n     * to navigate to the next/prev year.\n     *\n     * @example\n     * ```svelte\n     * <script>\n     * \timport { createCalendar } from '@melt-ui/svelte';\n     * \tconst { { ... }, helpers: { nextYear, prevYear } } = createCalendar()\n     * </script>\n     *\n     * <button on:click={prevYear} aria-label=\"Previous year\"></button>\n     * <button on:click={nextYear} aria-label=\"Next year\"></button>\n     *\n     * ```\n     */\n    function nextYear() {\n        placeholder.add({ years: 1 });\n    }\n    /**\n     * A helper function to navigate to the previous year in the calendar,\n     * which is useful if you want to extend the calendar to have buttons\n     * to navigate to the next/prev year.\n     *\n     * @example\n     * ```svelte\n     * <script>\n     * \timport { createCalendar } from '@melt-ui/svelte';\n     * \tconst { { ... }, helpers: { nextYear, prevYear } } = createCalendar()\n     * </script>\n     *\n     * <button on:click={prevYear} aria-label=\"Previous year\"></button>\n     * <button on:click={nextYear} aria-label=\"Next year\"></button>\n     *\n     * ```\n     */\n    function prevYear() {\n        placeholder.subtract({ years: 1 });\n    }\n    const ARROW_KEYS = [kbd.ARROW_DOWN, kbd.ARROW_UP, kbd.ARROW_LEFT, kbd.ARROW_RIGHT];\n    /**\n     * Set the year of the calendar to the specified year.\n     *\n     * @remarks\n     * This is useful if you want to extend the calendar to have\n     * alternative ways to change the year, such as a select input.\n     *\n     * @example\n     * ```svelte\n     * <script>\n     * \timport { createCalendar } from '@melt-ui/svelte';\n     * \tconst { { ... }, helpers: { setYear } } = createCalendar()\n     *\n     * \tlet selectValue = 2023;\n     * \t$: setYear(selectValue);\n     * </script>\n     *\n     * <select bind:value={selectValue} aria-label='Select a year'>\n     * \t<option value={2023}>2023</option>\n     * \t<option value={2024}>2024</option>\n     * \t<option value={2025}>2025</option>\n     * \t<!-- ... -->\n     * </select>\n     * ```\n     */\n    function setYear(year) {\n        placeholder.setDate({ year: year });\n    }\n    /**\n     * Set the month of the calendar to the specified month.\n     *\n     * @remarks\n     * This is useful if you want to extend the calendar to have\n     * alternative ways to change the month, such as a select input.\n     *\n     * @example\n     * ```svelte\n     * <script>\n     * \timport { createCalendar } from '@melt-ui/svelte';\n     * \tconst { { ... }, helpers: { setMonth } } = createCalendar()\n     *\n     * \tlet selectValue = 1;\n     * \t$: setMonth(selectValue);\n     * </script>\n     *\n     * <select bind:value={selectValue} aria-label='Select a month'>\n     * \t<option value={1}>January</option>\n     * \t<option value={2}>February</option>\n     * \t<option value={3}>March</option>\n     * \t<!-- ... -->\n     * </select>\n     * ```\n     */\n    function setMonth(month) {\n        placeholder.setDate({ month: month });\n    }\n    function handleCellClick(date) {\n        const $readonly = readonly.get();\n        if ($readonly)\n            return;\n        const $isDateDisabled = isDateDisabled.get();\n        const $isUnavailable = options.isDateUnavailable.get();\n        if ($isDateDisabled?.(date) || $isUnavailable?.(date))\n            return;\n        value.update((prev) => {\n            const $multiple = multiple.get();\n            if ($multiple) {\n                return handleMultipleUpdate(prev, date);\n            }\n            else {\n                const next = handleSingleUpdate(prev, date);\n                if (!next) {\n                    announcer.announce('Selected date is now empty.', 'polite', 5000);\n                }\n                else {\n                    announcer.announce(`Selected Date: ${formatter.selectedDate(next, false)}`, 'polite');\n                }\n                return next;\n            }\n        });\n    }\n    function handleSingleUpdate(prev, date) {\n        if (Array.isArray(prev))\n            throw new Error('Invalid value for multiple prop.');\n        if (!prev)\n            return date;\n        const $preventDeselect = preventDeselect.get();\n        if (!$preventDeselect && isSameDay(prev, date)) {\n            placeholder.set(date);\n            return undefined;\n        }\n        return date;\n    }\n    function handleMultipleUpdate(prev, date) {\n        if (!prev)\n            return [date];\n        if (!Array.isArray(prev))\n            throw new Error('Invalid value for multiple prop.');\n        const index = prev.findIndex((d) => isSameDay(d, date));\n        const $preventDeselect = preventDeselect.get();\n        if (index === -1) {\n            return [...prev, date];\n        }\n        else if ($preventDeselect) {\n            return prev;\n        }\n        else {\n            const next = prev.filter((d) => !isSameDay(d, date));\n            if (!next.length) {\n                placeholder.set(date);\n                return undefined;\n            }\n            return next;\n        }\n    }\n    const SELECT_KEYS = [kbd.ENTER, kbd.SPACE];\n    function handleCalendarKeydown(e) {\n        const currentCell = e.target;\n        if (!isCalendarCell(currentCell))\n            return;\n        if (!ARROW_KEYS.includes(e.key) && !SELECT_KEYS.includes(e.key))\n            return;\n        e.preventDefault();\n        // the cell that is currently focused\n        if (e.key === kbd.ARROW_DOWN) {\n            shiftFocus(currentCell, 7);\n        }\n        if (e.key === kbd.ARROW_UP) {\n            shiftFocus(currentCell, -7);\n        }\n        if (e.key === kbd.ARROW_LEFT) {\n            shiftFocus(currentCell, -1);\n        }\n        if (e.key === kbd.ARROW_RIGHT) {\n            shiftFocus(currentCell, 1);\n        }\n        if (e.key === kbd.SPACE || e.key === kbd.ENTER) {\n            const cellValue = currentCell.getAttribute('data-value');\n            if (!cellValue)\n                return;\n            handleCellClick(parseStringToDateValue(cellValue, placeholder.get()));\n        }\n    }\n    function shiftFocus(node, add) {\n        const candidateCells = getSelectableCells(ids.calendar.get());\n        if (!candidateCells.length)\n            return;\n        const index = candidateCells.indexOf(node);\n        const nextIndex = index + add;\n        /**\n         * If the next cell is within the bounds of the\n         * displayed/rendered cells, easy day, just focus it.\n         */\n        if (isValidIndex(nextIndex, candidateCells)) {\n            const nextCell = candidateCells[nextIndex];\n            setPlaceholderToNodeValue(nextCell, placeholder);\n            return nextCell.focus();\n        }\n        /**\n         * When the next cell falls outside the displayed/rendered cells range,\n         * we update the focus to the previous or next month based on the direction,\n         * and then focus on the relevant cell.\n         */\n        if (nextIndex < 0) {\n            /**\n             * To handle negative index values, we rewind by one month,\n             * retrieve candidate cells for that month, and shift the focus\n             * by the difference between the nextIndex starting from the end\n             * of the array.\n             */\n            // shift the calendar back a month unless previous month is disabled\n            if (isPrevButtonDisabled.get())\n                return;\n            const $months = months.get();\n            const firstMonth = $months[0].value;\n            const $numberOfMonths = numberOfMonths.get();\n            placeholder.set(firstMonth.subtract({ months: $numberOfMonths }));\n            // Without a tick here, it seems to be too fast for\n            // the DOM to update, with the tick it works great\n            tick().then(() => {\n                const newCandidateCells = getSelectableCells(ids.calendar.get());\n                if (!newCandidateCells.length) {\n                    return;\n                }\n                /**\n                 * Starting at the end of the array, shift focus by the\n                 * difference between the nextIndex and the length of the\n                 * array, since the nextIndex is negative.\n                 */\n                const newIndex = newCandidateCells.length - Math.abs(nextIndex);\n                if (isValidIndex(newIndex, newCandidateCells)) {\n                    const newCell = newCandidateCells[newIndex];\n                    setPlaceholderToNodeValue(newCell, placeholder);\n                    return newCell.focus();\n                }\n            });\n        }\n        if (nextIndex >= candidateCells.length) {\n            /**\n             * Since we're in the positive index range, we need to\n             * go forward a month, refetch the candidate cells within that\n             * month, and then starting at the beginning of that array,\n             * shift focus by the nextIndex amount.\n             */\n            // shift the calendar forward a month unless next month is disabled\n            if (isNextButtonDisabled.get())\n                return;\n            const $months = months.get();\n            const firstMonth = $months[0].value;\n            const $numberOfMonths = numberOfMonths.get();\n            placeholder.set(firstMonth.add({ months: $numberOfMonths }));\n            tick().then(() => {\n                const newCandidateCells = getSelectableCells(ids.calendar.get());\n                if (!newCandidateCells.length) {\n                    return;\n                }\n                /**\n                 * We need to determine how far into the next month we need to go\n                 * to get the next index. So if we only went over the previous\n                 * month by 1, we need to go into the next month by 1 to get the\n                 * right index.\n                 */\n                const newIndex = nextIndex - candidateCells.length;\n                if (isValidIndex(newIndex, newCandidateCells)) {\n                    const nextCell = newCandidateCells[newIndex];\n                    return nextCell.focus();\n                }\n            });\n        }\n    }\n    /**\n     * A helper function to determine if a date cell is disabled,\n     * which uses the `Matcher`(s) provided via the `isDisabled`\n     * prop, as well as other internal logic, such as if it's\n     * outside of the month, or if it's before/after the min/max\n     * values.\n     *\n     * Although we set attributes on the cells themselves, for\n     * easy styling this function is useful when you want to\n     * conditionally handle something outside of the cell,\n     * such as its wrapping element.\n     *\n     * @example\n     * ```svelte\n     * {#each dates as date}\n     * \t<td role=\"gridcell\" aria-disabled={$isDisabled(date)}>\n     * \t\t<!-- ... -->\n     * \t</td>\n     * {/each}\n     * ```\n     *\n     * @param date - The `DateValue` to check\n     * @returns `true` if the date is disabled, `false` otherwise\n     */\n    const _isDateDisabled = derived([isDateDisabled, placeholder, minValue, maxValue, disabled], ([$isDateDisabled, $placeholder, $minValue, $maxValue, $disabled]) => {\n        return (date) => {\n            if ($isDateDisabled?.(date) || $disabled)\n                return true;\n            if ($minValue && isBefore(date, $minValue))\n                return true;\n            if ($maxValue && isAfter(date, $maxValue))\n                return true;\n            if (!isSameMonth(date, $placeholder))\n                return true;\n            return false;\n        };\n    });\n    /**\n     * A helper function to determine if a date is unavailable,\n     * which uses the `Matcher`(s) provided via the `unavailable`\n     * prop.\n     *\n     * Although we set attributes on the cells themselves, this\n     * function is useful when you want to conditionally handle\n     * something outside of the cell, such as its wrapping element.\n     *\n     * @example\n     * ```svelte\n     * {#each dates as date}\n     * \t<td role=\"gridcell\">\n     * \t\t{#if $isUnavailable(date)}\n     * \t\t\t<span>X</span>\n     * \t\t{/if}\n     * \t\t<!-- ... -->\n     * \t</td>\n     * {/each}\n     * ```\n     *\n     * @param date - The `DateValue` to check\n     * @returns `true` if the date is disabled, `false` otherwise\n     */\n    const _isDateUnavailable = derived(isDateUnavailable, ($isDateUnavailable) => {\n        return (date) => $isDateUnavailable?.(date);\n    });\n    return {\n        elements: {\n            calendar,\n            heading,\n            grid,\n            cell,\n            nextButton,\n            prevButton,\n        },\n        states: {\n            placeholder: placeholder.toWritable(),\n            months,\n            value,\n            weekdays,\n            headingValue,\n        },\n        helpers: {\n            nextPage,\n            prevPage,\n            nextYear,\n            prevYear,\n            setYear,\n            setMonth,\n            isDateDisabled: _isDateDisabled,\n            isDateSelected,\n            isDateUnavailable: _isDateUnavailable,\n        },\n        options,\n        ids,\n    };\n}\n","import { createCalendar, createDateField, createPopover } from '../index.js';\nimport { handleSegmentNavigation, isSegmentNavigationKey, } from '../../internal/helpers/date/index.js';\nimport { addMeltEventListener, makeElement, effect, omit, toWritableStores, } from '../../internal/helpers/index.js';\nimport { pickerOpenFocus } from '../../internal/helpers/date/focus.js';\nimport { createFormatter, dateStore, getDefaultDate } from '../../internal/helpers/date/index.js';\nimport { defaults as calendarDefaults } from '../calendar/create.js';\nconst defaults = {\n    isDateDisabled: undefined,\n    isDateUnavailable: undefined,\n    value: undefined,\n    positioning: {\n        placement: 'bottom',\n    },\n    closeOnEscape: true,\n    closeOnOutsideClick: true,\n    onOutsideClick: undefined,\n    preventScroll: false,\n    forceVisible: false,\n    locale: 'en',\n    granularity: undefined,\n    disabled: false,\n    readonly: false,\n    minValue: undefined,\n    maxValue: undefined,\n    weekdayFormat: 'narrow',\n    ...omit(calendarDefaults, 'isDateDisabled', 'isDateUnavailable', 'value', 'locale', 'disabled', 'readonly', 'minValue', 'maxValue', 'weekdayFormat'),\n};\nexport function createDatePicker(props) {\n    const withDefaults = { ...defaults, ...props };\n    const options = toWritableStores(omit(withDefaults, 'value', 'placeholder'));\n    const dateField = createDateField({\n        ...withDefaults,\n        ids: withDefaults.dateFieldIds,\n    });\n    const { states: { value, placeholder: dfPlaceholder }, } = dateField;\n    const calendar = createCalendar({\n        ...omit(withDefaults, 'onValueChange'),\n        placeholder: dfPlaceholder,\n        value: value,\n        ids: withDefaults.calendarIds,\n    });\n    const popover = createPopover({\n        positioning: withDefaults.positioning,\n        arrowSize: withDefaults.arrowSize,\n        defaultOpen: withDefaults.defaultOpen,\n        open: withDefaults.open,\n        disableFocusTrap: withDefaults.disableFocusTrap,\n        closeOnEscape: withDefaults.closeOnEscape,\n        preventScroll: withDefaults.preventScroll,\n        onOpenChange: withDefaults.onOpenChange,\n        closeOnOutsideClick: withDefaults.closeOnOutsideClick,\n        portal: withDefaults.portal,\n        forceVisible: withDefaults.forceVisible,\n        openFocus: pickerOpenFocus,\n        ids: withDefaults.popoverIds,\n        onOutsideClick: withDefaults.onOutsideClick,\n    });\n    const trigger = makeElement('popover-trigger', {\n        stores: [popover.elements.trigger, options.disabled],\n        returned: ([$trigger, $disabled]) => {\n            return {\n                ...omit($trigger, 'action'),\n                'aria-label': 'Open date picker',\n                'data-segment': 'trigger',\n                disabled: $disabled ? true : undefined,\n            };\n        },\n        action: (node) => {\n            const unsubKeydown = addMeltEventListener(node, 'keydown', handleTriggerKeydown);\n            const { destroy } = popover.elements.trigger(node);\n            return {\n                destroy() {\n                    destroy?.();\n                    unsubKeydown();\n                },\n            };\n        },\n    });\n    const formatter = createFormatter(options.locale.get());\n    effect([options.locale], ([$locale]) => {\n        dateField.options.locale.set($locale);\n        calendar.options.locale.set($locale);\n        if (formatter.getLocale() === $locale)\n            return;\n        formatter.setLocale($locale);\n    });\n    effect([options.weekdayFormat], ([$weekdayFormat]) => {\n        calendar.options.weekdayFormat.set($weekdayFormat);\n    });\n    effect([options.disabled], ([$disabled]) => {\n        dateField.options.disabled.set($disabled);\n        calendar.options.disabled.set($disabled);\n    });\n    effect([options.readonly], ([$readonly]) => {\n        dateField.options.readonly.set($readonly);\n        calendar.options.readonly.set($readonly);\n    });\n    effect([options.minValue], ([$minValue]) => {\n        dateField.options.minValue.set($minValue);\n        calendar.options.minValue.set($minValue);\n    });\n    effect([options.maxValue], ([$maxValue]) => {\n        dateField.options.maxValue.set($maxValue);\n        calendar.options.maxValue.set($maxValue);\n    });\n    effect([options.numberOfMonths], ([$numberOfMonths]) => {\n        calendar.options.numberOfMonths.set($numberOfMonths);\n    });\n    effect([options.fixedWeeks], ([$fixedWeeks]) => {\n        calendar.options.fixedWeeks.set($fixedWeeks);\n    });\n    effect([options.weekStartsOn], ([$weekStartsOn]) => {\n        calendar.options.weekStartsOn.set($weekStartsOn);\n    });\n    const dateFieldOptions = omit(dateField.options, 'locale', 'disabled', 'readonly', 'minValue', 'maxValue');\n    const calendarOptions = omit(calendar.options, 'locale', 'disabled', 'readonly', 'minValue', 'maxValue');\n    const { states: { open }, } = popover;\n    const defaultDate = getDefaultDate({\n        defaultPlaceholder: withDefaults.defaultPlaceholder,\n        defaultValue: withDefaults.defaultValue,\n        granularity: withDefaults.granularity,\n    });\n    const placeholder = dateStore(dfPlaceholder, withDefaults.defaultPlaceholder ?? defaultDate);\n    effect([open], ([$open]) => {\n        if (!$open) {\n            const $value = value.get();\n            if ($value) {\n                placeholder.set($value);\n            }\n            else {\n                placeholder.reset();\n            }\n        }\n    });\n    function handleTriggerKeydown(e) {\n        if (isSegmentNavigationKey(e.key)) {\n            e.preventDefault();\n            handleSegmentNavigation(e, dateField.ids.field.get());\n        }\n    }\n    return {\n        elements: {\n            ...calendar.elements,\n            ...dateField.elements,\n            ...popover.elements,\n            trigger,\n        },\n        states: {\n            ...dateField.states,\n            ...calendar.states,\n            placeholder: placeholder.toWritable(),\n            value,\n            ...popover.states,\n        },\n        helpers: {\n            ...calendar.helpers,\n        },\n        options: {\n            ...dateFieldOptions,\n            ...calendarOptions,\n            ...options,\n            ...popover.options,\n        },\n        ids: {\n            dateField: dateField.ids,\n            calendar: calendar.ids,\n            popover: popover.ids,\n        },\n    };\n}\n","import { createFocusTrap, useEscapeKeydown, usePortal } from '../../internal/actions/index.js';\nimport { addMeltEventListener, makeElement, createElHelpers, effect, executeCallbacks, generateIds, getPortalDestination, handleFocus, isBrowser, isHTMLElement, kbd, noop, omit, overridable, removeScroll, styleToString, toWritableStores, portalAttr, } from '../../internal/helpers/index.js';\nimport { withGet } from '../../internal/helpers/withGet.js';\nimport { tick } from 'svelte';\nimport { derived, writable } from 'svelte/store';\nimport { useModal } from '../../internal/actions/modal/action.js';\nconst { name } = createElHelpers('dialog');\nconst defaults = {\n    preventScroll: true,\n    closeOnEscape: true,\n    closeOnOutsideClick: true,\n    role: 'dialog',\n    defaultOpen: false,\n    portal: undefined,\n    forceVisible: false,\n    openFocus: undefined,\n    closeFocus: undefined,\n    onOutsideClick: undefined,\n};\nexport const dialogIdParts = ['content', 'title', 'description'];\nexport function createDialog(props) {\n    const withDefaults = { ...defaults, ...props };\n    const options = toWritableStores(omit(withDefaults, 'ids'));\n    const { preventScroll, closeOnEscape, closeOnOutsideClick, role, portal, forceVisible, openFocus, closeFocus, onOutsideClick, } = options;\n    const activeTrigger = withGet.writable(null);\n    const ids = toWritableStores({\n        ...generateIds(dialogIdParts),\n        ...withDefaults.ids,\n    });\n    const openWritable = withDefaults.open ?? writable(withDefaults.defaultOpen);\n    const open = overridable(openWritable, withDefaults?.onOpenChange);\n    const isVisible = derived([open, forceVisible], ([$open, $forceVisible]) => {\n        return $open || $forceVisible;\n    });\n    let unsubScroll = noop;\n    function handleOpen(e) {\n        const el = e.currentTarget;\n        const triggerEl = e.currentTarget;\n        if (!isHTMLElement(el) || !isHTMLElement(triggerEl))\n            return;\n        open.set(true);\n        activeTrigger.set(triggerEl);\n    }\n    function handleClose() {\n        open.set(false);\n        handleFocus({\n            prop: closeFocus.get(),\n            defaultEl: activeTrigger.get(),\n        });\n    }\n    const trigger = makeElement(name('trigger'), {\n        stores: [open],\n        returned: ([$open]) => {\n            return {\n                'aria-haspopup': 'dialog',\n                'aria-expanded': $open,\n                type: 'button',\n            };\n        },\n        action: (node) => {\n            const unsub = executeCallbacks(addMeltEventListener(node, 'click', (e) => {\n                handleOpen(e);\n            }), addMeltEventListener(node, 'keydown', (e) => {\n                if (e.key !== kbd.ENTER && e.key !== kbd.SPACE)\n                    return;\n                e.preventDefault();\n                handleOpen(e);\n            }));\n            return {\n                destroy: unsub,\n            };\n        },\n    });\n    const overlay = makeElement(name('overlay'), {\n        stores: [isVisible, open],\n        returned: ([$isVisible, $open]) => {\n            return {\n                hidden: $isVisible ? undefined : true,\n                tabindex: -1,\n                style: styleToString({\n                    display: $isVisible ? undefined : 'none',\n                }),\n                'aria-hidden': true,\n                'data-state': $open ? 'open' : 'closed',\n            };\n        },\n        action: (node) => {\n            let unsubEscapeKeydown = noop;\n            if (closeOnEscape.get()) {\n                const escapeKeydown = useEscapeKeydown(node, {\n                    handler: () => {\n                        handleClose();\n                    },\n                });\n                if (escapeKeydown && escapeKeydown.destroy) {\n                    unsubEscapeKeydown = escapeKeydown.destroy;\n                }\n            }\n            return {\n                destroy() {\n                    unsubEscapeKeydown();\n                },\n            };\n        },\n    });\n    const content = makeElement(name('content'), {\n        stores: [isVisible, ids.content, ids.description, ids.title, open],\n        returned: ([$isVisible, $contentId, $descriptionId, $titleId, $open]) => {\n            return {\n                id: $contentId,\n                role: role.get(),\n                'aria-describedby': $descriptionId,\n                'aria-labelledby': $titleId,\n                'aria-modal': $isVisible ? 'true' : undefined,\n                'data-state': $open ? 'open' : 'closed',\n                tabindex: -1,\n                hidden: $isVisible ? undefined : true,\n                style: styleToString({\n                    display: $isVisible ? undefined : 'none',\n                }),\n            };\n        },\n        action: (node) => {\n            let activate = noop;\n            let deactivate = noop;\n            const destroy = executeCallbacks(effect([open, closeOnOutsideClick, closeOnEscape], ([$open, $closeOnOutsideClick, $closeOnEscape]) => {\n                if (!$open)\n                    return;\n                const focusTrap = createFocusTrap({\n                    immediate: false,\n                    escapeDeactivates: $closeOnEscape,\n                    clickOutsideDeactivates: $closeOnOutsideClick,\n                    allowOutsideClick: true,\n                    returnFocusOnDeactivate: false,\n                    fallbackFocus: node,\n                });\n                activate = focusTrap.activate;\n                deactivate = focusTrap.deactivate;\n                const ac = focusTrap.useFocusTrap(node);\n                if (ac && ac.destroy) {\n                    return ac.destroy;\n                }\n                else {\n                    return focusTrap.deactivate;\n                }\n            }), effect([closeOnOutsideClick, open], ([$closeOnOutsideClick, $open]) => {\n                return useModal(node, {\n                    open: $open,\n                    closeOnInteractOutside: $closeOnOutsideClick,\n                    onClose() {\n                        handleClose();\n                    },\n                    shouldCloseOnInteractOutside(e) {\n                        onOutsideClick.get()?.(e);\n                        if (e.defaultPrevented)\n                            return false;\n                        return true;\n                    },\n                }).destroy;\n            }), effect([closeOnEscape], ([$closeOnEscape]) => {\n                if (!$closeOnEscape)\n                    return noop;\n                return useEscapeKeydown(node, { handler: handleClose }).destroy;\n            }), effect([isVisible], ([$isVisible]) => {\n                tick().then(() => {\n                    if (!$isVisible) {\n                        deactivate();\n                    }\n                    else {\n                        activate();\n                    }\n                });\n            }));\n            return {\n                destroy: () => {\n                    unsubScroll();\n                    destroy();\n                },\n            };\n        },\n    });\n    const portalled = makeElement(name('portalled'), {\n        stores: portal,\n        returned: ($portal) => ({\n            'data-portal': portalAttr($portal),\n        }),\n        action: (node) => {\n            const unsubPortal = effect([portal], ([$portal]) => {\n                if ($portal === null)\n                    return noop;\n                const portalDestination = getPortalDestination(node, $portal);\n                if (portalDestination === null)\n                    return noop;\n                return usePortal(node, portalDestination).destroy;\n            });\n            return {\n                destroy() {\n                    unsubPortal();\n                },\n            };\n        },\n    });\n    const title = makeElement(name('title'), {\n        stores: [ids.title],\n        returned: ([$titleId]) => ({\n            id: $titleId,\n        }),\n    });\n    const description = makeElement(name('description'), {\n        stores: [ids.description],\n        returned: ([$descriptionId]) => ({\n            id: $descriptionId,\n        }),\n    });\n    const close = makeElement(name('close'), {\n        returned: () => ({\n            type: 'button',\n        }),\n        action: (node) => {\n            const unsub = executeCallbacks(addMeltEventListener(node, 'click', () => {\n                handleClose();\n            }), addMeltEventListener(node, 'keydown', (e) => {\n                if (e.key !== kbd.SPACE && e.key !== kbd.ENTER)\n                    return;\n                e.preventDefault();\n                handleClose();\n            }));\n            return {\n                destroy: unsub,\n            };\n        },\n    });\n    effect([open, preventScroll], ([$open, $preventScroll]) => {\n        if (!isBrowser)\n            return;\n        if ($preventScroll && $open)\n            unsubScroll = removeScroll();\n        if ($open) {\n            const contentEl = document.getElementById(ids.content.get());\n            handleFocus({ prop: openFocus.get(), defaultEl: contentEl });\n        }\n        return () => {\n            // we only want to remove the scroll lock if the dialog is not forced visible\n            // otherwise the scroll removal is handled in the `destroy` of the `content` builder\n            if (!forceVisible.get()) {\n                unsubScroll();\n            }\n        };\n    });\n    return {\n        ids,\n        elements: {\n            content,\n            trigger,\n            title,\n            description,\n            overlay,\n            close,\n            portalled,\n        },\n        states: {\n            open,\n        },\n        options,\n    };\n}\n","import { overridable, toWritableStores } from '../../internal/helpers/index.js';\nimport { withGet } from '../../internal/helpers/withGet.js';\nimport { writable } from 'svelte/store';\nimport { omit } from '../../internal/helpers/object.js';\nimport { createMenuBuilder } from '../menu/index.js';\nconst defaults = {\n    arrowSize: 8,\n    positioning: {\n        placement: 'bottom',\n    },\n    preventScroll: true,\n    closeOnEscape: true,\n    closeOnOutsideClick: true,\n    portal: undefined,\n    loop: false,\n    dir: 'ltr',\n    defaultOpen: false,\n    forceVisible: false,\n    typeahead: true,\n    closeFocus: undefined,\n    disableFocusFirstItem: false,\n    closeOnItemClick: true,\n    onOutsideClick: undefined,\n};\nexport function createDropdownMenu(props) {\n    const withDefaults = { ...defaults, ...props };\n    const rootOptions = toWritableStores(omit(withDefaults, 'ids'));\n    const openWritable = withDefaults.open ?? writable(withDefaults.defaultOpen);\n    const rootOpen = overridable(openWritable, withDefaults?.onOpenChange);\n    const rootActiveTrigger = withGet(writable(null));\n    const nextFocusable = withGet(writable(null));\n    const prevFocusable = withGet(writable(null));\n    const { elements, builders, ids, states, options } = createMenuBuilder({\n        rootOptions,\n        rootOpen,\n        rootActiveTrigger: withGet(rootActiveTrigger),\n        nextFocusable: withGet(nextFocusable),\n        prevFocusable: withGet(prevFocusable),\n        selector: 'dropdown-menu',\n        removeScroll: true,\n        ids: withDefaults.ids,\n    });\n    return {\n        ids,\n        elements,\n        states,\n        builders,\n        options,\n    };\n}\n","import { makeElement, toWritableStores } from '../../internal/helpers/index.js';\nconst defaults = {\n    orientation: 'horizontal',\n    decorative: false,\n};\nexport const createSeparator = (props) => {\n    const withDefaults = { ...defaults, ...props };\n    const options = toWritableStores(withDefaults);\n    const { orientation, decorative } = options;\n    const root = makeElement('separator', {\n        stores: [orientation, decorative],\n        returned: ([$orientation, $decorative]) => {\n            const ariaOrientation = $orientation === 'vertical' ? $orientation : undefined;\n            return {\n                role: $decorative ? 'none' : 'separator',\n                'aria-orientation': ariaOrientation,\n                'aria-hidden': $decorative,\n                'data-orientation': $orientation,\n            };\n        },\n    });\n    return {\n        elements: {\n            root,\n        },\n        options,\n    };\n};\n","export const bits = [\n    \"accordion\",\n    \"alert-dialog\",\n    \"aspect-ratio\",\n    \"avatar\",\n    \"button\",\n    \"calendar\",\n    \"checkbox\",\n    \"collapsible\",\n    \"combobox\",\n    \"context-menu\",\n    \"date-field\",\n    \"date-picker\",\n    \"date-range-field\",\n    \"date-range-picker\",\n    \"dialog\",\n    \"dropdown-menu\",\n    \"label\",\n    \"link-preview\",\n    \"menubar\",\n    \"pagination\",\n    \"pin-input\",\n    \"popover\",\n    \"progress\",\n    \"radio-group\",\n    \"range-calendar\",\n    \"scroll-area\",\n    \"select\",\n    \"separator\",\n    \"slider\",\n    \"switch\",\n    \"tabs\",\n    \"toggle\",\n    \"toggle-group\",\n    \"toolbar\",\n    \"tooltip\",\n];\nexport function createBitAttrs(bit, parts) {\n    const attrs = {};\n    parts.forEach((part) => {\n        attrs[part] = {\n            [`data-${bit}-${part}`]: \"\",\n        };\n    });\n    return (part) => attrs[part];\n}\nexport function disabledAttrs(disabled) {\n    return disabled\n        ? { \"aria-disabled\": \"true\", \"data-disabled\": \"\" }\n        : { \"aria-disabled\": undefined, \"data-disabled\": undefined };\n}\n","import { createEventDispatcher } from \"svelte\";\nexport function createDispatcher() {\n    const dispatch = createEventDispatcher();\n    return (e) => {\n        const { originalEvent } = e.detail;\n        const { cancelable } = e;\n        const type = originalEvent.type;\n        const shouldContinue = dispatch(type, { originalEvent, currentTarget: originalEvent.currentTarget }, { cancelable });\n        if (!shouldContinue) {\n            e.preventDefault();\n        }\n    };\n}\n","export function removeUndefined(obj) {\n    const result = {};\n    for (const key in obj) {\n        const value = obj[key];\n        if (value !== undefined) {\n            result[key] = value;\n        }\n    }\n    return result;\n}\n","export function getOptionUpdater(options) {\n    return function (key, value) {\n        if (value === undefined)\n            return;\n        const store = options[key];\n        if (store) {\n            store.set(value);\n        }\n    };\n}\n","export function getPositioningUpdater(store) {\n    return (props = {}) => {\n        return updatePositioning(store, props);\n    };\n}\nexport function updatePositioning(store, props) {\n    const defaultPositioningProps = {\n        side: \"bottom\",\n        align: \"center\",\n        sideOffset: 0,\n        alignOffset: 0,\n        sameWidth: false,\n        avoidCollisions: true,\n        collisionPadding: 8,\n        fitViewport: false,\n        strategy: \"absolute\",\n        overlap: false,\n    };\n    const withDefaults = { ...defaultPositioningProps, ...props };\n    store.update((prev) => {\n        return {\n            ...prev,\n            placement: joinPlacement(withDefaults.side, withDefaults.align),\n            offset: {\n                ...prev.offset,\n                mainAxis: withDefaults.sideOffset,\n                crossAxis: withDefaults.alignOffset,\n            },\n            gutter: 0,\n            sameWidth: withDefaults.sameWidth,\n            flip: withDefaults.avoidCollisions,\n            overflowPadding: withDefaults.collisionPadding,\n            boundary: withDefaults.collisionBoundary,\n            fitViewport: withDefaults.fitViewport,\n            strategy: withDefaults.strategy,\n            overlap: withDefaults.overlap,\n        };\n    });\n}\nfunction joinPlacement(side, align) {\n    if (align === \"center\")\n        return side;\n    return `${side}-${align}`;\n}\n","import { createDropdownMenu, } from \"@melt-ui/svelte\";\nimport { getContext, setContext } from \"svelte\";\nimport { getPositioningUpdater } from \"../floating/helpers.js\";\nimport { createBitAttrs, generateId, getOptionUpdater, removeUndefined, } from \"../../internal/index.js\";\nexport function getMenuData() {\n    const NAME = \"menu\";\n    const SUB_NAME = \"menu-submenu\";\n    const RADIO_GROUP_NAME = \"menu-radiogroup\";\n    const CHECKBOX_ITEM_NAME = \"menu-checkboxitem\";\n    const RADIO_ITEM_NAME = \"menu-radioitem\";\n    const GROUP_NAME = \"menu-group\";\n    const PARTS = [\n        \"arrow\",\n        \"checkbox-indicator\",\n        \"checkbox-item\",\n        \"content\",\n        \"group\",\n        \"item\",\n        \"label\",\n        \"radio-group\",\n        \"radio-item\",\n        \"radio-indicator\",\n        \"separator\",\n        \"sub-content\",\n        \"sub-trigger\",\n        \"trigger\",\n    ];\n    return {\n        NAME,\n        SUB_NAME,\n        RADIO_GROUP_NAME,\n        CHECKBOX_ITEM_NAME,\n        RADIO_ITEM_NAME,\n        GROUP_NAME,\n        PARTS,\n    };\n}\nexport function getCtx() {\n    const { NAME } = getMenuData();\n    return getContext(NAME);\n}\nexport function setCtx(props) {\n    const { NAME, PARTS } = getMenuData();\n    const getAttrs = createBitAttrs(\"menu\", PARTS);\n    const dropdownMenu = {\n        ...createDropdownMenu({ ...removeUndefined(props), forceVisible: true }),\n        getAttrs,\n    };\n    setContext(NAME, dropdownMenu);\n    return {\n        ...dropdownMenu,\n        updateOption: getOptionUpdater(dropdownMenu.options),\n    };\n}\nexport function setSubMenuCtx(props) {\n    const { SUB_NAME } = getMenuData();\n    const { builders: { createSubmenu }, getAttrs, } = getCtx();\n    const sub = { ...createSubmenu(removeUndefined(props)), getAttrs };\n    setContext(SUB_NAME, sub);\n    return {\n        ...sub,\n        updateOption: getOptionUpdater(sub.options),\n    };\n}\nexport function setRadioGroupCtx(props) {\n    const { RADIO_GROUP_NAME } = getMenuData();\n    const { builders: { createMenuRadioGroup }, getAttrs, } = getCtx();\n    const radioGroup = createMenuRadioGroup(props);\n    setContext(RADIO_GROUP_NAME, { ...radioGroup, getAttrs });\n    return {\n        ...radioGroup,\n        getAttrs,\n    };\n}\nexport function setRadioItem(value) {\n    const { RADIO_ITEM_NAME, RADIO_GROUP_NAME } = getMenuData();\n    const dropdownMenu = getContext(RADIO_GROUP_NAME);\n    setContext(RADIO_ITEM_NAME, { ...dropdownMenu, value });\n    return {\n        ...dropdownMenu,\n        value,\n    };\n}\nexport function getRadioIndicator() {\n    const { RADIO_ITEM_NAME } = getMenuData();\n    const radioItem = getContext(RADIO_ITEM_NAME);\n    return {\n        ...radioItem,\n    };\n}\nexport function getSubTrigger() {\n    const { SUB_NAME } = getMenuData();\n    const submenu = getContext(SUB_NAME);\n    return submenu;\n}\nexport function getSubmenuCtx() {\n    const { SUB_NAME } = getMenuData();\n    return getContext(SUB_NAME);\n}\nexport function setCheckboxItem(props) {\n    const { CHECKBOX_ITEM_NAME } = getMenuData();\n    const { builders: { createCheckboxItem }, getAttrs, } = getCtx();\n    const checkboxItem = createCheckboxItem(removeUndefined(props));\n    setContext(CHECKBOX_ITEM_NAME, checkboxItem.states.checked);\n    return {\n        ...checkboxItem,\n        updateOption: getOptionUpdater(checkboxItem.options),\n        getAttrs,\n    };\n}\nexport function getCheckboxIndicator() {\n    const { CHECKBOX_ITEM_NAME } = getMenuData();\n    return getContext(CHECKBOX_ITEM_NAME);\n}\nexport function setGroupCtx() {\n    const { GROUP_NAME } = getMenuData();\n    const { elements: { group }, getAttrs, } = getCtx();\n    const id = generateId();\n    setContext(GROUP_NAME, id);\n    return { group, id, getAttrs };\n}\nexport function getGroupLabel() {\n    const { GROUP_NAME } = getMenuData();\n    const id = getContext(GROUP_NAME) ?? generateId();\n    const { elements: { groupLabel }, getAttrs, } = getCtx();\n    return { groupLabel, id, getAttrs };\n}\nexport function setArrow(size = 8) {\n    const menu = getCtx();\n    menu.options.arrowSize.set(size);\n    return menu;\n}\nexport function updatePositioning(props) {\n    const defaultPlacement = {\n        side: \"bottom\",\n        align: \"center\",\n    };\n    const withDefaults = { ...defaultPlacement, ...props };\n    const { options: { positioning }, } = getCtx();\n    const updater = getPositioningUpdater(positioning);\n    updater(withDefaults);\n}\nexport function updateSubPositioning(props) {\n    const defaultSubPlacement = {\n        side: \"right\",\n        align: \"start\",\n    };\n    const withDefaults = { ...defaultSubPlacement, ...props };\n    const { options: { positioning }, } = getSubmenuCtx();\n    const updater = getPositioningUpdater(positioning);\n    updater(withDefaults);\n}\n","<script>import { melt } from \"@melt-ui/svelte\";\nimport { getCtx } from \"../ctx.js\";\nimport { disabledAttrs } from \"../../../internal/index.js\";\nimport { createDispatcher } from \"../../../internal/events.js\";\nexport let href = void 0;\nexport let asChild = false;\nexport let disabled = false;\nexport let el = void 0;\nconst {\n  elements: { item },\n  getAttrs\n} = getCtx();\nconst dispatch = createDispatcher();\n$: builder = $item;\n$: attrs = { ...getAttrs(\"item\"), ...disabledAttrs(disabled) };\n$: Object.assign(builder, attrs);\n</script>\n\n{#if asChild}\n\t<slot {builder} />\n{:else}\n\t<svelte:element\n\t\tthis={href ? \"a\" : \"div\"}\n\t\tbind:this={el}\n\t\t{href}\n\t\t{...builder} use:builder.action\n\t\t{...$$restProps}\n\t\ton:m-click={dispatch}\n\t\ton:m-focusin={dispatch}\n\t\ton:m-focusout={dispatch}\n\t\ton:m-keydown={dispatch}\n\t\ton:m-pointerdown={dispatch}\n\t\ton:m-pointerleave={dispatch}\n\t\ton:m-pointermove={dispatch}\n\t\ton:pointerenter\n\t>\n\t\t<slot {builder} />\n\t</svelte:element>\n{/if}\n","import { createDialog } from \"@melt-ui/svelte\";\nimport { getContext, setContext } from \"svelte\";\nimport { createBitAttrs, getOptionUpdater, removeUndefined } from \"../../internal/index.js\";\nexport function getDialogData() {\n    const NAME = \"dialog\";\n    const PARTS = [\n        \"close\",\n        \"content\",\n        \"description\",\n        \"overlay\",\n        \"portal\",\n        \"title\",\n        \"trigger\",\n    ];\n    return {\n        NAME,\n        PARTS,\n    };\n}\nexport function setCtx(props) {\n    const { NAME, PARTS } = getDialogData();\n    const getAttrs = createBitAttrs(NAME, PARTS);\n    const dialog = {\n        ...createDialog({ ...removeUndefined(props), role: \"dialog\", forceVisible: true }),\n        getAttrs,\n    };\n    setContext(NAME, dialog);\n    return {\n        ...dialog,\n        updateOption: getOptionUpdater(dialog.options),\n    };\n}\nexport function getCtx() {\n    const { NAME } = getDialogData();\n    return getContext(NAME);\n}\n","<script>import { derived } from \"svelte/store\";\nimport { setCtx } from \"../ctx.js\";\nexport let preventScroll = void 0;\nexport let closeOnEscape = void 0;\nexport let closeOnOutsideClick = void 0;\nexport let portal = void 0;\nexport let open = void 0;\nexport let onOpenChange = void 0;\nexport let openFocus = void 0;\nexport let closeFocus = void 0;\nexport let onOutsideClick = void 0;\nconst {\n  states: { open: localOpen },\n  updateOption,\n  ids\n} = setCtx({\n  closeOnEscape,\n  preventScroll,\n  closeOnOutsideClick,\n  portal,\n  forceVisible: true,\n  defaultOpen: open,\n  openFocus,\n  closeFocus,\n  onOutsideClick,\n  onOpenChange: ({ next }) => {\n    if (open !== next) {\n      onOpenChange?.(next);\n      open = next;\n    }\n    return next;\n  }\n});\nconst idValues = derived(\n  [ids.content, ids.description, ids.title],\n  ([$contentId, $descriptionId, $titleId]) => ({\n    content: $contentId,\n    description: $descriptionId,\n    title: $titleId\n  })\n);\n$: open !== void 0 && localOpen.set(open);\n$: updateOption(\"preventScroll\", preventScroll);\n$: updateOption(\"closeOnEscape\", closeOnEscape);\n$: updateOption(\"closeOnOutsideClick\", closeOnOutsideClick);\n$: updateOption(\"portal\", portal);\n$: updateOption(\"openFocus\", openFocus);\n$: updateOption(\"closeFocus\", closeFocus);\n$: updateOption(\"onOutsideClick\", onOutsideClick);\n</script>\n\n<slot ids={$idValues} />\n","<script>import { melt } from \"@melt-ui/svelte\";\nimport { getCtx } from \"../ctx.js\";\nexport let level = \"h2\";\nexport let asChild = false;\nexport let id = void 0;\nexport let el = void 0;\nconst {\n  elements: { title },\n  ids,\n  getAttrs\n} = getCtx();\nconst attrs = getAttrs(\"title\");\n$: if (id) {\n  ids.title.set(id);\n}\n$: builder = $title;\n$: Object.assign(builder, attrs);\n</script>\n\n{#if asChild}\n\t<slot {builder} />\n{:else}\n\t<svelte:element this={level} bind:this={el} {...builder} use:builder.action {...$$restProps}>\n\t\t<slot {builder} />\n\t</svelte:element>\n{/if}\n","<script>import { melt } from \"@melt-ui/svelte\";\nimport { getCtx } from \"../ctx.js\";\nimport { createDispatcher } from \"../../../internal/events.js\";\nexport let asChild = false;\nexport let el = void 0;\nconst {\n  elements: { close },\n  getAttrs\n} = getCtx();\nconst dispatch = createDispatcher();\nconst attrs = getAttrs(\"close\");\n$: builder = $close;\n$: Object.assign(builder, attrs);\n</script>\n\n{#if asChild}\n\t<slot {builder} />\n{:else}\n\t<button\n\t\tbind:this={el}\n\t\t{...builder} use:builder.action\n\t\ttype=\"button\"\n\t\t{...$$restProps}\n\t\ton:m-click={dispatch}\n\t\ton:m-keydown={dispatch}\n\t>\n\t\t<slot {builder} />\n\t</button>\n{/if}\n","<script>import { melt } from \"@melt-ui/svelte\";\nimport { getCtx } from \"../ctx.js\";\nexport let asChild = false;\nexport let el = void 0;\nconst {\n  elements: { portalled },\n  getAttrs\n} = getCtx();\nconst attrs = getAttrs(\"portal\");\n$: builder = $portalled;\n$: Object.assign(builder, attrs);\n</script>\n\n{#if asChild}\n\t<slot {builder} />\n{:else}\n\t<div bind:this={el} {...builder} use:builder.action {...$$restProps}>\n\t\t<slot {builder} />\n\t</div>\n{/if}\n","<script>import { melt } from \"@melt-ui/svelte\";\nimport { getCtx } from \"../ctx.js\";\nexport let transition = void 0;\nexport let transitionConfig = void 0;\nexport let inTransition = void 0;\nexport let inTransitionConfig = void 0;\nexport let outTransition = void 0;\nexport let outTransitionConfig = void 0;\nexport let asChild = false;\nexport let id = void 0;\nexport let el = void 0;\nconst {\n  elements: { content },\n  states: { open },\n  ids,\n  getAttrs\n} = getCtx();\nconst attrs = getAttrs(\"content\");\n$: if (id) {\n  ids.content.set(id);\n}\n$: builder = $content;\n$: Object.assign(builder, attrs);\n</script>\n\n{#if asChild && $open}\n\t<slot {builder} />\n{:else if transition && $open}\n\t<div\n\t\tbind:this={el}\n\t\ttransition:transition={transitionConfig}\n\t\t{...builder} use:builder.action\n\t\t{...$$restProps}\n\t\ton:pointerdown\n\t\ton:pointermove\n\t\ton:pointerup\n\t\ton:touchcancel\n\t\ton:touchend\n\t\ton:touchmove|nonpassive\n\t\ton:touchstart|nonpassive\n\t>\n\t\t<slot {builder} />\n\t</div>\n{:else if inTransition && outTransition && $open}\n\t<div\n\t\tbind:this={el}\n\t\tin:inTransition={inTransitionConfig}\n\t\tout:outTransition={outTransitionConfig}\n\t\t{...builder} use:builder.action\n\t\ton:pointerdown\n\t\ton:pointermove\n\t\ton:pointerup\n\t\ton:touchcancel\n\t\ton:touchend\n\t\ton:touchmove|nonpassive\n\t\ton:touchstart|nonpassive\n\t\t{...$$restProps}\n\t>\n\t\t<slot {builder} />\n\t</div>\n{:else if inTransition && $open}\n\t<div\n\t\tbind:this={el}\n\t\tin:inTransition={inTransitionConfig}\n\t\t{...builder} use:builder.action\n\t\ton:pointerdown\n\t\ton:pointermove\n\t\ton:pointerup\n\t\ton:touchcancel\n\t\ton:touchend\n\t\ton:touchmove|nonpassive\n\t\ton:touchstart|nonpassive\n\t\t{...$$restProps}\n\t>\n\t\t<slot {builder} />\n\t</div>\n{:else if outTransition && $open}\n\t<div\n\t\tbind:this={el}\n\t\tout:outTransition={outTransitionConfig}\n\t\t{...builder} use:builder.action\n\t\ton:pointerdown\n\t\ton:pointermove\n\t\ton:pointerup\n\t\ton:touchcancel\n\t\ton:touchend\n\t\ton:touchmove|nonpassive\n\t\ton:touchstart|nonpassive\n\t\t{...$$restProps}\n\t>\n\t\t<slot {builder} />\n\t</div>\n{:else if $open}\n\t<div\n\t\tbind:this={el}\n\t\t{...builder} use:builder.action\n\t\ton:pointerdown\n\t\ton:pointermove\n\t\ton:pointerup\n\t\ton:touchcancel\n\t\ton:touchend\n\t\ton:touchmove|nonpassive\n\t\ton:touchstart|nonpassive\n\t\t{...$$restProps}\n\t>\n\t\t<slot {builder} />\n\t</div>\n{/if}\n","<script>import { melt } from \"@melt-ui/svelte\";\nimport { getCtx } from \"../ctx.js\";\nexport let transition = void 0;\nexport let transitionConfig = void 0;\nexport let inTransition = void 0;\nexport let inTransitionConfig = void 0;\nexport let outTransition = void 0;\nexport let outTransitionConfig = void 0;\nexport let asChild = false;\nexport let el = void 0;\nconst {\n  elements: { overlay },\n  states: { open },\n  getAttrs\n} = getCtx();\nconst attrs = getAttrs(\"overlay\");\n$: builder = $overlay;\n$: Object.assign(builder, attrs);\n</script>\n\n{#if asChild && $open}\n\t<slot {builder} />\n{:else if transition && $open}\n\t<!-- svelte-ignore a11y-no-static-element-interactions a11y_no_static_element_interactions -->\n\t<div\n\t\ton:mouseup\n\t\tbind:this={el}\n\t\ttransition:transition={transitionConfig}\n\t\t{...builder} use:builder.action\n\t\t{...$$restProps}\n\t></div>\n{:else if inTransition && outTransition && $open}\n\t<!-- svelte-ignore a11y-no-static-element-interactions a11y_no_static_element_interactions -->\n\t<div\n\t\tbind:this={el}\n\t\tin:inTransition={inTransitionConfig}\n\t\tout:outTransition={outTransitionConfig}\n\t\t{...builder} use:builder.action\n\t\ton:mouseup\n\t\t{...$$restProps}\n\t></div>\n{:else if inTransition && $open}\n\t<!-- svelte-ignore a11y-no-static-element-interactions a11y_no_static_element_interactions -->\n\t<div\n\t\tbind:this={el}\n\t\tin:inTransition={inTransitionConfig}\n\t\t{...builder} use:builder.action\n\t\ton:mouseup\n\t\t{...$$restProps}\n\t></div>\n{:else if outTransition && $open}\n\t<!-- svelte-ignore a11y-no-static-element-interactions a11y_no_static_element_interactions -->\n\t<div\n\t\tbind:this={el}\n\t\tout:outTransition={outTransitionConfig}\n\t\t{...builder} use:builder.action\n\t\ton:mouseup\n\t\t{...$$restProps}\n\t></div>\n{:else if $open}\n\t<!-- svelte-ignore a11y-no-static-element-interactions a11y_no_static_element_interactions -->\n\t<div bind:this={el} {...builder} use:builder.action on:mouseup {...$$restProps}></div>\n{/if}\n","<script>import { derived } from \"svelte/store\";\nimport { setCtx } from \"../ctx.js\";\nexport let closeOnOutsideClick = void 0;\nexport let closeOnEscape = void 0;\nexport let portal = void 0;\nexport let open = void 0;\nexport let onOpenChange = void 0;\nexport let preventScroll = void 0;\nexport let loop = void 0;\nexport let dir = void 0;\nexport let typeahead = void 0;\nexport let closeFocus = void 0;\nexport let disableFocusFirstItem = void 0;\nexport let closeOnItemClick = void 0;\nexport let onOutsideClick = void 0;\nconst {\n  states: { open: localOpen },\n  updateOption,\n  ids\n} = setCtx({\n  closeOnOutsideClick,\n  closeOnEscape,\n  portal,\n  forceVisible: true,\n  defaultOpen: open,\n  preventScroll,\n  loop,\n  dir,\n  typeahead,\n  closeFocus,\n  disableFocusFirstItem,\n  closeOnItemClick,\n  onOutsideClick,\n  onOpenChange: ({ next }) => {\n    if (open !== next) {\n      onOpenChange?.(next);\n      open = next;\n    }\n    return next;\n  }\n});\nconst idValues = derived([ids.menu, ids.trigger], ([$menuId, $triggerId]) => ({\n  menu: $menuId,\n  trigger: $triggerId\n}));\n$: open !== void 0 && localOpen.set(open);\n$: updateOption(\"closeOnOutsideClick\", closeOnOutsideClick);\n$: updateOption(\"closeOnEscape\", closeOnEscape);\n$: updateOption(\"portal\", portal);\n$: updateOption(\"preventScroll\", preventScroll);\n$: updateOption(\"loop\", loop);\n$: updateOption(\"dir\", dir);\n$: updateOption(\"closeFocus\", closeFocus);\n$: updateOption(\"disableFocusFirstItem\", disableFocusFirstItem);\n$: updateOption(\"typeahead\", typeahead);\n$: updateOption(\"closeOnItemClick\", closeOnItemClick);\n$: updateOption(\"onOutsideClick\", onOutsideClick);\n</script>\n\n<slot ids={$idValues} />\n","<script>import { melt } from \"@melt-ui/svelte\";\nimport { getCtx, updatePositioning } from \"../ctx.js\";\nimport { createDispatcher } from \"../../../internal/events.js\";\nexport let transition = void 0;\nexport let transitionConfig = void 0;\nexport let inTransition = void 0;\nexport let inTransitionConfig = void 0;\nexport let outTransition = void 0;\nexport let outTransitionConfig = void 0;\nexport let asChild = false;\nexport let id = void 0;\nexport let side = \"bottom\";\nexport let align = \"center\";\nexport let sideOffset = 0;\nexport let alignOffset = 0;\nexport let collisionPadding = 8;\nexport let avoidCollisions = true;\nexport let collisionBoundary = void 0;\nexport let sameWidth = false;\nexport let fitViewport = false;\nexport let strategy = \"absolute\";\nexport let overlap = false;\nexport let el = void 0;\nconst {\n  elements: { menu },\n  states: { open },\n  ids,\n  getAttrs\n} = getCtx();\nconst dispatch = createDispatcher();\nconst attrs = getAttrs(\"content\");\n$: if (id) {\n  ids.menu.set(id);\n}\n$: builder = $menu;\n$: Object.assign(builder, attrs);\n$: if ($open) {\n  updatePositioning({\n    side,\n    align,\n    sideOffset,\n    alignOffset,\n    collisionPadding,\n    avoidCollisions,\n    collisionBoundary,\n    sameWidth,\n    fitViewport,\n    strategy,\n    overlap\n  });\n}\n</script>\n\n{#if asChild && $open}\n\t<slot {builder} />\n{:else if transition && $open}\n\t<div\n\t\tbind:this={el}\n\t\ttransition:transition={transitionConfig}\n\t\t{...builder} use:builder.action\n\t\t{...$$restProps}\n\t\ton:m-keydown={dispatch}\n\t>\n\t\t<slot {builder} />\n\t</div>\n{:else if inTransition && outTransition && $open}\n\t<div\n\t\tbind:this={el}\n\t\tin:inTransition={inTransitionConfig}\n\t\tout:outTransition={outTransitionConfig}\n\t\t{...builder} use:builder.action\n\t\t{...$$restProps}\n\t\ton:m-keydown={dispatch}\n\t>\n\t\t<slot {builder} />\n\t</div>\n{:else if inTransition && $open}\n\t<div\n\t\tbind:this={el}\n\t\tin:inTransition={inTransitionConfig}\n\t\t{...builder} use:builder.action\n\t\t{...$$restProps}\n\t\ton:m-keydown={dispatch}\n\t>\n\t\t<slot {builder} />\n\t</div>\n{:else if outTransition && $open}\n\t<div\n\t\tbind:this={el}\n\t\tout:outTransition={outTransitionConfig}\n\t\t{...builder} use:builder.action\n\t\t{...$$restProps}\n\t\ton:m-keydown={dispatch}\n\t>\n\t\t<slot {builder} />\n\t</div>\n{:else if $open}\n\t<div bind:this={el} {...builder} use:builder.action {...$$restProps} on:m-keydown={dispatch}>\n\t\t<slot {builder} />\n\t</div>\n{/if}\n","<script>import { melt } from \"@melt-ui/svelte\";\nimport { getCtx } from \"../ctx.js\";\nimport { createDispatcher } from \"../../../internal/events.js\";\nexport let asChild = false;\nexport let id = void 0;\nexport let el = void 0;\nconst {\n  elements: { trigger },\n  ids,\n  getAttrs\n} = getCtx();\nconst dispatch = createDispatcher();\nconst attrs = getAttrs(\"trigger\");\n$: if (id) {\n  ids.trigger.set(id);\n}\n$: builder = $trigger;\n$: Object.assign(builder, attrs);\n</script>\n\n{#if asChild}\n\t<slot {builder} />\n{:else}\n\t<button\n\t\tbind:this={el}\n\t\t{...builder} use:builder.action\n\t\ttype=\"button\"\n\t\t{...$$restProps}\n\t\ton:m-keydown={dispatch}\n\t\ton:m-pointerdown={dispatch}\n\t>\n\t\t<slot {builder} />\n\t</button>\n{/if}\n","<script lang=\"ts\" module>\n    const map = {\n        'chevron-down': 'chevron-down',\n        'comment-lines': 'comment-lines',\n        'close': 'close',\n        'copy-to-clipboard': 'copy-to-clipboard',\n    } as const;\n\n    export type Name = keyof typeof map;\n</script>\n\n<script lang=\"ts\">\n    type Size = 16 | 24;\n\n    type Props = {\n        name: Name,\n        class?: string,\n        size?: Size\n    };\n\n    const { name, class: className = '', size = 16 }: Props = $props();\n</script>\n\n<svg role=\"img\" class=\"gl-icon s{size} {className}\">\n    <use href=\"/assets/icons-1563760c6022424ca5187159258484be0c106b044e5e5a1b4f0be7a10cd6c90f.svg#{map[name]}\"></use>\n</svg>\n","<script lang=\"ts\">\n    import { DropdownMenu } from \"bits-ui\";\n    import type { Snippet } from 'svelte';\n    import Icon from '../Icon.svelte';\n\n    type Props = {\n        children: Snippet,\n        class?: string\n    };\n\n    const { children, class: className = '' }: Props = $props();\n</script>\n\n<div class=\"gl-disclosure-dropdown gl-new-dropdown {className}\">\n    <DropdownMenu.Trigger class=\"btn btn-default btn-md gl-button gl-new-dropdown-toggle\">\n        <span class=\"gl-button-text gl-w-full\">\n            <span class=\"gl-new-dropdown-button-text\">\n                {@render children()}\n            </span>\n            <Icon name=\"chevron-down\" class=\"gl-button-icon gl-new-dropdown-chevron\" />\n        </span>\n    </DropdownMenu.Trigger>\n</div>\n","<script lang=\"ts\">\n    import { DropdownMenu } from 'bits-ui';\n    import type { Snippet } from 'svelte';\n\n    type Props = {\n        children: Snippet\n    };\n\n    const { children }: Props = $props();\n</script>\n\n<DropdownMenu.Content class=\"gl-new-dropdown\" align=\"start\" sideOffset={4}>\n    <div class=\"gl-new-dropdown-panel gl-display-block!\">\n        <div class=\"gl-new-dropdown-inner\">\n            <div class=\"gl-new-dropdown-contents\">\n                {@render children()}\n            </div>\n        </div>\n    </div>\n</DropdownMenu.Content>\n","import { DropdownMenu } from 'bits-ui';\nimport Trigger from './Trigger.svelte';\nimport Content from './Content.svelte';\nimport Item from './Item.svelte';\n\nexport default {\n\tRoot: DropdownMenu.Root,\n\tTrigger,\n\tContent,\n\tItem,\n};\n","<script lang=\"ts\">\n    type Props = {\n        class?: string,\n        style?: string,\n    };\n\n    const { class: className = '', style }: Props = $props();\n</script>\n\n<img src=\"/uploads/-/system/project/avatar/10/256x256.png\" alt=\"Daktela logo\" class={className} {style} />\n","<script lang=\"ts\">\n    import Dropdown from '@gitlab/ui/dropdown';\n    import DaktelaIcon from '@gitlab/ui/DaktelaIcon.svelte';\n    import Icon from '@gitlab/ui/Icon.svelte';\n    import type { Feature } from './types';\n\n    type Props = {\n        features: Feature[],\n        class?: string,\n    };\n\n    const { features, class: className = '' }: Props = $props();\n</script>\n\n<Dropdown.Root>\n    <Dropdown.Trigger class={className}>\n        <DaktelaIcon class=\"gl-icon s14\" style=\"scale: 1.5\" />\n    </Dropdown.Trigger>\n\n    <Dropdown.Content>\n        {#each features as feature (feature.title)}\n            <Dropdown.Item onclick={feature.onClick}>\n                <Icon name={feature.icon} class=\"gl-mr-2\" />\n                {feature.title}\n            </Dropdown.Item>\n        {/each}\n    </Dropdown.Content>\n</Dropdown.Root>\n","import type { ProjectRef, SHA } from '@gitlab/types';\n\nconst Current = {\n\tprojects: {\n\t\tref(): ProjectRef {\n\t\t\tconst matches = location.pathname.match(/^\\/?(.*?)(?:\\/-\\/|$)/);\n\n\t\t\tif (!matches) {\n\t\t\t\tthrow Error(`Could not parse project ref: ${location.pathname}`);\n\t\t\t}\n\n\t\t\treturn matches[1];\n\t\t},\n\t},\n\tcommits: {\n\t\tsha(): SHA {\n\t\t\tconst matches = location.pathname.match(/\\/-\\/commit\\/(\\w+)/);\n\n\t\t\tif (!matches) {\n\t\t\t\tthrow Error(`Could not parse commit SHA: ${location.pathname}`);\n\t\t\t}\n\n\t\t\treturn matches[1];\n\t\t},\n\t},\n} as const;\n\nexport default Current;\n","<script lang=\"ts\">\n    import { Dialog } from 'bits-ui';\n    import type { Snippet } from 'svelte';\n\n    const sizeMap = {\n        'sm': 'sm',\n        'md': 'md',\n    } as const;\n\n    type Size = keyof typeof sizeMap;\n\n    type Props = {\n        size?: Size,\n        children: Snippet,\n    };\n\n    const { size = 'md', children }: Props = $props();\n</script>\n\n<Dialog.Content>\n    <div class=\"modal fade show gl-modal\" style=\"display: block;\">\n        <div class=\"modal-dialog modal-{size}\">\n            <div class=\"modal-content\">\n                {@render children()}\n            </div>\n        </div>\n    </div>\n</Dialog.Content>\n","import { Dialog } from 'bits-ui';\nimport Overlay from './Overlay.svelte';\nimport Content from './Content.svelte';\nimport Header from './Header.svelte';\nimport Title from './Title.svelte';\nimport Close from './Close.svelte';\nimport CloseIcon from './CloseIcon.svelte';\nimport Body from './Body.svelte';\nimport Footer from './Footer.svelte';\n\nexport default {\n\tRoot: Dialog.Root,\n\tPortal: Dialog.Portal,\n\tOverlay,\n\tContent,\n\tHeader,\n\tTitle,\n\tClose,\n\tCloseIcon,\n\tBody,\n\tFooter,\n};\n","import type { Comment, CommitWithBranch } from './types';\nimport type { Branch, Commit } from '../../services/gitlab/types';\n\n// noinspection SpellCheckingInspection\nconst BODY_FONTS = [\n\t'Menlo',\n\t'\\'DejaVu Sans Mono\\'',\n\t'\\'Liberation Mono\\'',\n\t'Consolas',\n\t'\\'Ubuntu Mono\\'',\n\t'\\'Courier New\\'',\n\t'\\'andale mono\\'',\n\t'\\'lucida console\\'',\n\t'monospace'\n].join(', ');\n\nconst BODY_STYLES = [\n\t`font-family:${BODY_FONTS}`,\n\t'font-size:0.8125rem',\n\t'margin-top:8px',\n\t'margin-bottom:8px',\n\t'color:#999999',\n\t'padding:8px 0 8px 8px',\n\t'border-width:0 0 0 3px',\n\t'border-style:none none none solid',\n\t'border-color:#444444',\n].join(';');\n\nfunction render(comment: Comment): string {\n\treturn (\n\t\trenderTitle(comment)\n\t\t+ renderCommits(comment)\n\t\t+ renderMergeRequests(comment)\n\t\t+ renderExtra(comment)\n\t\t+ renderBody(comment)\n\t);\n}\n\nfunction renderTitle(comment: Comment): string {\n\treturn `<p><strong>${comment.title}</strong></p>`;\n}\n\nfunction renderCommits(comment: Comment): string {\n\treturn renderListWithTitle('Commits', renderCBs([comment as CommitWithBranch<Branch>].concat(comment.cherryPicks)));\n}\n\nfunction renderCBs(cbs: CommitWithBranch<Branch>[]): string[] {\n\treturn cbs.map(cb => `${renderBranch(cb.branch)} ${renderCommit(cb.commit)}`);\n}\n\nfunction renderBranch(branch: Branch): string {\n\treturn renderAnchor(branch.name, branch.web_url);\n}\n\nfunction renderCommit(commit: Commit): string {\n\treturn renderAnchor(commit.web_url, commit.web_url);\n}\n\nfunction renderMergeRequests(comment: Comment): string {\n\treturn renderListWithTitle('Merge requests', comment.mergeRequests.map(mr => linkify(mr.web_url)));\n}\n\nfunction renderExtra(comment: Comment): string {\n\treturn Object.entries(comment.extra)\n\t\t.reduce((html, [name, values]) => {\n\t\t\treturn html + renderListWithTitle(name, linkifyAll(values), true);\n\t\t}, '');\n}\n\nfunction renderBody(comment: Comment): string {\n\tif (comment.body === '') {\n\t\treturn '';\n\t}\n\n\treturn (\n\t\t`<p>Notes (copied from commit message):</p>`\n\t\t+ `<pre style=\"${BODY_STYLES}\">${comment.body}</pre>`\n\t);\n}\n\nfunction renderListWithTitle(title: string, items: string[], allowCollapse: boolean = false): string {\n\tif (!items.length) {\n\t\treturn '';\n\t}\n\n\tif (items.length === 1 && allowCollapse) {\n\t\treturn `<p>${title}: ${items[0]}</p>`;\n\t}\n\n\treturn (\n\t\t`<p>${title}:</p>`\n\t\t+ renderList(items)\n\t);\n}\n\nfunction renderList(items: string[]): string {\n\treturn `<ul>${items.map(item => `<li>${item}</li>`).join('')}</ul>`;\n}\n\nfunction renderAnchor(title: string, url: string): string {\n\treturn `<a href=\"${url}\" target=\"_blank\" rel=\"noreferrer noopener\">${title}</a>`;\n}\n\nfunction linkifyAll(values: string[]): string[] {\n\treturn values.map(linkify);\n}\n\nfunction linkify(value: string): string {\n\ttry {\n\t\treturn renderAnchor(value, new URL(value).toString());\n\t} catch {\n\t\treturn value;\n\t}\n}\n\nexport default render;\n","<script lang=\"ts\">\n    import type { Comment } from '../../../types';\n    import renderComment from '../../../render';\n    import Icon from '@gitlab/ui/Icon.svelte';\n\n    type Props = {\n        comment: Comment,\n    };\n\n    const { comment }: Props = $props();\n    const rendered = $derived.by(() => renderComment(comment));\n\n    async function copy(): Promise<void> {\n        try {\n            await navigator.clipboard.writeText(rendered);\n        } catch (error) {\n            console.error(error);\n        }\n    }\n</script>\n\n<div class=\"gl-display-flex gl-justify-content-space-between gl-mb-2\">\n    <div>\n        {#if comment.ticket}\n            <span>\n                Ticket:\n                <a href={comment.ticket} target=\"_blank\" rel=\"noreferrer noopener\">{comment.ticket}</a>\n            </span>\n        {/if}\n    </div>\n    <button onclick={copy} title=\"Copy message\" class=\"btn input-group-text btn-default btn-md gl-button btn-default-secondary btn-icon\">\n        <Icon name=\"copy-to-clipboard\" class=\"gl-button-icon\" />\n    </button>\n</div>\n\n<textarea readonly class=\"gl-form-input gl-form-textarea form-control\">{rendered}</textarea>\n","import type { Branch, Comment, Commit, Ref, RefType, MergeRequest, ProjectRef, SHA } from './types';\n\nconst BASE_URL = '/api/v4';\n\nconst GitLab = {\n\tcommits: {\n\t\tasync findBySHA(project: ProjectRef, sha: SHA): Promise<Commit> {\n\t\t\treturn get(`projects/${e(project)}/repository/commits/${sha}`);\n\t\t},\n\t\tasync refs(project: ProjectRef, sha: SHA, type: RefType|'all' = 'all'): Promise<Ref[]> {\n\t\t\treturn get(`projects/${e(project)}/repository/commits/${sha}/refs`, {type});\n\t\t},\n\t\tasync comments(project: ProjectRef, sha: SHA): Promise<Comment[]> {\n\t\t\treturn get(`projects/${e(project)}/repository/commits/${sha}/comments`);\n\t\t},\n\t\tasync mergeRequests(project: ProjectRef, sha: SHA): Promise<MergeRequest[]> {\n\t\t\treturn get(`projects/${e(project)}/repository/commits/${sha}/merge_requests`);\n\t\t},\n\t},\n\tbranches: {\n\t\tasync findByName(project: ProjectRef, name: string): Promise<Branch> {\n\t\t\treturn get(`projects/${e(project)}/repository/branches/${e(name)}`);\n\t\t},\n\t},\n} as const;\n\nfunction e(value: string|number|boolean): string {\n\treturn encodeURIComponent(value);\n}\n\nasync function get<TResponse>(endpoint: string, query: Record<string, string> = {}): Promise<TResponse> {\n\tconst url = new URL(`${BASE_URL}/${endpoint}`, location.origin);\n\tObject.entries(query)\n\t\t.forEach(([name, value]) => url.searchParams.append(name, value));\n\n\tlet response = await fetch(url);\n\n\treturn await response.json();\n}\n\nexport default GitLab;\n","import type { Branch, Comment, ProjectRef, Ref, SHA } from '../../services/gitlab/types';\nimport GitLab from '../../services/gitlab/gitlab';\nimport type { CommitWithBranch } from './types';\n\nconst CherryPicks = {\n\tasync findRefs(project: ProjectRef, sha: SHA): Promise<CommitWithBranch<Ref[]>[]> {\n\t\tconst SHAs = await findSHAsForCommit(project, sha);\n\n\t\treturn Promise.all(\n\t\t\tSHAs.map(cherryPickSHA => this.findRef(project, cherryPickSHA))\n\t\t);\n\t},\n\tasync findRef(project: ProjectRef, sha: SHA): Promise<CommitWithBranch<Ref[]>> {\n\t\tconst [commit, branches] = await Promise.all([\n\t\t\tGitLab.commits.findBySHA(project, sha),\n\t\t\tGitLab.commits.refs(project, sha, 'branch'),\n\t\t]);\n\n\t\treturn {commit, branches};\n\t},\n\tasync deRefAll(project: ProjectRef, cherryPicks: CommitWithBranch<Ref>[]): Promise<CommitWithBranch<Branch>[]> {\n\t\treturn await Promise.all(\n\t\t\tcherryPicks.map(cherryPick => this.deRef(project, cherryPick))\n\t\t);\n\t},\n\tasync deRef(project: ProjectRef, cherryPick: CommitWithBranch<Ref>): Promise<CommitWithBranch<Branch>> {\n\t\tconst branch = await GitLab.branches.findByName(project, cherryPick.branch.name);\n\t\treturn {commit: cherryPick.commit, branch};\n\t},\n} as const;\n\nasync function findSHAsForCommit(project: ProjectRef, sha: SHA): Promise<SHA[]> {\n\tconst comments = await GitLab.commits.comments(project, sha);\n\treturn parseSHAsFromComments(comments);\n}\n\nfunction parseSHAsFromComments(comments: Comment[]): SHA[] {\n\treturn comments.reduce((SHAs, comment) => {\n\t\tconst matches = comment.note.match(/mentioned\\s+in\\s+commit\\s+(\\w+)/i);\n\n\t\tif (matches !== null) {\n\t\t\tSHAs.push(matches[1]);\n\t\t}\n\n\t\treturn SHAs;\n\t}, [] as SHA[]);\n}\n\nexport default CherryPicks;\n","import type { Message } from './types';\nimport type { Commit } from '../../services/gitlab/types';\n\nconst Parse = {\n\tmessage(commit: Commit): Message {\n\t\tconst message: Message = {title: '', body: '', ticket: undefined, extra: {}};\n\t\tconst lines = commit.message.split('\\n')\n\t\t\t.map(line => line.trim());\n\n\t\tskipEmptyLines(lines);\n\t\tmessage.title = parseTitle(lines);\n\t\tskipEmptyLines(lines);\n\n\t\twhile (lines.length) {\n\t\t\tprocessNextLine(message, lines);\n\t\t}\n\n\t\tmessage.body = message.body.trim();\n\n\t\treturn message;\n\t},\n} as const;\n\nfunction parseTitle(lines: string[]): string {\n\tconst title = lines.shift();\n\n\tif (title === undefined) {\n\t\tthrow Error('Could not parse commit title');\n\t}\n\n\treturn title.replace(/\\s*#\\s*\\d+\\s*$/, '');\n}\n\nfunction processNextLine(message: Message, lines: string[]): boolean {\n\treturn (\n\t\tskipCherryPicks(lines)\n\t\t|| collapseEmptyLines(message, lines)\n\t\t|| parseTicket(message, lines)\n\t\t|| parseExtra(message, lines)\n\t\t|| parseBody(message, lines)\n\t);\n}\n\nfunction skipEmptyLines(lines: string[]): boolean {\n\treturn skipWithPattern(lines, /^\\s*$/);\n}\n\nfunction skipCherryPicks(lines: string[]): boolean {\n\treturn skipWithPattern(lines, /\\(.*cherry.*picked.*\\)/i);\n}\n\nfunction skipWithPattern(lines: string[], pattern: RegExp): boolean {\n\tlet didSkip = false;\n\n\twhile (lines.length && lines[0].match(pattern)) {\n\t\tlines.shift();\n\t\tdidSkip = true;\n\t}\n\n\treturn didSkip;\n}\n\nfunction collapseEmptyLines(message: Message, lines: string[]): boolean {\n\tlet didCollapse = false;\n\n\tif (lines.length && lines[0].match(/^\\s*$/)) {\n\t\tmessage.body += '\\n';\n\t\tdidCollapse = true;\n\n\t\tskipEmptyLines(lines);\n\t}\n\n\treturn didCollapse;\n}\n\nfunction parseTicket(message: Message, lines: string[]): boolean {\n\tif (lines.length) {\n\t\tconst match = lines[0].match(/ticket\\s*:\\s*(http.*)/i);\n\n\t\tif (!match) {\n\t\t\treturn false;\n\t\t}\n\n\t\tmessage.ticket = match[1].trim();\n\t\tlines.shift();\n\t}\n\n\treturn true;\n}\n\nfunction parseExtra(message: Message, lines: string[]) {\n\tif (lines.length) {\n\t\tconst match = lines[0].match(/^([^:]+):\\s*(http.*)/i);\n\n\t\tif (!match) {\n\t\t\treturn false;\n\t\t}\n\n\t\tconst key = match[1].trim();\n\t\tconst value = match[2].trim();\n\n\t\tmessage.extra[key] = message.extra[key] ?? [];\n\t\tmessage.extra[key].push(value);\n\n\t\tlines.shift();\n\t}\n\n\treturn true;\n}\n\nfunction parseBody(message: Message, lines: string[]): boolean {\n\tconst nextLine = lines.shift();\n\n\tif (nextLine !== undefined) {\n\t\tmessage.body += `${nextLine}\\n`\n\t}\n\n\treturn nextLine !== undefined;\n}\n\nexport default Parse;\n","import type { ProjectRef, Ref, SHA } from '../../services/gitlab/types';\nimport GitLab from '../../services/gitlab/gitlab';\nimport CherryPicks from './cherry-picks';\nimport type { Base, Comment } from './types';\nimport Parse from './parse';\n\nconst Comments = {\n\tasync assembleBase(project: ProjectRef, sha: SHA): Promise<Base<Ref[]>> {\n\t\tconst commit = await GitLab.commits.findBySHA(project, sha);\n\n\t\tconst [\n\t\t\tbranches,\n\t\t\tcherryPicks,\n\t\t\tmergeRequests,\n\t\t] = await Promise.all([\n\t\t\tGitLab.commits.refs(project, commit.id, 'all'),\n\t\t\tCherryPicks.findRefs(project, commit.id),\n\t\t\tGitLab.commits.mergeRequests(project, commit.id),\n\t\t]);\n\n\t\treturn {commit, branches, cherryPicks, mergeRequests};\n\t},\n\tasync assembleComment(project: ProjectRef, base: Base<Ref>): Promise<Comment> {\n\t\tconst [branch, cherryPicks] = await Promise.all([\n\t\t\tGitLab.branches.findByName(project, base.branch.name),\n\t\t\tCherryPicks.deRefAll(project, base.cherryPicks),\n\t\t]);\n\t\tconst message = Parse.message(base.commit);\n\n\t\treturn {\n\t\t\tcommit: base.commit,\n\t\t\tbranch,\n\t\t\tcherryPicks,\n\t\t\tmergeRequests: base.mergeRequests,\n\t\t\ttitle: message.title,\n\t\t\tbody: message.body,\n\t\t\tticket: message.ticket,\n\t\t\textra: message.extra,\n\t\t};\n\t},\n\ttryAutoResolveBase(base: Base<Ref[]>): Base<Ref>|null {\n\t\tif (\n\t\t\tbase.branches.length > 1\n\t\t\t|| base.cherryPicks.some(cherryPick => cherryPick.branches.length > 1)\n\t\t) {\n\t\t\treturn null;\n\t\t}\n\n\t\treturn this.resolveBaseUsingFirst(base);\n\t},\n\tresolveBaseUsingFirst(base: Base<Ref[]>): Base<Ref> {\n\t\treturn {\n\t\t\tcommit: base.commit,\n\t\t\tbranch: base.branches[0],\n\t\t\tcherryPicks: base.cherryPicks.map(cherryPick => ({\n\t\t\t\tcommit: cherryPick.commit,\n\t\t\t\tbranch: cherryPick.branches[0],\n\t\t\t})),\n\t\t\tmergeRequests: base.mergeRequests,\n\t\t};\n\t},\n} as const;\n\nexport default Comments;\n","<script lang=\"ts\" module>\n    import type { ProjectRef, SHA } from '@gitlab/types';\n\n    export type Args = {\n        projectRef: ProjectRef,\n        sha: SHA,\n    };\n</script>\n\n<script lang=\"ts\">\n    import Modal from '@gitlab/ui/modal';\n    import Loading from './Steps/Loading.svelte';\n    import Result from './Steps/Result.svelte';\n    import Comments from '../../comments';\n    import type { Comment } from '../../types';\n\n    type Props = {\n        args?: Args,\n    };\n\n    type Step = (\n        | { type: 'closed' }\n        | { type: 'loading', project: ProjectRef, commit: SHA }\n        | { type: 'result', comment: Comment }\n    );\n\n    let { args = $bindable() }: Props = $props();\n    let step: Step = $state({ type: 'closed' });\n\n    async function start(project: ProjectRef, commit: SHA): Promise<void> {\n        setLoadingState(project, commit);\n\n        const base = await Comments.assembleBase(project, commit);\n        // const autoResolvedBase = Comments.tryAutoResolveBase(base);\n        const autoResolvedBase = Comments.resolveBaseUsingFirst(base);\n\n        if (autoResolvedBase !== null) {\n            const comment = await Comments.assembleComment(project, autoResolvedBase);\n            setResultState(comment);\n        } else {\n            // TODO: Implement modal\n            console.error('Comment could not be auto-resolved');\n        }\n    }\n\n    function setLoadingState(project: ProjectRef, commit: SHA): void {\n        step = { type: 'loading', project, commit };\n    }\n\n    function setResultState(comment: Comment): void {\n        step = { type: 'result', comment };\n    }\n\n    $effect(() => {\n        if (args !== undefined) {\n            start(args.projectRef, args.sha);\n        }\n    });\n\n    function onOpenChange(newIsOpen: boolean): void {\n        if (!newIsOpen) {\n            closeModal();\n        }\n    }\n\n    function closeModal(): void {\n        step = { type: 'closed' };\n        args = undefined;\n    }\n</script>\n\n<Modal.Root open={step.type !== 'closed'} onOpenChange={onOpenChange}>\n    <Modal.Portal>\n        <Modal.Overlay />\n\n        <Modal.Content size=\"sm\">\n            <Modal.Header>\n                <Modal.Title>Generate ticket comment</Modal.Title>\n                <Modal.CloseIcon />\n            </Modal.Header>\n            <Modal.Body>\n                {#if step.type === 'loading'}\n                    <Loading />\n                {:else if step.type === 'result'}\n                    <Result comment={step.comment} />\n                {/if}\n            </Modal.Body>\n            <Modal.Footer>\n                <Modal.Close />\n            </Modal.Footer>\n        </Modal.Content>\n    </Modal.Portal>\n</Modal.Root>\n","<script lang=\"ts\">\n    import GenerateTicketCommentModal from './generate-ticket-comment/GenerateTicketCommentModal.svelte';\n    import type { Controls } from './types';\n\n    type Props = {\n        controls: Controls,\n    };\n\n    let { controls }: Props = $props();\n</script>\n\n<GenerateTicketCommentModal bind:args={controls.generateTicketCommentModal.args} />\n","import type { Args } from './GenerateTicketCommentModal.svelte';\n\nexport type GenerateTicketCommentModalControls = {\n\treadonly args: Args | undefined,\n\topen: (args: Args) => void,\n\tclose: () => void,\n};\n\nfunction makeControls(): GenerateTicketCommentModalControls {\n\tlet state: Args | undefined = $state(undefined);\n\n\tfunction open(args: Args): void {\n\t\tstate = args;\n\t}\n\n\tfunction close(): void {\n\t\tstate = undefined;\n\t}\n\n\treturn {\n\t\tget args() { return state },\n\t\topen,\n\t\tclose,\n\t};\n}\n\nexport default makeControls;\n","import FeatureDropdown from './FeatureDropdown.svelte';\nimport { mount } from 'svelte';\nimport Current from '../current';\nimport Modals from './Modals.svelte';\nimport makeGenerateTicketCommentModalControls from './generate-ticket-comment/controls.svelte';\nimport type { Controls } from './types';\n\nfunction inject(): void {\n\tconst controls = makeControls();\n\n\tinjectOnCommitDetailPage(controls);\n\tinjectToProjectLastCommit(controls);\n\tinjectModals(controls);\n}\n\nfunction makeControls(): Controls {\n\treturn {\n\t\tgenerateTicketCommentModal: makeGenerateTicketCommentModalControls(),\n\t};\n}\n\nfunction injectOnCommitDetailPage(controls: Controls): void {\n\ttry {\n\t\tconst header = document.querySelector('.page-content-header');\n\n\t\tif (!header) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst projectRef = Current.projects.ref();\n\t\tconst sha = Current.commits.sha();\n\n\t\tmount(FeatureDropdown, {\n\t\t\ttarget: header,\n\t\t\tprops: {\n\t\t\t\tclass: 'gl-ml-3',\n\t\t\t\tfeatures: [\n\t\t\t\t\t{\n\t\t\t\t\t\ticon: 'comment-lines',\n\t\t\t\t\t\ttitle: 'Generate ticket comment',\n\t\t\t\t\t\tonClick(): void {\n\t\t\t\t\t\t\tcontrols.generateTicketCommentModal.open({ projectRef, sha });\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t},\n\t\t});\n\t} catch (error) {\n\t\tconsole.error(error);\n\t}\n}\n\nfunction injectToProjectLastCommit(controls: Controls): void {\n\ttry {\n\t\tconst group = document.querySelector([\n\t\t\t'.project-last-commit .js-commit-sha-group',\n\t\t\t'.blob-commit-info .commit-sha-group',\n\t\t].join(', '));\n\n\t\tif (!group) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst shaElement = group.querySelector('[data-clipboard-text]');\n\n\t\tif (!shaElement || !(shaElement instanceof HTMLElement)) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst projectRef = Current.projects.ref();\n\t\tconst sha = shaElement.dataset.clipboardText ?? '';\n\n\t\tmount(FeatureDropdown, {\n\t\t\ttarget: group,\n\t\t\tprops: {\n\t\t\t\tfeatures: [\n\t\t\t\t\t{\n\t\t\t\t\t\ticon: 'comment-lines',\n\t\t\t\t\t\ttitle: 'Generate ticket comment',\n\t\t\t\t\t\tonClick(): void {\n\t\t\t\t\t\t\tcontrols.generateTicketCommentModal.open({ projectRef, sha });\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t},\n\t\t});\n\t} catch (error) {\n\t\tconsole.error(error);\n\t}\n}\n\nfunction injectModals(controls: Controls): void {\n\tconst modalsContainer = document.createElement('div');\n\tmodalsContainer.id = 'daktela-modals';\n\n\tdocument.body.appendChild(modalsContainer);\n\n\tmount(Modals, {\n\t\ttarget: modalsContainer,\n\t\tprops: {\n\t\t\tcontrols,\n\t\t},\n\t});\n}\n\nexport default inject;\n","import './styles.css';\n// import injectCopyCommitAsComment from './features/copy-commit-as-comment/inject';\nimport injectTest from './features/inject';\n\n// injectCopyCommitAsComment();\ninjectTest();\n"],"names":["PUBLIC_VERSION","EACH_ITEM_REACTIVE","EACH_INDEX_REACTIVE","EACH_ITEM_IMMUTABLE","PROPS_IS_IMMUTABLE","PROPS_IS_RUNES","PROPS_IS_UPDATED","PROPS_IS_BINDABLE","PROPS_IS_LAZY_INITIAL","TRANSITION_IN","TRANSITION_OUT","TRANSITION_GLOBAL","TEMPLATE_FRAGMENT","TEMPLATE_USE_IMPORT_NODE","UNINITIALIZED","NAMESPACE_SVG","DEV","is_array","array_from","define_property","get_descriptor","get_descriptors","object_prototype","array_prototype","get_prototype_of","is_function","thing","noop","run","fn","run_all","arr","i","DERIVED","EFFECT","RENDER_EFFECT","BLOCK_EFFECT","BRANCH_EFFECT","ROOT_EFFECT","UNOWNED","DISCONNECTED","CLEAN","DIRTY","MAYBE_DIRTY","INERT","DESTROYED","EFFECT_RAN","EFFECT_TRANSPARENT","LEGACY_DERIVED_PROP","HEAD_EFFECT","EFFECT_HAS_DERIVED","STATE_SYMBOL","LOADING_ATTR_SYMBOL","equals","value","safe_not_equal","a","b","safe_equals","effect_in_teardown","rune","effect_in_unowned_derived","effect_orphan","effect_update_depth_exceeded","props_invalid_value","key","state_descriptors_fixed","state_prototype_fixed","state_unsafe_local_read","state_unsafe_mutation","source","v","state","push_derived_source","mutable_source","initial_value","immutable","_a","s","component_context","mutable_state","active_reaction","derived_sources","set_derived_sources","set","is_runes","e.state_unsafe_mutation","internal_set","increment_version","mark_reactions","active_effect","new_deps","set_signal_status","schedule_effect","untracked_writes","set_untracked_writes","signal","status","reactions","runes","length","reaction","flags","derived","derived_safe_equal","destroy_derived_children","children","child","destroy_derived","destroy_effect","execute_derived","prev_active_effect","set_active_effect","update_reaction","update_derived","skip_reaction","remove_reactions","validate_effect","e.effect_orphan","e.effect_in_unowned_derived","is_destroying_effect","e.effect_in_teardown","push_effect","effect","parent_effect","parent_last","create_effect","type","sync","push","is_root","previously_flushing_effect","is_flushing_effect","set_is_flushing_effect","update_effect","e","inert","teardown","user_effect","defer","context","user_pre_effect","render_effect","effect_root","legacy_pre_effect","deps","token","untrack","legacy_pre_effect_reset","get","check_dirtiness","template_effect","block","branch","execute_effect_teardown","previously_destroying_effect","previous_reaction","set_is_destroying_effect","set_active_reaction","destroy_effect_deriveds","deriveds","destroy_effect_children","remove_dom","next","destroy_block_effect_children","removed","node","end","get_next_sibling","transitions","transition","parent","unlink_effect","prev","pause_effect","callback","pause_children","run_out_transitions","remaining","check","local","sibling","transparent","resume_effect","resume_children","is_micro_task_queued","current_queued_micro_tasks","process_micro_tasks","tasks","queue_micro_task","flush_tasks","lifecycle_outside_component","name","FLUSH_MICROTASK","FLUSH_SYNC","scheduler_mode","queued_root_effects","flush_count","sources","skipped_deps","current_version","_b","dependencies","is_unowned","dependency","handle_error","error","previous_deps","previous_skipped_deps","previous_untracked_writes","previous_skip_reaction","prev_derived_sources","result","remove_reaction","index","new_length","start_index","previous_effect","previous_component_context","infinite_loop_guard","e.effect_update_depth_exceeded","flush_queued_root_effects","root_effects","collected_effects","process_effects","flush_queued_effects","effects","process_deferred","previous_queued_root_effects","current_effect","main_loop","is_branch","is_skippable_branch","parent_sibling","flush_sync","previous_scheduler_mode","tick","is_derived","e.state_unsafe_local_read","STATUS_MASK","getContext","get_or_init_context_map","setContext","get_parent_context","context_map","update","d","props","pop","component","context_stack_item","component_effects","component_effect","deep_read_state","deep_read","prop","visited","proto","descriptors","proxy","prototype","is_proxied_array","version","metadata","_","descriptor","e.state_descriptors_fixed","target","ls","n","update_version","receiver","exists","has","other_s","own_keys","e.state_prototype_fixed","$window","first_child_getter","next_sibling_getter","init_operations","element_prototype","node_prototype","create_text","get_first_child","first_child","fragment","is_text","first","count","next_sibling","clear_text_content","hydrating","all_registered_events","root_event_handles","create_event","event_name","dom","handler","options","target_handler","event","handle_event_propagation","capture","passive","delegate","events","handler_element","owner_document","path","current_target","path_idx","handled_at","at_idx","handler_idx","throw_error","other_errors","parent_element","delegated","data","create_fragment_from_html","html","elem","assign_nodes","start","template","content","is_fragment","use_import_node","has_start","clone","ns_template","ns","wrapped","root","text","t","comment","frag","anchor","append","is_capture_event","DELEGATED_EVENTS","is_delegated","ATTRIBUTE_ALIASES","normalize_attribute","PASSIVE_EVENTS","is_passive_event","should_intro","set_should_intro","set_text","str","mount","_mount","document_listeners","Component","intro","registered_events","event_handle","unmount","anchor_node","ctx","mounted_components","if_block","get_condition","consequent_fn","alternate_fn","elseif","consequent_effect","alternate_effect","condition","current_each_item","set_current_each_item","item","pause_effects","items","controlled_anchor","items_map","is_controlled","parent_node","link","each","get_collection","get_key","render_fn","fallback_fn","fallback","was_empty","collection","array","reconcile","current","seen","matched","stashed","child_anchor","create_item","update_item","j","move","to_destroy","destroy_length","previous_each_item","reactive","mutable","dest","next_node","slot","$$props","slot_props","slot_fn","is_interop","snippet","get_snippet","args","snippet_effect","get_component","element","get_tag","is_svg","get_namespace","location","tag","current_tag","each_item_block","next_tag","action","get_value","payload","autofocus","body","set_value","attributes","set_attribute","attribute","skip_warning","get_setters","set_attributes","css_hash","preserve_attribute_case","is_custom_element","is_option_element","setters","prev_value","prefix","opts","event_handle_key","handle","evt","setters_cache","element_proto","set_svg_class","prev_class_name","next_class_name","to_class","set_class","request_animation_frame","now","raf","run_tasks","task","loop","fulfill","dispatch_event","css_style_from_camel_case","style","parts","word","css_to_keyframe","css","keyframe","part","property","formatted_property","linear","get_fn","get_params","is_intro","is_outro","is_both","is_global","direction","current_options","outro","get_options","animate","counterpart","t2","on_finish","aborted","o","delay","easing","keyframes","styles","get_t","animation","t1","delta","duration","time","is_bound_this","bound_value","element_or_component","bind_this","get_parts","old_parts","init","callbacks","changed","observe_all","fns","bubble_event","legacy_rest_props_handler","legacy_rest_props","exclude","with_parent_branch","bindable","lazy","prop_value","setter","fallback_value","fallback_dirty","fallback_used","get_fallback","e.props_invalid_value","getter","derived_getter","legacy_parent","mutation","from_child","was_from_child","inner_current_value","current_value","parent_value","child_value","current_derived","new_value","subscribe_to_store","store","invalidate","unsub","store_get","store_name","stores","entry","is_synchronous_callback","setup_stores","last","wrapArray","startIndex","styleToString","disabledAttr","disabled","portalAttr","portal","subscriber_queue","readable","writable","stop","subscribers","run_queue","subscriber","subscribe","single","stores_array","auto","started","values","pending","cleanup","unsubscribers","readonly","lightable","hiddenAction","obj","isFunctionWithParams","makeElement","returned","derivedStore","returnedFn","resultFn","actionFn","createElHelpers","selector","isBrowser","isFunction","isElement","isHTMLElement","isElementDisabled","ariaDisabled","dataDisabled","isObject","isReadable","executeCallbacks","addEventListener","_event","addMeltEventListener","handlerWithMelt","withMelt","dispatchMeltEvent","originalEvent","customMeltEvent","customEvent","addHighlight","removeHighlight","onMount","init_update_callbacks","onDestroy","create_custom_event","detail","bubbles","cancelable","createEventDispatcher","active_component_context","l","safeOnMount","safeOnDestroy","omit","keys","withGet","initial","internal","newValue","updater","unsubscribe","overridable","_store","onChange","sideEffect","curr","res","sleep","ms","resolve","urlAlphabet","nanoid","size","id","generateId","generateIds","acc","kbd","FIRST_KEYS","LAST_KEYS","FIRST_LAST_KEYS","SELECTION_KEYS","debounce","wait","timeout","later","isDom","getPlatform","agent","pt","isTouchDevice","isMac","isApple","isIos","LOCK_CLASSNAME","assignStyle","el","previousStyle","setCSSProperty","previousValue","getPaddingProperty","documentElement","documentLeft","removeScroll","_document","doc","win","scrollbarWidth","setScrollbarWidthProperty","paddingProperty","scrollbarSidePadding","setStyle","setIOSStyle","scrollX","scrollY","visualViewport","offsetLeft","offsetTop","restoreStyle","cleanups","derivedVisible","open","forceVisible","activeTrigger","$open","$forceVisible","$activeTrigger","cb","destroy","toWritableStores","properties","propertyKey","handleRovingFocus","nextElement","currentFocusedElement","getFocusableElements","getNextFocusable","currentElement","focusableElements","nextIndex","getPreviousFocusable","previousIndex","prevElement","ignoredKeys","defaults","createTypeaheadSearch","withDefaults","typed","resetTyped","currentItem","$typed","candidateItems","normalizeSearch","char","currentItemIndex","wrappedItems","nextItem","getPortalParent","getPortalDestination","portalProp","handleFocus","defaultEl","clicked","documentEscapeKeyStore","keydown","useEscapeKeydown","config","enabled","ignoreEl","$enabled","min","max","round","floor","createCoords","oppositeSideMap","oppositeAlignmentMap","clamp","evaluate","param","getSide","placement","getAlignment","getOppositeAxis","axis","getAxisLength","getSideAxis","getAlignmentAxis","getAlignmentSides","rects","rtl","alignment","alignmentAxis","mainAlignmentSide","getOppositePlacement","getExpandedPlacements","oppositePlacement","getOppositeAlignmentPlacement","getSideList","side","isStart","lr","rl","tb","bt","getOppositeAxisPlacements","flipAlignment","list","expandPaddingObject","padding","getPaddingObject","rectToClientRect","rect","x","y","width","height","computeCoordsFromPlacement","_ref","reference","floating","sideAxis","alignLength","isVertical","commonX","commonY","commonAlign","coords","computePosition","strategy","middleware","platform","validMiddleware","statefulPlacement","middlewareData","resetCount","nextX","nextY","reset","detectOverflow","_await$platform$isEle","elements","boundary","rootBoundary","elementContext","altBoundary","paddingObject","clippingClientRect","offsetParent","offsetScale","elementClientRect","arrow","arrowDimensions","isYAxis","minProp","maxProp","clientProp","endDiff","startDiff","arrowOffsetParent","clientSize","centerToReference","largestPossiblePadding","minPadding","maxPadding","min$1","center","offset","shouldAddOffset","alignmentOffset","flip","_middlewareData$arrow","_middlewareData$flip","initialPlacement","checkMainAxis","checkCrossAxis","specifiedFallbackPlacements","fallbackStrategy","fallbackAxisSideDirection","detectOverflowOptions","initialSideAxis","isBasePlacement","fallbackPlacements","hasFallbackAxisSideDirection","placements","overflow","overflows","overflowsData","sides","_middlewareData$flip2","_overflowsData$filter","nextPlacement","resetPlacement","_overflowsData$filter2","currentSideAxis","convertValueToCoords","mainAxisMulti","crossAxisMulti","rawValue","mainAxis","crossAxis","_middlewareData$offse","diffCoords","shift","limiter","mainAxisCoord","crossAxisCoord","minSide","maxSide","limitedCoords","_state$middlewareData","_state$middlewareData2","apply","heightSide","widthSide","maximumClippingHeight","maximumClippingWidth","overflowAvailableHeight","overflowAvailableWidth","noShift","availableHeight","availableWidth","xMin","xMax","yMin","yMax","nextDimensions","hasWindow","getNodeName","isNode","getWindow","_node$ownerDocument","getDocumentElement","isShadowRoot","isOverflowElement","overflowX","overflowY","display","getComputedStyle","isTableElement","isTopLayer","isContainingBlock","elementOrCss","webkit","isWebKit","getContainingBlock","currentNode","getParentNode","isLastTraversableNode","getNodeScroll","getNearestOverflowAncestor","parentNode","getOverflowAncestors","traverseIframes","_node$ownerDocument2","scrollableAncestor","isBody","frameElement","getFrameElement","getCssDimensions","hasOffset","offsetWidth","offsetHeight","shouldFallback","unwrapElement","getScale","domElement","$","noOffsets","getVisualOffsets","shouldAddVisualOffsets","isFixed","floatingOffsetParent","getBoundingClientRect","includeScale","isFixedStrategy","clientRect","scale","visualOffsets","offsetWin","currentWin","currentIFrame","iframeScale","iframeRect","left","top","convertOffsetParentRelativeRectToViewportRelativeRect","topLayer","scroll","offsets","isOffsetParentAnElement","offsetRect","getClientRects","getWindowScrollBarX","leftScroll","getDocumentRect","getViewportRect","visualViewportBased","getInnerBoundingClientRect","getClientRectFromClippingAncestor","clippingAncestor","hasFixedPositionAncestor","stopNode","getClippingElementAncestors","cache","cachedResult","currentContainingBlockComputedStyle","elementIsFixed","computedStyle","currentNodeIsContaining","ancestor","getClippingRect","clippingAncestors","firstClippingAncestor","clippingRect","accRect","getDimensions","getRectRelativeToOffsetParent","htmlX","htmlY","htmlRect","isStaticPositioned","getTrueOffsetParent","polyfill","rawOffsetParent","getOffsetParent","svgOffsetParent","getElementRects","getOffsetParentFn","getDimensionsFn","floatingDimensions","isRTL","observeMove","onMove","io","timeoutId","_io","refresh","skip","threshold","insetTop","insetRight","insetBottom","insetLeft","isFirstUpdate","handleObserve","entries","ratio","autoUpdate","ancestorScroll","ancestorResize","elementResize","layoutShift","animationFrame","referenceEl","ancestors","cleanupIo","reobserveFrame","resizeObserver","firstEntry","_resizeObserver","frameId","prevRefRect","frameLoop","nextRefRect","_resizeObserver2","offset$1","shift$1","flip$1","size$1","arrow$1","mergedOptions","platformWithCache","computePosition$1","defaultConfig","ARROW_TRANSFORM","useFloating","arrowEl","arrowOffset","compute","align","getSideAndAlignFromPlacement","dir","candidateSelectors","candidateSelector","NoElement","matches","getRootNode","_element$getRootNode","isInert","lookUp","_node$getAttribute","inertAtt","isContentEditable","_node$getAttribute2","attValue","getCandidates","includeContainer","filter","candidates","getCandidatesIteratively","elementsToCheck","assigned","nestedCandidates","validCandidate","shadowRoot","validShadowRoot","_nestedCandidates","hasTabIndex","getTabIndex","getSortOrderTabIndex","isScope","tabIndex","sortOrderedTabbables","isInput","isHiddenInput","isDetailsWithSummary","r","getCheckedRadio","nodes","form","isTabbableRadio","radioScope","queryRadios","radioSet","err","checked","isRadio","isNonTabbableRadio","isNodeAttached","_nodeRoot","nodeRoot","nodeRootHost","attached","_nodeRootHost","_nodeRootHost$ownerDo","_nodeRoot2","_nodeRootHost2","_nodeRootHost2$ownerD","isZeroArea","_node$getBoundingClie","isHidden","displayCheck","getShadowRoot","isDirectSummary","nodeUnderDetails","originalNode","parentElement","rootNode","isDisabledFromFieldset","isNodeMatchingSelectorFocusable","isNodeMatchingSelectorTabbable","isValidShadowRootTabbable","shadowHostNode","sortByOrder","regularTabbables","orderedTabbables","candidateTabindex","sortable","tabbable","container","focusable","isTabbable","focusableCandidateSelector","isFocusable","_defineProperty","_toPropertyKey","ownKeys","_objectSpread2","_toPrimitive","activeFocusTraps","trapStack","trap","activeTrap","trapIndex","isSelectableInput","isEscapeEvent","isTabEvent","isKeyForward","isKeyBackward","findIndex","idx","valueOrHandler","_len","params","_key","getActualTarget","internalTrapStack","createFocusTrap","userOptions","getOption","configOverrideOptions","optionName","configOptionName","findContainerIndex","composedPath","tabbableNodes","getNodeForOption","optionValue","_len2","_key2","getInitialFocusNode","firstTabbableGroup","firstTabbableNode","updateTabbableNodes","focusableNodes","lastTabbableNode","firstDomTabbableNode","lastDomTabbableNode","posTabIndexesFound","forward","nodeIdx","group","g","_getActiveElement","activeElement","_tryFocus","getReturnFocusNode","previousActiveElement","findNextNavNode","_ref2","_ref2$isBackward","isBackward","destinationNode","containerIndex","containerGroup","startOfGroupIndex","_ref3","destinationGroupIndex","destinationGroup","lastOfGroupIndex","_ref4","_destinationGroupIndex","_destinationGroup","checkPointerDown","checkFocusIn","targetContained","nextNode","navAcrossContainers","mruContainerIdx","mruTabIdx","checkKeyNav","checkTabKey","checkEscapeKey","checkClick","addListeners","removeListeners","checkDomRemoval","mutations","isFocusedNodeRemoved","removedNodes","mutationObserver","updateObservedNodes","activateOptions","onActivate","onPostActivate","checkCanFocusTrap","finishActivation","deactivateOptions","onDeactivate","onPostDeactivate","checkCanReturnFocus","returnFocus","finishDeactivation","pauseOptions","onPause","onPostPause","unpauseOptions","onUnpause","onPostUnpause","containerElements","elementsAsArray","immediate","focusTrapOptions","hasFocus","isPaused","activate","deactivate","pause","unpause","_createFocusTrap","visibleModals","useModal","unsubInteractOutside","removeNodeFromVisibleModals","onClose","shouldCloseOnInteractOutside","closeOnInteractOutside","isLastModal","closeModal","onInteractOutsideStart","onInteractOutside","useInteractOutside","usePopper","popperElement","anchorElement","usePortal","useFocusTrap","targetEl","newTarget","unsubClick","isPointerDown","isPointerDownInside","ignoreEmulatedMouseEvents","onPointerDown","isValidEvent","isOrContainsTarget","triggerInteractOutside","documentObj","getOwnerDocument","onPointerUp","shouldTriggerInteractOutside","resetPointerState","onMouseUp","onTouchEnd","ownerDocument","SUB_OPEN_KEYS","SUB_CLOSE_KEYS","menuIdParts","createMenuBuilder","preventScroll","arrowSize","positioning","closeOnEscape","closeOnOutsideClick","typeahead","closeFocus","disableFocusFirstItem","closeOnItemClick","onOutsideClick","rootOpen","rootActiveTrigger","nextFocusable","prevFocusable","isUsingKeyboard","lastPointerX","pointerGraceIntent","pointerDir","currentFocusedItem","pointerMovingToSubmenu","$pointerDir","$pointerGraceIntent","isPointerInGraceArea","handleTypeaheadSearch","rootIds","isVisible","rootMenu","$isVisible","$portal","$rootMenuId","$rootTriggerId","unsubPopper","unsubDerived","$rootActiveTrigger","$positioning","$closeOnOutsideClick","$closeOnEscape","setMeltMenuAttribute","unsubEvents","menuEl","handleMenuNavigation","handleTabNavigation","isCharacterKey","getMenuItems","rootTrigger","$rootOpen","applyAttrsIfDisabled","p","triggerEl","handleOpen","menuId","menu","menuItems","rootArrow","$arrowSize","overlay","stateAttr","unsubEscapeKeydown","escapeKeydown","unsubPortal","portalDestination","itemEl","onItemKeyDown","onMenuItemPointerMove","onMenuItemPointerLeave","onItemFocusIn","onItemFocusOut","groupId","groupLabel","checkboxItemDefaults","createCheckboxItem","checkedWritable","checkboxItem","$checked","$disabled","isIndeterminate","getCheckedState","onItemLeave","isChecked","_isIndeterminate","createMenuRadioGroup","valueWritable","radioGroup","radioItemDefaults","radioItem","$value","itemProps","itemValue","separator","createSeparator","subMenuDefaults","createSubmenu","subOpenWritable","subOpen","subActiveTrigger","subOpenTimer","pointerGraceTimer","subIds","subTrigger","subIsVisible","subMenu","$subIsVisible","$subMenuId","$subTriggerId","parentMenuEl","getParentMenu","isCloseKey","isModifierKey","$subActiveTrigger","onMenuPointerMove","submenuEl","relatedTarget","$subOpen","unsubTimer","clearTimerStore","firstItem","isMouse","onItemEnter","isFocusWithinSubmenu","openTimer","contentRect","rightSide","bleed","contentNearEdge","contentFarEdge","onTriggerLeave","subArrow","focusedItem","subTriggerEl","unsubs","handlePointer","handleKeyDown","keydownListener","$currentFocusedItem","$closeFocus","$preventScroll","isOpen","isPointerMovingToSubmenu","currentTarget","$lastPointerX","pointerXHasChanged","newDir","currTarget","$prevFocusable","$nextFocusable","menuElement","timerStore","timer","candidateNodes","currentIndex","area","cursorPos","isPointInPolygon","point","polygon","inside","xi","yi","xj","yj","submenuId","activeEl","calendarDefaults","dialogIdParts","createDialog","role","openFocus","ids","openWritable","unsubScroll","handleClose","trigger","$contentId","$descriptionId","$titleId","focusTrap","ac","portalled","title","description","close","contentEl","createDropdownMenu","rootOptions","builders","states","orientation","decorative","$orientation","$decorative","createBitAttrs","bit","attrs","disabledAttrs","createDispatcher","dispatch","removeUndefined","getOptionUpdater","getPositioningUpdater","updatePositioning","joinPlacement","getMenuData","getCtx","NAME","setCtx","PARTS","getAttrs","dropdownMenu","href","asChild","$.set","builder","$item","$.get","$$element","$$anchor","$.bind_this","$$value","$$restProps","getDialogData","dialog","onOpenChange","localOpen","updateOption","idValues","$idValues","level","$title","$.template_effect","$.set_attributes","$.NAMESPACE_SVG","$close","button","$portalled","div","transitionConfig","inTransition","inTransitionConfig","outTransition","outTransitionConfig","$content","div_1","attributes_1","div_2","attributes_2","div_3","attributes_3","div_4","attributes_4","$overlay","$menuId","$triggerId","sideOffset","alignOffset","collisionPadding","avoidCollisions","collisionBoundary","sameWidth","fitViewport","overlap","$menu","$trigger","map","className","$.set_svg_class","svg","Dropdown","DropdownMenu.Root","Trigger","Content","Item","$.each","node_3","feature","$.set_text","Current","Modal","Dialog.Root","Dialog.Portal","Overlay","Header","Title","Close","CloseIcon","Body","Footer","BODY_FONTS","BODY_STYLES","render","renderTitle","renderCommits","renderMergeRequests","renderExtra","renderBody","renderListWithTitle","renderCBs","cbs","renderBranch","renderCommit","renderAnchor","commit","linkify","mr","linkifyAll","allowCollapse","renderList","url","copy","rendered","renderComment","BASE_URL","GitLab","project","sha","endpoint","query","CherryPicks","SHAs","findSHAsForCommit","cherryPickSHA","branches","cherryPicks","cherryPick","comments","parseSHAsFromComments","Parse","message","lines","line","skipEmptyLines","parseTitle","processNextLine","skipCherryPicks","collapseEmptyLines","parseTicket","parseExtra","parseBody","skipWithPattern","pattern","didSkip","didCollapse","match","nextLine","Comments","mergeRequests","base","$.prop","step","$.state","$.proxy","setLoadingState","autoResolvedBase","setResultState","$.user_effect","newIsOpen","controls","makeControls","inject","injectOnCommitDetailPage","injectToProjectLastCommit","injectModals","makeGenerateTicketCommentModalControls","header","projectRef","FeatureDropdown","shaElement","modalsContainer","Modals","injectTest"],"mappings":"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","x_google_ignoreList":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107]}