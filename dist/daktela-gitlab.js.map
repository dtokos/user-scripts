{"version":3,"file":"daktela-gitlab.js","sources":["../node_modules/svelte/src/version.js","../node_modules/svelte/src/internal/disclose-version.js","../node_modules/svelte/src/constants.js","../node_modules/esm-env/browser.js","../node_modules/svelte/src/internal/shared/utils.js","../node_modules/svelte/src/internal/client/constants.js","../node_modules/svelte/src/internal/client/reactivity/equality.js","../node_modules/svelte/src/internal/client/errors.js","../node_modules/svelte/src/internal/client/reactivity/sources.js","../node_modules/svelte/src/internal/client/reactivity/deriveds.js","../node_modules/svelte/src/internal/client/reactivity/effects.js","../node_modules/svelte/src/internal/client/dom/task.js","../node_modules/svelte/src/internal/shared/errors.js","../node_modules/svelte/src/internal/client/runtime.js","../node_modules/svelte/src/internal/client/proxy.js","../node_modules/svelte/src/internal/client/dom/operations.js","../node_modules/svelte/src/internal/client/dom/hydration.js","../node_modules/svelte/src/internal/client/dom/elements/events.js","../node_modules/svelte/src/internal/client/dom/reconciler.js","../node_modules/svelte/src/internal/client/dom/template.js","../node_modules/svelte/src/utils.js","../node_modules/svelte/src/internal/client/render.js","../node_modules/svelte/src/internal/client/dom/blocks/if.js","../node_modules/svelte/src/internal/client/dom/blocks/key.js","../node_modules/svelte/src/internal/client/dom/blocks/each.js","../node_modules/svelte/src/internal/client/dom/blocks/snippet.js","../node_modules/svelte/src/internal/client/dom/blocks/svelte-component.js","../node_modules/svelte/src/internal/client/dom/elements/misc.js","../node_modules/svelte/src/internal/client/dom/elements/attributes.js","../node_modules/svelte/src/internal/client/dom/elements/class.js","../node_modules/svelte/src/index-client.js","../node_modules/svelte/src/internal/client/reactivity/store.js","../node_modules/svelte/src/internal/client/reactivity/props.js","../node_modules/svelte-toolbelt/dist/utils/is.js","../node_modules/svelte-toolbelt/dist/box/box.svelte.js","../node_modules/svelte-toolbelt/dist/utils/compose-handlers.js","../node_modules/inline-style-parser/index.js","../node_modules/style-to-object/cjs/index.js","../node_modules/style-to-object/esm/index.mjs","../node_modules/svelte-toolbelt/dist/utils/strings.js","../node_modules/svelte-toolbelt/dist/utils/css-to-style-obj.js","../node_modules/svelte-toolbelt/dist/utils/execute-callbacks.js","../node_modules/clsx/dist/clsx.mjs","../node_modules/svelte-toolbelt/dist/utils/style-to-css.js","../node_modules/svelte-toolbelt/dist/utils/style.js","../node_modules/svelte-toolbelt/dist/utils/merge-props.js","../node_modules/svelte-toolbelt/dist/utils/use-ref-by-id.svelte.js","../node_modules/svelte-toolbelt/dist/utils/on-destroy-effect.svelte.js","../node_modules/svelte-toolbelt/dist/utils/after-sleep.js","../node_modules/svelte-toolbelt/dist/utils/after-tick.js","../node_modules/bits-ui/dist/internal/attrs.js","../node_modules/bits-ui/dist/internal/kbd-constants.js","../node_modules/bits-ui/dist/internal/locale.js","../node_modules/bits-ui/dist/internal/get-directional-keys.js","../node_modules/bits-ui/dist/internal/is.js","../node_modules/bits-ui/dist/internal/use-roving-focus.svelte.js","../node_modules/bits-ui/dist/internal/create-context.js","../node_modules/bits-ui/dist/internal/use-id.js","../node_modules/bits-ui/dist/internal/noop.js","../node_modules/bits-ui/dist/internal/use-state-machine.svelte.js","../node_modules/bits-ui/dist/internal/box.svelte.js","../node_modules/bits-ui/dist/bits/utilities/presence-layer/usePresence.svelte.js","../node_modules/bits-ui/dist/bits/utilities/presence-layer/presence-layer.svelte","../node_modules/bits-ui/dist/bits/dialog/dialog.svelte.js","../node_modules/bits-ui/dist/bits/dialog/components/dialog-title.svelte","../node_modules/bits-ui/dist/bits/utilities/portal/portal.svelte","../node_modules/bits-ui/dist/internal/events.js","../node_modules/bits-ui/dist/internal/debounce.js","../node_modules/bits-ui/dist/internal/elements.js","../node_modules/bits-ui/dist/bits/utilities/dismissible-layer/useDismissibleLayer.svelte.js","../node_modules/bits-ui/dist/bits/utilities/dismissible-layer/dismissible-layer.svelte","../node_modules/bits-ui/dist/bits/utilities/escape-layer/useEscapeLayer.svelte.js","../node_modules/bits-ui/dist/bits/utilities/escape-layer/escape-layer.svelte","../node_modules/bits-ui/dist/bits/utilities/focus-scope/focus-scope-stack.svelte.js","../node_modules/bits-ui/dist/internal/focus.js","../node_modules/bits-ui/dist/bits/utilities/focus-scope/useFocusScope.svelte.js","../node_modules/bits-ui/dist/bits/utilities/focus-scope/focus-scope.svelte","../node_modules/bits-ui/dist/bits/utilities/text-selection-layer/useTextSelectionLayer.svelte.js","../node_modules/bits-ui/dist/bits/utilities/text-selection-layer/text-selection-layer.svelte","../node_modules/svelte/src/reactivity/utils.js","../node_modules/svelte/src/reactivity/map.js","../node_modules/runed/dist/utilities/Readable/readable.svelte.js","../node_modules/runed/dist/utilities/activeElement/activeElement.svelte.js","../node_modules/runed/dist/internal/utils/is.js","../node_modules/runed/dist/internal/utils/get.js","../node_modules/runed/dist/utilities/ElementSize/ElementSize.svelte.js","../node_modules/runed/dist/utilities/extract/extract.svelte.js","../node_modules/runed/dist/utilities/Previous/Previous.svelte.js","../node_modules/runed/dist/utilities/IsFocusWithin/IsFocusWithin.svelte.js","../node_modules/bits-ui/dist/internal/create-shared-hook.svelte.js","../node_modules/bits-ui/dist/internal/use-body-scroll-lock.svelte.js","../node_modules/bits-ui/dist/bits/utilities/scroll-lock/scroll-lock.svelte","../node_modules/bits-ui/dist/internal/should-trap-focus.js","../node_modules/bits-ui/dist/bits/dialog/components/dialog-overlay.svelte","../node_modules/bits-ui/dist/internal/arrays.js","../node_modules/@floating-ui/utils/dist/floating-ui.utils.mjs","../node_modules/@floating-ui/core/dist/floating-ui.core.mjs","../node_modules/@floating-ui/utils/dist/floating-ui.utils.dom.mjs","../node_modules/@floating-ui/dom/dist/floating-ui.dom.mjs","../node_modules/bits-ui/dist/internal/floating-svelte/floating-utils.svelte.js","../node_modules/bits-ui/dist/internal/floating-svelte/use-floating.svelte.js","../node_modules/bits-ui/dist/bits/utilities/floating-layer/useFloatingLayer.svelte.js","../node_modules/bits-ui/dist/bits/utilities/floating-layer/components/floating-layer.svelte","../node_modules/bits-ui/dist/internal/box-auto-reset.svelte.js","../node_modules/bits-ui/dist/internal/use-dom-typeahead.svelte.js","../node_modules/bits-ui/dist/bits/utilities/floating-layer/components/floating-layer-anchor.svelte","../node_modules/bits-ui/dist/bits/utilities/floating-layer/components/floating-layer-content.svelte","../node_modules/bits-ui/dist/bits/utilities/floating-layer/components/floating-layer-content-static.svelte","../node_modules/bits-ui/dist/bits/utilities/popper-layer/popper-content.svelte","../node_modules/bits-ui/dist/bits/utilities/popper-layer/popper-layer-inner.svelte","../node_modules/bits-ui/dist/bits/utilities/popper-layer/popper-layer.svelte","../node_modules/bits-ui/dist/bits/utilities/popper-layer/popper-layer-force-mount.svelte","../node_modules/bits-ui/dist/bits/utilities/mounted.svelte","../node_modules/bits-ui/dist/bits/menu/utils.js","../node_modules/bits-ui/dist/internal/polygon.js","../node_modules/bits-ui/dist/bits/menu/menu.svelte.js","../node_modules/bits-ui/dist/bits/menu/components/menu-item.svelte","../node_modules/bits-ui/dist/bits/dialog/components/dialog.svelte","../node_modules/bits-ui/dist/bits/dialog/components/dialog-close.svelte","../node_modules/bits-ui/dist/bits/dialog/components/dialog-content.svelte","../node_modules/bits-ui/dist/bits/menu/components/menu.svelte","../node_modules/bits-ui/dist/bits/dropdown-menu/components/dropdown-menu-content.svelte","../node_modules/bits-ui/dist/bits/menu/components/menu-trigger.svelte","../src/services/gitlab/ui/Icon.svelte","../src/services/gitlab/ui/dropdown/Trigger.svelte","../src/services/gitlab/ui/dropdown/Content.svelte","../src/services/gitlab/ui/dropdown/index.ts","../src/services/gitlab/ui/DaktelaIcon.svelte","../src/daktela/gitlab/features/FeatureDropdown.svelte","../src/daktela/gitlab/current.ts","../src/services/gitlab/ui/modal/Content.svelte","../src/services/gitlab/ui/modal/index.ts","../src/daktela/gitlab/render.ts","../src/daktela/gitlab/features/generate-ticket-comment/Steps/Result.svelte","../src/services/gitlab/gitlab.ts","../src/daktela/gitlab/cherry-picks.ts","../src/daktela/gitlab/parse.ts","../src/daktela/gitlab/comments.ts","../src/daktela/gitlab/features/generate-ticket-comment/GenerateTicketCommentModal.svelte","../src/daktela/gitlab/features/Modals.svelte","../src/daktela/gitlab/features/generate-ticket-comment/controls.svelte.ts","../src/daktela/gitlab/features/inject.ts","../src/daktela/gitlab/main.ts"],"sourcesContent":["// generated during release, do not modify\n\n/**\n * The current version, as set in package.json.\n *\n * https://svelte.dev/docs/svelte-compiler#svelte-version\n * @type {string}\n */\nexport const VERSION = '5.1.9';\nexport const PUBLIC_VERSION = '5';\n","import { PUBLIC_VERSION } from '../version.js';\n\nif (typeof window !== 'undefined')\n\t// @ts-ignore\n\t(window.__svelte ||= { v: new Set() }).v.add(PUBLIC_VERSION);\n","export const EACH_ITEM_REACTIVE = 1;\nexport const EACH_INDEX_REACTIVE = 1 << 1;\n/** See EachBlock interface metadata.is_controlled for an explanation what this is */\nexport const EACH_IS_CONTROLLED = 1 << 2;\nexport const EACH_IS_ANIMATED = 1 << 3;\nexport const EACH_ITEM_IMMUTABLE = 1 << 4;\n\nexport const PROPS_IS_IMMUTABLE = 1;\nexport const PROPS_IS_RUNES = 1 << 1;\nexport const PROPS_IS_UPDATED = 1 << 2;\nexport const PROPS_IS_BINDABLE = 1 << 3;\nexport const PROPS_IS_LAZY_INITIAL = 1 << 4;\n\nexport const TRANSITION_IN = 1;\nexport const TRANSITION_OUT = 1 << 1;\nexport const TRANSITION_GLOBAL = 1 << 2;\n\nexport const TEMPLATE_FRAGMENT = 1;\nexport const TEMPLATE_USE_IMPORT_NODE = 1 << 1;\n\nexport const HYDRATION_START = '[';\n/** used to indicate that an `{:else}...` block was rendered */\nexport const HYDRATION_START_ELSE = '[!';\nexport const HYDRATION_END = ']';\nexport const HYDRATION_ERROR = {};\n\nexport const ELEMENT_IS_NAMESPACED = 1;\nexport const ELEMENT_PRESERVE_ATTRIBUTE_CASE = 1 << 1;\n\nexport const UNINITIALIZED = Symbol();\n\n// Dev-time component properties\nexport const FILENAME = Symbol('filename');\nexport const HMR = Symbol('hmr');\n\nexport const NAMESPACE_SVG = 'http://www.w3.org/2000/svg';\nexport const NAMESPACE_MATHML = 'http://www.w3.org/1998/Math/MathML';\n\n// we use a list of ignorable runtime warnings because not every runtime warning\n// can be ignored and we want to keep the validation for svelte-ignore in place\nexport const IGNORABLE_RUNTIME_WARNINGS = /** @type {const} */ ([\n\t'state_snapshot_uncloneable',\n\t'binding_property_non_reactive',\n\t'hydration_attribute_changed',\n\t'hydration_html_changed',\n\t'ownership_invalid_binding',\n\t'ownership_invalid_mutation'\n]);\n\n/**\n * Whitespace inside one of these elements will not result in\n * a whitespace node being created in any circumstances. (This\n * list is almost certainly very incomplete)\n * TODO this is currently unused\n */\nexport const ELEMENTS_WITHOUT_TEXT = ['audio', 'datalist', 'dl', 'optgroup', 'select', 'video'];\n","export const BROWSER = true;\nexport const DEV = false;\nexport const NODE = false;\n","// Store the references to globals in case someone tries to monkey patch these, causing the below\n// to de-opt (this occurs often when using popular extensions).\nexport var is_array = Array.isArray;\nexport var array_from = Array.from;\nexport var object_keys = Object.keys;\nexport var define_property = Object.defineProperty;\nexport var get_descriptor = Object.getOwnPropertyDescriptor;\nexport var get_descriptors = Object.getOwnPropertyDescriptors;\nexport var object_prototype = Object.prototype;\nexport var array_prototype = Array.prototype;\nexport var get_prototype_of = Object.getPrototypeOf;\n\n/**\n * @param {any} thing\n * @returns {thing is Function}\n */\nexport function is_function(thing) {\n\treturn typeof thing === 'function';\n}\n\nexport const noop = () => {};\n\n// Adapted from https://github.com/then/is-promise/blob/master/index.js\n// Distributed under MIT License https://github.com/then/is-promise/blob/master/LICENSE\n\n/**\n * @template [T=any]\n * @param {any} value\n * @returns {value is PromiseLike<T>}\n */\nexport function is_promise(value) {\n\treturn typeof value?.then === 'function';\n}\n\n/** @param {Function} fn */\nexport function run(fn) {\n\treturn fn();\n}\n\n/** @param {Array<() => void>} arr */\nexport function run_all(arr) {\n\tfor (var i = 0; i < arr.length; i++) {\n\t\tarr[i]();\n\t}\n}\n\n/**\n * @template V\n * @param {V} value\n * @param {V | (() => V)} fallback\n * @param {boolean} [lazy]\n * @returns {V}\n */\nexport function fallback(value, fallback, lazy = false) {\n\treturn value === undefined\n\t\t? lazy\n\t\t\t? /** @type {() => V} */ (fallback)()\n\t\t\t: /** @type {V} */ (fallback)\n\t\t: value;\n}\n","export const DERIVED = 1 << 1;\nexport const EFFECT = 1 << 2;\nexport const RENDER_EFFECT = 1 << 3;\nexport const BLOCK_EFFECT = 1 << 4;\nexport const BRANCH_EFFECT = 1 << 5;\nexport const ROOT_EFFECT = 1 << 6;\nexport const UNOWNED = 1 << 7;\nexport const DISCONNECTED = 1 << 8;\nexport const CLEAN = 1 << 9;\nexport const DIRTY = 1 << 10;\nexport const MAYBE_DIRTY = 1 << 11;\nexport const INERT = 1 << 12;\nexport const DESTROYED = 1 << 13;\nexport const EFFECT_RAN = 1 << 14;\n/** 'Transparent' effects do not create a transition boundary */\nexport const EFFECT_TRANSPARENT = 1 << 15;\n/** Svelte 4 legacy mode props need to be handled with deriveds and be recognized elsewhere, hence the dedicated flag */\nexport const LEGACY_DERIVED_PROP = 1 << 16;\nexport const INSPECT_EFFECT = 1 << 17;\nexport const HEAD_EFFECT = 1 << 18;\nexport const EFFECT_HAS_DERIVED = 1 << 19;\n\nexport const STATE_SYMBOL = Symbol('$state');\nexport const STATE_SYMBOL_METADATA = Symbol('$state metadata');\nexport const LOADING_ATTR_SYMBOL = Symbol('');\n","/** @import { Equals } from '#client' */\n/** @type {Equals} */\nexport function equals(value) {\n\treturn value === this.v;\n}\n\n/**\n * @param {unknown} a\n * @param {unknown} b\n * @returns {boolean}\n */\nexport function safe_not_equal(a, b) {\n\treturn a != a\n\t\t? b == b\n\t\t: a !== b || (a !== null && typeof a === 'object') || typeof a === 'function';\n}\n\n/** @type {Equals} */\nexport function safe_equals(value) {\n\treturn !safe_not_equal(value, this.v);\n}\n","/* This file is generated by scripts/process-messages/index.js. Do not edit! */\n\nimport { DEV } from 'esm-env';\n\n/**\n * Using `bind:value` together with a checkbox input is not allowed. Use `bind:checked` instead\n * @returns {never}\n */\nexport function bind_invalid_checkbox_value() {\n\tif (DEV) {\n\t\tconst error = new Error(`bind_invalid_checkbox_value\\nUsing \\`bind:value\\` together with a checkbox input is not allowed. Use \\`bind:checked\\` instead`);\n\n\t\terror.name = 'Svelte error';\n\t\tthrow error;\n\t} else {\n\t\t// TODO print a link to the documentation\n\t\tthrow new Error(\"bind_invalid_checkbox_value\");\n\t}\n}\n\n/**\n * Component %component% has an export named `%key%` that a consumer component is trying to access using `bind:%key%`, which is disallowed. Instead, use `bind:this` (e.g. `<%name% bind:this={component} />`) and then access the property on the bound component instance (e.g. `component.%key%`)\n * @param {string} component\n * @param {string} key\n * @param {string} name\n * @returns {never}\n */\nexport function bind_invalid_export(component, key, name) {\n\tif (DEV) {\n\t\tconst error = new Error(`bind_invalid_export\\nComponent ${component} has an export named \\`${key}\\` that a consumer component is trying to access using \\`bind:${key}\\`, which is disallowed. Instead, use \\`bind:this\\` (e.g. \\`<${name} bind:this={component} />\\`) and then access the property on the bound component instance (e.g. \\`component.${key}\\`)`);\n\n\t\terror.name = 'Svelte error';\n\t\tthrow error;\n\t} else {\n\t\t// TODO print a link to the documentation\n\t\tthrow new Error(\"bind_invalid_export\");\n\t}\n}\n\n/**\n * A component is attempting to bind to a non-bindable property `%key%` belonging to %component% (i.e. `<%name% bind:%key%={...}>`). To mark a property as bindable: `let { %key% = $bindable() } = $props()`\n * @param {string} key\n * @param {string} component\n * @param {string} name\n * @returns {never}\n */\nexport function bind_not_bindable(key, component, name) {\n\tif (DEV) {\n\t\tconst error = new Error(`bind_not_bindable\\nA component is attempting to bind to a non-bindable property \\`${key}\\` belonging to ${component} (i.e. \\`<${name} bind:${key}={...}>\\`). To mark a property as bindable: \\`let { ${key} = $bindable() } = $props()\\``);\n\n\t\terror.name = 'Svelte error';\n\t\tthrow error;\n\t} else {\n\t\t// TODO print a link to the documentation\n\t\tthrow new Error(\"bind_not_bindable\");\n\t}\n}\n\n/**\n * %parent% called `%method%` on an instance of %component%, which is no longer valid in Svelte 5. See https://svelte.dev/docs/svelte/v5-migration-guide#Components-are-no-longer-classes for more information\n * @param {string} parent\n * @param {string} method\n * @param {string} component\n * @returns {never}\n */\nexport function component_api_changed(parent, method, component) {\n\tif (DEV) {\n\t\tconst error = new Error(`component_api_changed\\n${parent} called \\`${method}\\` on an instance of ${component}, which is no longer valid in Svelte 5. See https://svelte.dev/docs/svelte/v5-migration-guide#Components-are-no-longer-classes for more information`);\n\n\t\terror.name = 'Svelte error';\n\t\tthrow error;\n\t} else {\n\t\t// TODO print a link to the documentation\n\t\tthrow new Error(\"component_api_changed\");\n\t}\n}\n\n/**\n * Attempted to instantiate %component% with `new %name%`, which is no longer valid in Svelte 5. If this component is not under your control, set the `compatibility.componentApi` compiler option to `4` to keep it working. See https://svelte.dev/docs/svelte/v5-migration-guide#Components-are-no-longer-classes for more information\n * @param {string} component\n * @param {string} name\n * @returns {never}\n */\nexport function component_api_invalid_new(component, name) {\n\tif (DEV) {\n\t\tconst error = new Error(`component_api_invalid_new\\nAttempted to instantiate ${component} with \\`new ${name}\\`, which is no longer valid in Svelte 5. If this component is not under your control, set the \\`compatibility.componentApi\\` compiler option to \\`4\\` to keep it working. See https://svelte.dev/docs/svelte/v5-migration-guide#Components-are-no-longer-classes for more information`);\n\n\t\terror.name = 'Svelte error';\n\t\tthrow error;\n\t} else {\n\t\t// TODO print a link to the documentation\n\t\tthrow new Error(\"component_api_invalid_new\");\n\t}\n}\n\n/**\n * A derived value cannot reference itself recursively\n * @returns {never}\n */\nexport function derived_references_self() {\n\tif (DEV) {\n\t\tconst error = new Error(`derived_references_self\\nA derived value cannot reference itself recursively`);\n\n\t\terror.name = 'Svelte error';\n\t\tthrow error;\n\t} else {\n\t\t// TODO print a link to the documentation\n\t\tthrow new Error(\"derived_references_self\");\n\t}\n}\n\n/**\n * Keyed each block has duplicate key `%value%` at indexes %a% and %b%\n * @param {string} a\n * @param {string} b\n * @param {string | undefined | null} [value]\n * @returns {never}\n */\nexport function each_key_duplicate(a, b, value) {\n\tif (DEV) {\n\t\tconst error = new Error(`each_key_duplicate\\n${value ? `Keyed each block has duplicate key \\`${value}\\` at indexes ${a} and ${b}` : `Keyed each block has duplicate key at indexes ${a} and ${b}`}`);\n\n\t\terror.name = 'Svelte error';\n\t\tthrow error;\n\t} else {\n\t\t// TODO print a link to the documentation\n\t\tthrow new Error(\"each_key_duplicate\");\n\t}\n}\n\n/**\n * `%rune%` cannot be used inside an effect cleanup function\n * @param {string} rune\n * @returns {never}\n */\nexport function effect_in_teardown(rune) {\n\tif (DEV) {\n\t\tconst error = new Error(`effect_in_teardown\\n\\`${rune}\\` cannot be used inside an effect cleanup function`);\n\n\t\terror.name = 'Svelte error';\n\t\tthrow error;\n\t} else {\n\t\t// TODO print a link to the documentation\n\t\tthrow new Error(\"effect_in_teardown\");\n\t}\n}\n\n/**\n * Effect cannot be created inside a `$derived` value that was not itself created inside an effect\n * @returns {never}\n */\nexport function effect_in_unowned_derived() {\n\tif (DEV) {\n\t\tconst error = new Error(`effect_in_unowned_derived\\nEffect cannot be created inside a \\`$derived\\` value that was not itself created inside an effect`);\n\n\t\terror.name = 'Svelte error';\n\t\tthrow error;\n\t} else {\n\t\t// TODO print a link to the documentation\n\t\tthrow new Error(\"effect_in_unowned_derived\");\n\t}\n}\n\n/**\n * `%rune%` can only be used inside an effect (e.g. during component initialisation)\n * @param {string} rune\n * @returns {never}\n */\nexport function effect_orphan(rune) {\n\tif (DEV) {\n\t\tconst error = new Error(`effect_orphan\\n\\`${rune}\\` can only be used inside an effect (e.g. during component initialisation)`);\n\n\t\terror.name = 'Svelte error';\n\t\tthrow error;\n\t} else {\n\t\t// TODO print a link to the documentation\n\t\tthrow new Error(\"effect_orphan\");\n\t}\n}\n\n/**\n * Maximum update depth exceeded. This can happen when a reactive block or effect repeatedly sets a new value. Svelte limits the number of nested updates to prevent infinite loops\n * @returns {never}\n */\nexport function effect_update_depth_exceeded() {\n\tif (DEV) {\n\t\tconst error = new Error(`effect_update_depth_exceeded\\nMaximum update depth exceeded. This can happen when a reactive block or effect repeatedly sets a new value. Svelte limits the number of nested updates to prevent infinite loops`);\n\n\t\terror.name = 'Svelte error';\n\t\tthrow error;\n\t} else {\n\t\t// TODO print a link to the documentation\n\t\tthrow new Error(\"effect_update_depth_exceeded\");\n\t}\n}\n\n/**\n * Failed to hydrate the application\n * @returns {never}\n */\nexport function hydration_failed() {\n\tif (DEV) {\n\t\tconst error = new Error(`hydration_failed\\nFailed to hydrate the application`);\n\n\t\terror.name = 'Svelte error';\n\t\tthrow error;\n\t} else {\n\t\t// TODO print a link to the documentation\n\t\tthrow new Error(\"hydration_failed\");\n\t}\n}\n\n/**\n * Could not `{@render}` snippet due to the expression being `null` or `undefined`. Consider using optional chaining `{@render snippet?.()}`\n * @returns {never}\n */\nexport function invalid_snippet() {\n\tif (DEV) {\n\t\tconst error = new Error(`invalid_snippet\\nCould not \\`{@render}\\` snippet due to the expression being \\`null\\` or \\`undefined\\`. Consider using optional chaining \\`{@render snippet?.()}\\``);\n\n\t\terror.name = 'Svelte error';\n\t\tthrow error;\n\t} else {\n\t\t// TODO print a link to the documentation\n\t\tthrow new Error(\"invalid_snippet\");\n\t}\n}\n\n/**\n * `%name%(...)` cannot be used in runes mode\n * @param {string} name\n * @returns {never}\n */\nexport function lifecycle_legacy_only(name) {\n\tif (DEV) {\n\t\tconst error = new Error(`lifecycle_legacy_only\\n\\`${name}(...)\\` cannot be used in runes mode`);\n\n\t\terror.name = 'Svelte error';\n\t\tthrow error;\n\t} else {\n\t\t// TODO print a link to the documentation\n\t\tthrow new Error(\"lifecycle_legacy_only\");\n\t}\n}\n\n/**\n * Cannot do `bind:%key%={undefined}` when `%key%` has a fallback value\n * @param {string} key\n * @returns {never}\n */\nexport function props_invalid_value(key) {\n\tif (DEV) {\n\t\tconst error = new Error(`props_invalid_value\\nCannot do \\`bind:${key}={undefined}\\` when \\`${key}\\` has a fallback value`);\n\n\t\terror.name = 'Svelte error';\n\t\tthrow error;\n\t} else {\n\t\t// TODO print a link to the documentation\n\t\tthrow new Error(\"props_invalid_value\");\n\t}\n}\n\n/**\n * Rest element properties of `$props()` such as `%property%` are readonly\n * @param {string} property\n * @returns {never}\n */\nexport function props_rest_readonly(property) {\n\tif (DEV) {\n\t\tconst error = new Error(`props_rest_readonly\\nRest element properties of \\`$props()\\` such as \\`${property}\\` are readonly`);\n\n\t\terror.name = 'Svelte error';\n\t\tthrow error;\n\t} else {\n\t\t// TODO print a link to the documentation\n\t\tthrow new Error(\"props_rest_readonly\");\n\t}\n}\n\n/**\n * The `%rune%` rune is only available inside `.svelte` and `.svelte.js/ts` files\n * @param {string} rune\n * @returns {never}\n */\nexport function rune_outside_svelte(rune) {\n\tif (DEV) {\n\t\tconst error = new Error(`rune_outside_svelte\\nThe \\`${rune}\\` rune is only available inside \\`.svelte\\` and \\`.svelte.js/ts\\` files`);\n\n\t\terror.name = 'Svelte error';\n\t\tthrow error;\n\t} else {\n\t\t// TODO print a link to the documentation\n\t\tthrow new Error(\"rune_outside_svelte\");\n\t}\n}\n\n/**\n * Property descriptors defined on `$state` objects must contain `value` and always be `enumerable`, `configurable` and `writable`.\n * @returns {never}\n */\nexport function state_descriptors_fixed() {\n\tif (DEV) {\n\t\tconst error = new Error(`state_descriptors_fixed\\nProperty descriptors defined on \\`$state\\` objects must contain \\`value\\` and always be \\`enumerable\\`, \\`configurable\\` and \\`writable\\`.`);\n\n\t\terror.name = 'Svelte error';\n\t\tthrow error;\n\t} else {\n\t\t// TODO print a link to the documentation\n\t\tthrow new Error(\"state_descriptors_fixed\");\n\t}\n}\n\n/**\n * Cannot set prototype of `$state` object\n * @returns {never}\n */\nexport function state_prototype_fixed() {\n\tif (DEV) {\n\t\tconst error = new Error(`state_prototype_fixed\\nCannot set prototype of \\`$state\\` object`);\n\n\t\terror.name = 'Svelte error';\n\t\tthrow error;\n\t} else {\n\t\t// TODO print a link to the documentation\n\t\tthrow new Error(\"state_prototype_fixed\");\n\t}\n}\n\n/**\n * Reading state that was created inside the same derived is forbidden. Consider using `untrack` to read locally created state\n * @returns {never}\n */\nexport function state_unsafe_local_read() {\n\tif (DEV) {\n\t\tconst error = new Error(`state_unsafe_local_read\\nReading state that was created inside the same derived is forbidden. Consider using \\`untrack\\` to read locally created state`);\n\n\t\terror.name = 'Svelte error';\n\t\tthrow error;\n\t} else {\n\t\t// TODO print a link to the documentation\n\t\tthrow new Error(\"state_unsafe_local_read\");\n\t}\n}\n\n/**\n * Updating state inside a derived or a template expression is forbidden. If the value should not be reactive, declare it without `$state`\n * @returns {never}\n */\nexport function state_unsafe_mutation() {\n\tif (DEV) {\n\t\tconst error = new Error(`state_unsafe_mutation\\nUpdating state inside a derived or a template expression is forbidden. If the value should not be reactive, declare it without \\`$state\\``);\n\n\t\terror.name = 'Svelte error';\n\t\tthrow error;\n\t} else {\n\t\t// TODO print a link to the documentation\n\t\tthrow new Error(\"state_unsafe_mutation\");\n\t}\n}","/** @import { Derived, Effect, Reaction, Source, Value } from '#client' */\nimport { DEV } from 'esm-env';\nimport {\n\tcomponent_context,\n\tactive_reaction,\n\tnew_deps,\n\tactive_effect,\n\tuntracked_writes,\n\tget,\n\tis_runes,\n\tschedule_effect,\n\tset_untracked_writes,\n\tset_signal_status,\n\tuntrack,\n\tincrement_version,\n\tupdate_effect,\n\tderived_sources,\n\tset_derived_sources,\n\tcheck_dirtiness,\n\tset_is_flushing_effect,\n\tis_flushing_effect\n} from '../runtime.js';\nimport { equals, safe_equals } from './equality.js';\nimport {\n\tCLEAN,\n\tDERIVED,\n\tDIRTY,\n\tBRANCH_EFFECT,\n\tINSPECT_EFFECT,\n\tUNOWNED,\n\tMAYBE_DIRTY,\n\tBLOCK_EFFECT\n} from '../constants.js';\nimport * as e from '../errors.js';\n\nexport let inspect_effects = new Set();\n\n/**\n * @param {Set<any>} v\n */\nexport function set_inspect_effects(v) {\n\tinspect_effects = v;\n}\n\n/**\n * @template V\n * @param {V} v\n * @returns {Source<V>}\n */\nexport function source(v) {\n\treturn {\n\t\tf: 0, // TODO ideally we could skip this altogether, but it causes type errors\n\t\tv,\n\t\treactions: null,\n\t\tequals,\n\t\tversion: 0\n\t};\n}\n\n/**\n * @template V\n * @param {V} v\n */\nexport function state(v) {\n\treturn push_derived_source(source(v));\n}\n\n/**\n * @template V\n * @param {V} initial_value\n * @param {boolean} [immutable]\n * @returns {Source<V>}\n */\n/*#__NO_SIDE_EFFECTS__*/\nexport function mutable_source(initial_value, immutable = false) {\n\tconst s = source(initial_value);\n\tif (!immutable) {\n\t\ts.equals = safe_equals;\n\t}\n\n\t// bind the signal to the component context, in case we need to\n\t// track updates to trigger beforeUpdate/afterUpdate callbacks\n\tif (component_context !== null && component_context.l !== null) {\n\t\t(component_context.l.s ??= []).push(s);\n\t}\n\n\treturn s;\n}\n\n/**\n * @template V\n * @param {V} v\n * @param {boolean} [immutable]\n * @returns {Source<V>}\n */\nexport function mutable_state(v, immutable = false) {\n\treturn push_derived_source(mutable_source(v, immutable));\n}\n\n/**\n * @template V\n * @param {Source<V>} source\n */\n/*#__NO_SIDE_EFFECTS__*/\nfunction push_derived_source(source) {\n\tif (active_reaction !== null && (active_reaction.f & DERIVED) !== 0) {\n\t\tif (derived_sources === null) {\n\t\t\tset_derived_sources([source]);\n\t\t} else {\n\t\t\tderived_sources.push(source);\n\t\t}\n\t}\n\n\treturn source;\n}\n\n/**\n * @template V\n * @param {Value<V>} source\n * @param {V} value\n */\nexport function mutate(source, value) {\n\tset(\n\t\tsource,\n\t\tuntrack(() => get(source))\n\t);\n\treturn value;\n}\n\n/**\n * @template V\n * @param {Source<V>} source\n * @param {V} value\n * @returns {V}\n */\nexport function set(source, value) {\n\tif (\n\t\tactive_reaction !== null &&\n\t\tis_runes() &&\n\t\t(active_reaction.f & (DERIVED | BLOCK_EFFECT)) !== 0 &&\n\t\t// If the source was created locally within the current derived, then\n\t\t// we allow the mutation.\n\t\t(derived_sources === null || !derived_sources.includes(source))\n\t) {\n\t\te.state_unsafe_mutation();\n\t}\n\n\treturn internal_set(source, value);\n}\n\n/**\n * @template V\n * @param {Source<V>} source\n * @param {V} value\n * @returns {V}\n */\nexport function internal_set(source, value) {\n\tif (!source.equals(value)) {\n\t\tsource.v = value;\n\t\tsource.version = increment_version();\n\n\t\tmark_reactions(source, DIRTY);\n\n\t\t// If the current signal is running for the first time, it won't have any\n\t\t// reactions as we only allocate and assign the reactions after the signal\n\t\t// has fully executed. So in the case of ensuring it registers the reaction\n\t\t// properly for itself, we need to ensure the current effect actually gets\n\t\t// scheduled. i.e: `$effect(() => x++)`\n\t\tif (\n\t\t\tis_runes() &&\n\t\t\tactive_effect !== null &&\n\t\t\t(active_effect.f & CLEAN) !== 0 &&\n\t\t\t(active_effect.f & BRANCH_EFFECT) === 0\n\t\t) {\n\t\t\tif (new_deps !== null && new_deps.includes(source)) {\n\t\t\t\tset_signal_status(active_effect, DIRTY);\n\t\t\t\tschedule_effect(active_effect);\n\t\t\t} else {\n\t\t\t\tif (untracked_writes === null) {\n\t\t\t\t\tset_untracked_writes([source]);\n\t\t\t\t} else {\n\t\t\t\t\tuntracked_writes.push(source);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (DEV && inspect_effects.size > 0) {\n\t\t\tconst inspects = Array.from(inspect_effects);\n\t\t\tvar previously_flushing_effect = is_flushing_effect;\n\t\t\tset_is_flushing_effect(true);\n\t\t\ttry {\n\t\t\t\tfor (const effect of inspects) {\n\t\t\t\t\t// Mark clean inspect-effects as maybe dirty and then check their dirtiness\n\t\t\t\t\t// instead of just updating the effects - this way we avoid overfiring.\n\t\t\t\t\tif ((effect.f & CLEAN) !== 0) {\n\t\t\t\t\t\tset_signal_status(effect, MAYBE_DIRTY);\n\t\t\t\t\t}\n\t\t\t\t\tif (check_dirtiness(effect)) {\n\t\t\t\t\t\tupdate_effect(effect);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} finally {\n\t\t\t\tset_is_flushing_effect(previously_flushing_effect);\n\t\t\t}\n\t\t\tinspect_effects.clear();\n\t\t}\n\t}\n\n\treturn value;\n}\n\n/**\n * @param {Value} signal\n * @param {number} status should be DIRTY or MAYBE_DIRTY\n * @returns {void}\n */\nfunction mark_reactions(signal, status) {\n\tvar reactions = signal.reactions;\n\tif (reactions === null) return;\n\n\tvar runes = is_runes();\n\tvar length = reactions.length;\n\n\tfor (var i = 0; i < length; i++) {\n\t\tvar reaction = reactions[i];\n\t\tvar flags = reaction.f;\n\n\t\t// Skip any effects that are already dirty\n\t\tif ((flags & DIRTY) !== 0) continue;\n\n\t\t// In legacy mode, skip the current effect to prevent infinite loops\n\t\tif (!runes && reaction === active_effect) continue;\n\n\t\t// Inspect effects need to run immediately, so that the stack trace makes sense\n\t\tif (DEV && (flags & INSPECT_EFFECT) !== 0) {\n\t\t\tinspect_effects.add(reaction);\n\t\t\tcontinue;\n\t\t}\n\n\t\tset_signal_status(reaction, status);\n\n\t\t// If the signal a) was previously clean or b) is an unowned derived, then mark it\n\t\tif ((flags & (CLEAN | UNOWNED)) !== 0) {\n\t\t\tif ((flags & DERIVED) !== 0) {\n\t\t\t\tmark_reactions(/** @type {Derived} */ (reaction), MAYBE_DIRTY);\n\t\t\t} else {\n\t\t\t\tschedule_effect(/** @type {Effect} */ (reaction));\n\t\t\t}\n\t\t}\n\t}\n}\n","/** @import { Derived, Effect } from '#client' */\nimport { DEV } from 'esm-env';\nimport {\n\tCLEAN,\n\tDERIVED,\n\tDESTROYED,\n\tDIRTY,\n\tEFFECT_HAS_DERIVED,\n\tMAYBE_DIRTY,\n\tUNOWNED\n} from '../constants.js';\nimport {\n\tactive_reaction,\n\tactive_effect,\n\tremove_reactions,\n\tset_signal_status,\n\tskip_reaction,\n\tupdate_reaction,\n\tincrement_version,\n\tset_active_effect,\n\tcomponent_context\n} from '../runtime.js';\nimport { equals, safe_equals } from './equality.js';\nimport * as e from '../errors.js';\nimport { destroy_effect } from './effects.js';\nimport { inspect_effects, set_inspect_effects } from './sources.js';\n\n/**\n * @template V\n * @param {() => V} fn\n * @returns {Derived<V>}\n */\n/*#__NO_SIDE_EFFECTS__*/\nexport function derived(fn) {\n\tvar flags = DERIVED | DIRTY;\n\n\tif (active_effect === null) {\n\t\tflags |= UNOWNED;\n\t} else {\n\t\t// Since deriveds are evaluated lazily, any effects created inside them are\n\t\t// created too late to ensure that the parent effect is added to the tree\n\t\tactive_effect.f |= EFFECT_HAS_DERIVED;\n\t}\n\n\t/** @type {Derived<V>} */\n\tconst signal = {\n\t\tchildren: null,\n\t\tctx: component_context,\n\t\tdeps: null,\n\t\tequals,\n\t\tf: flags,\n\t\tfn,\n\t\treactions: null,\n\t\tv: /** @type {V} */ (null),\n\t\tversion: 0,\n\t\tparent: active_effect\n\t};\n\n\tif (active_reaction !== null && (active_reaction.f & DERIVED) !== 0) {\n\t\tvar derived = /** @type {Derived} */ (active_reaction);\n\t\t(derived.children ??= []).push(signal);\n\t}\n\n\treturn signal;\n}\n\n/**\n * @template V\n * @param {() => V} fn\n * @returns {Derived<V>}\n */\n/*#__NO_SIDE_EFFECTS__*/\nexport function derived_safe_equal(fn) {\n\tconst signal = derived(fn);\n\tsignal.equals = safe_equals;\n\treturn signal;\n}\n\n/**\n * @param {Derived} derived\n * @returns {void}\n */\nfunction destroy_derived_children(derived) {\n\tvar children = derived.children;\n\n\tif (children !== null) {\n\t\tderived.children = null;\n\n\t\tfor (var i = 0; i < children.length; i += 1) {\n\t\t\tvar child = children[i];\n\t\t\tif ((child.f & DERIVED) !== 0) {\n\t\t\t\tdestroy_derived(/** @type {Derived} */ (child));\n\t\t\t} else {\n\t\t\t\tdestroy_effect(/** @type {Effect} */ (child));\n\t\t\t}\n\t\t}\n\t}\n}\n\n/**\n * The currently updating deriveds, used to detect infinite recursion\n * in dev mode and provide a nicer error than 'too much recursion'\n * @type {Derived[]}\n */\nlet stack = [];\n\n/**\n * @template T\n * @param {Derived} derived\n * @returns {T}\n */\nexport function execute_derived(derived) {\n\tvar value;\n\tvar prev_active_effect = active_effect;\n\n\tset_active_effect(derived.parent);\n\n\tif (DEV) {\n\t\tlet prev_inspect_effects = inspect_effects;\n\t\tset_inspect_effects(new Set());\n\t\ttry {\n\t\t\tif (stack.includes(derived)) {\n\t\t\t\te.derived_references_self();\n\t\t\t}\n\n\t\t\tstack.push(derived);\n\n\t\t\tdestroy_derived_children(derived);\n\t\t\tvalue = update_reaction(derived);\n\t\t} finally {\n\t\t\tset_active_effect(prev_active_effect);\n\t\t\tset_inspect_effects(prev_inspect_effects);\n\t\t\tstack.pop();\n\t\t}\n\t} else {\n\t\ttry {\n\t\t\tdestroy_derived_children(derived);\n\t\t\tvalue = update_reaction(derived);\n\t\t} finally {\n\t\t\tset_active_effect(prev_active_effect);\n\t\t}\n\t}\n\n\treturn value;\n}\n\n/**\n * @param {Derived} derived\n * @returns {void}\n */\nexport function update_derived(derived) {\n\tvar value = execute_derived(derived);\n\tvar status =\n\t\t(skip_reaction || (derived.f & UNOWNED) !== 0) && derived.deps !== null ? MAYBE_DIRTY : CLEAN;\n\n\tset_signal_status(derived, status);\n\n\tif (!derived.equals(value)) {\n\t\tderived.v = value;\n\t\tderived.version = increment_version();\n\t}\n}\n\n/**\n * @param {Derived} signal\n * @returns {void}\n */\nexport function destroy_derived(signal) {\n\tdestroy_derived_children(signal);\n\tremove_reactions(signal, 0);\n\tset_signal_status(signal, DESTROYED);\n\n\t// TODO we need to ensure we remove the derived from any parent derives\n\tsignal.v = signal.children = signal.deps = signal.ctx = signal.reactions = null;\n}\n","/** @import { ComponentContext, ComponentContextLegacy, Derived, Effect, Reaction, TemplateNode, TransitionManager } from '#client' */\nimport {\n\tcheck_dirtiness,\n\tcomponent_context,\n\tactive_effect,\n\tactive_reaction,\n\tdev_current_component_function,\n\tupdate_effect,\n\tget,\n\tis_destroying_effect,\n\tis_flushing_effect,\n\tremove_reactions,\n\tschedule_effect,\n\tset_active_reaction,\n\tset_is_destroying_effect,\n\tset_is_flushing_effect,\n\tset_signal_status,\n\tuntrack,\n\tskip_reaction\n} from '../runtime.js';\nimport {\n\tDIRTY,\n\tBRANCH_EFFECT,\n\tRENDER_EFFECT,\n\tEFFECT,\n\tDESTROYED,\n\tINERT,\n\tEFFECT_RAN,\n\tBLOCK_EFFECT,\n\tROOT_EFFECT,\n\tEFFECT_TRANSPARENT,\n\tDERIVED,\n\tUNOWNED,\n\tCLEAN,\n\tINSPECT_EFFECT,\n\tHEAD_EFFECT,\n\tMAYBE_DIRTY,\n\tEFFECT_HAS_DERIVED\n} from '../constants.js';\nimport { set } from './sources.js';\nimport * as e from '../errors.js';\nimport { DEV } from 'esm-env';\nimport { define_property } from '../../shared/utils.js';\nimport { get_next_sibling } from '../dom/operations.js';\nimport { destroy_derived } from './deriveds.js';\n\n/**\n * @param {'$effect' | '$effect.pre' | '$inspect'} rune\n */\nexport function validate_effect(rune) {\n\tif (active_effect === null && active_reaction === null) {\n\t\te.effect_orphan(rune);\n\t}\n\n\tif (active_reaction !== null && (active_reaction.f & UNOWNED) !== 0) {\n\t\te.effect_in_unowned_derived();\n\t}\n\n\tif (is_destroying_effect) {\n\t\te.effect_in_teardown(rune);\n\t}\n}\n\n/**\n * @param {Effect} effect\n * @param {Effect} parent_effect\n */\nfunction push_effect(effect, parent_effect) {\n\tvar parent_last = parent_effect.last;\n\tif (parent_last === null) {\n\t\tparent_effect.last = parent_effect.first = effect;\n\t} else {\n\t\tparent_last.next = effect;\n\t\teffect.prev = parent_last;\n\t\tparent_effect.last = effect;\n\t}\n}\n\n/**\n * @param {number} type\n * @param {null | (() => void | (() => void))} fn\n * @param {boolean} sync\n * @param {boolean} push\n * @returns {Effect}\n */\nfunction create_effect(type, fn, sync, push = true) {\n\tvar is_root = (type & ROOT_EFFECT) !== 0;\n\tvar parent_effect = active_effect;\n\n\tif (DEV) {\n\t\t// Ensure the parent is never an inspect effect\n\t\twhile (parent_effect !== null && (parent_effect.f & INSPECT_EFFECT) !== 0) {\n\t\t\tparent_effect = parent_effect.parent;\n\t\t}\n\t}\n\n\t/** @type {Effect} */\n\tvar effect = {\n\t\tctx: component_context,\n\t\tdeps: null,\n\t\tderiveds: null,\n\t\tnodes_start: null,\n\t\tnodes_end: null,\n\t\tf: type | DIRTY,\n\t\tfirst: null,\n\t\tfn,\n\t\tlast: null,\n\t\tnext: null,\n\t\tparent: is_root ? null : parent_effect,\n\t\tprev: null,\n\t\tteardown: null,\n\t\ttransitions: null,\n\t\tversion: 0\n\t};\n\n\tif (DEV) {\n\t\teffect.component_function = dev_current_component_function;\n\t}\n\n\tif (sync) {\n\t\tvar previously_flushing_effect = is_flushing_effect;\n\n\t\ttry {\n\t\t\tset_is_flushing_effect(true);\n\t\t\tupdate_effect(effect);\n\t\t\teffect.f |= EFFECT_RAN;\n\t\t} catch (e) {\n\t\t\tdestroy_effect(effect);\n\t\t\tthrow e;\n\t\t} finally {\n\t\t\tset_is_flushing_effect(previously_flushing_effect);\n\t\t}\n\t} else if (fn !== null) {\n\t\tschedule_effect(effect);\n\t}\n\n\t// if an effect has no dependencies, no DOM and no teardown function,\n\t// don't bother adding it to the effect tree\n\tvar inert =\n\t\tsync &&\n\t\teffect.deps === null &&\n\t\teffect.first === null &&\n\t\teffect.nodes_start === null &&\n\t\teffect.teardown === null &&\n\t\t(effect.f & EFFECT_HAS_DERIVED) === 0;\n\n\tif (!inert && !is_root && push) {\n\t\tif (parent_effect !== null) {\n\t\t\tpush_effect(effect, parent_effect);\n\t\t}\n\n\t\t// if we're in a derived, add the effect there too\n\t\tif (active_reaction !== null && (active_reaction.f & DERIVED) !== 0) {\n\t\t\tvar derived = /** @type {Derived} */ (active_reaction);\n\t\t\t(derived.children ??= []).push(effect);\n\t\t}\n\t}\n\n\treturn effect;\n}\n\n/**\n * Internal representation of `$effect.tracking()`\n * @returns {boolean}\n */\nexport function effect_tracking() {\n\tif (active_reaction === null) {\n\t\treturn false;\n\t}\n\n\t// If it's skipped, that's because we're inside an unowned\n\t// that is not being tracked by another reaction\n\treturn !skip_reaction;\n}\n\n/**\n * @param {() => void} fn\n */\nexport function teardown(fn) {\n\tconst effect = create_effect(RENDER_EFFECT, null, false);\n\tset_signal_status(effect, CLEAN);\n\teffect.teardown = fn;\n\treturn effect;\n}\n\n/**\n * Internal representation of `$effect(...)`\n * @param {() => void | (() => void)} fn\n */\nexport function user_effect(fn) {\n\tvalidate_effect('$effect');\n\n\t// Non-nested `$effect(...)` in a component should be deferred\n\t// until the component is mounted\n\tvar defer =\n\t\tactive_effect !== null &&\n\t\t(active_effect.f & BRANCH_EFFECT) !== 0 &&\n\t\tcomponent_context !== null &&\n\t\t!component_context.m;\n\n\tif (DEV) {\n\t\tdefine_property(fn, 'name', {\n\t\t\tvalue: '$effect'\n\t\t});\n\t}\n\n\tif (defer) {\n\t\tvar context = /** @type {ComponentContext} */ (component_context);\n\t\t(context.e ??= []).push({\n\t\t\tfn,\n\t\t\teffect: active_effect,\n\t\t\treaction: active_reaction\n\t\t});\n\t} else {\n\t\tvar signal = effect(fn);\n\t\treturn signal;\n\t}\n}\n\n/**\n * Internal representation of `$effect.pre(...)`\n * @param {() => void | (() => void)} fn\n * @returns {Effect}\n */\nexport function user_pre_effect(fn) {\n\tvalidate_effect('$effect.pre');\n\tif (DEV) {\n\t\tdefine_property(fn, 'name', {\n\t\t\tvalue: '$effect.pre'\n\t\t});\n\t}\n\treturn render_effect(fn);\n}\n\n/** @param {() => void | (() => void)} fn */\nexport function inspect_effect(fn) {\n\treturn create_effect(INSPECT_EFFECT, fn, true);\n}\n\n/**\n * Internal representation of `$effect.root(...)`\n * @param {() => void | (() => void)} fn\n * @returns {() => void}\n */\nexport function effect_root(fn) {\n\tconst effect = create_effect(ROOT_EFFECT, fn, true);\n\treturn () => {\n\t\tdestroy_effect(effect);\n\t};\n}\n\n/**\n * @param {() => void | (() => void)} fn\n * @returns {Effect}\n */\nexport function effect(fn) {\n\treturn create_effect(EFFECT, fn, false);\n}\n\n/**\n * Internal representation of `$: ..`\n * @param {() => any} deps\n * @param {() => void | (() => void)} fn\n */\nexport function legacy_pre_effect(deps, fn) {\n\tvar context = /** @type {ComponentContextLegacy} */ (component_context);\n\n\t/** @type {{ effect: null | Effect, ran: boolean }} */\n\tvar token = { effect: null, ran: false };\n\tcontext.l.r1.push(token);\n\n\ttoken.effect = render_effect(() => {\n\t\tdeps();\n\n\t\t// If this legacy pre effect has already run before the end of the reset, then\n\t\t// bail out to emulate the same behavior.\n\t\tif (token.ran) return;\n\n\t\ttoken.ran = true;\n\t\tset(context.l.r2, true);\n\t\tuntrack(fn);\n\t});\n}\n\nexport function legacy_pre_effect_reset() {\n\tvar context = /** @type {ComponentContextLegacy} */ (component_context);\n\n\trender_effect(() => {\n\t\tif (!get(context.l.r2)) return;\n\n\t\t// Run dirty `$:` statements\n\t\tfor (var token of context.l.r1) {\n\t\t\tvar effect = token.effect;\n\n\t\t\t// If the effect is CLEAN, then make it MAYBE_DIRTY. This ensures we traverse through\n\t\t\t// the effects dependencies and correctly ensure each dependency is up-to-date.\n\t\t\tif ((effect.f & CLEAN) !== 0) {\n\t\t\t\tset_signal_status(effect, MAYBE_DIRTY);\n\t\t\t}\n\n\t\t\tif (check_dirtiness(effect)) {\n\t\t\t\tupdate_effect(effect);\n\t\t\t}\n\n\t\t\ttoken.ran = false;\n\t\t}\n\n\t\tcontext.l.r2.v = false; // set directly to avoid rerunning this effect\n\t});\n}\n\n/**\n * @param {() => void | (() => void)} fn\n * @returns {Effect}\n */\nexport function render_effect(fn) {\n\treturn create_effect(RENDER_EFFECT, fn, true);\n}\n\n/**\n * @param {() => void | (() => void)} fn\n * @returns {Effect}\n */\nexport function template_effect(fn) {\n\tif (DEV) {\n\t\tdefine_property(fn, 'name', {\n\t\t\tvalue: '{expression}'\n\t\t});\n\t}\n\treturn block(fn);\n}\n\n/**\n * @param {(() => void)} fn\n * @param {number} flags\n */\nexport function block(fn, flags = 0) {\n\treturn create_effect(RENDER_EFFECT | BLOCK_EFFECT | flags, fn, true);\n}\n\n/**\n * @param {(() => void)} fn\n * @param {boolean} [push]\n */\nexport function branch(fn, push = true) {\n\treturn create_effect(RENDER_EFFECT | BRANCH_EFFECT, fn, true, push);\n}\n\n/**\n * @param {Effect} effect\n */\nexport function execute_effect_teardown(effect) {\n\tvar teardown = effect.teardown;\n\tif (teardown !== null) {\n\t\tconst previously_destroying_effect = is_destroying_effect;\n\t\tconst previous_reaction = active_reaction;\n\t\tset_is_destroying_effect(true);\n\t\tset_active_reaction(null);\n\t\ttry {\n\t\t\tteardown.call(null);\n\t\t} finally {\n\t\t\tset_is_destroying_effect(previously_destroying_effect);\n\t\t\tset_active_reaction(previous_reaction);\n\t\t}\n\t}\n}\n\n/**\n * @param {Effect} signal\n * @returns {void}\n */\nexport function destroy_effect_deriveds(signal) {\n\tvar deriveds = signal.deriveds;\n\n\tif (deriveds !== null) {\n\t\tsignal.deriveds = null;\n\n\t\tfor (var i = 0; i < deriveds.length; i += 1) {\n\t\t\tdestroy_derived(deriveds[i]);\n\t\t}\n\t}\n}\n\n/**\n * @param {Effect} signal\n * @param {boolean} remove_dom\n * @returns {void}\n */\nexport function destroy_effect_children(signal, remove_dom = false) {\n\tvar effect = signal.first;\n\tsignal.first = signal.last = null;\n\n\twhile (effect !== null) {\n\t\tvar next = effect.next;\n\t\tdestroy_effect(effect, remove_dom);\n\t\teffect = next;\n\t}\n}\n\n/**\n * @param {Effect} signal\n * @returns {void}\n */\nexport function destroy_block_effect_children(signal) {\n\tvar effect = signal.first;\n\n\twhile (effect !== null) {\n\t\tvar next = effect.next;\n\t\tif ((effect.f & BRANCH_EFFECT) === 0) {\n\t\t\tdestroy_effect(effect);\n\t\t}\n\t\teffect = next;\n\t}\n}\n\n/**\n * @param {Effect} effect\n * @param {boolean} [remove_dom]\n * @returns {void}\n */\nexport function destroy_effect(effect, remove_dom = true) {\n\tvar removed = false;\n\n\tif ((remove_dom || (effect.f & HEAD_EFFECT) !== 0) && effect.nodes_start !== null) {\n\t\t/** @type {TemplateNode | null} */\n\t\tvar node = effect.nodes_start;\n\t\tvar end = effect.nodes_end;\n\n\t\twhile (node !== null) {\n\t\t\t/** @type {TemplateNode | null} */\n\t\t\tvar next = node === end ? null : /** @type {TemplateNode} */ (get_next_sibling(node));\n\n\t\t\tnode.remove();\n\t\t\tnode = next;\n\t\t}\n\n\t\tremoved = true;\n\t}\n\n\tdestroy_effect_children(effect, remove_dom && !removed);\n\tdestroy_effect_deriveds(effect);\n\tremove_reactions(effect, 0);\n\tset_signal_status(effect, DESTROYED);\n\n\tvar transitions = effect.transitions;\n\n\tif (transitions !== null) {\n\t\tfor (const transition of transitions) {\n\t\t\ttransition.stop();\n\t\t}\n\t}\n\n\texecute_effect_teardown(effect);\n\n\tvar parent = effect.parent;\n\n\t// If the parent doesn't have any children, then skip this work altogether\n\tif (parent !== null && parent.first !== null) {\n\t\tunlink_effect(effect);\n\t}\n\n\tif (DEV) {\n\t\teffect.component_function = null;\n\t}\n\n\t// `first` and `child` are nulled out in destroy_effect_children\n\teffect.next =\n\t\teffect.prev =\n\t\teffect.teardown =\n\t\teffect.ctx =\n\t\teffect.deps =\n\t\teffect.parent =\n\t\teffect.fn =\n\t\teffect.nodes_start =\n\t\teffect.nodes_end =\n\t\t\tnull;\n}\n\n/**\n * Detach an effect from the effect tree, freeing up memory and\n * reducing the amount of work that happens on subsequent traversals\n * @param {Effect} effect\n */\nexport function unlink_effect(effect) {\n\tvar parent = effect.parent;\n\tvar prev = effect.prev;\n\tvar next = effect.next;\n\n\tif (prev !== null) prev.next = next;\n\tif (next !== null) next.prev = prev;\n\n\tif (parent !== null) {\n\t\tif (parent.first === effect) parent.first = next;\n\t\tif (parent.last === effect) parent.last = prev;\n\t}\n}\n\n/**\n * When a block effect is removed, we don't immediately destroy it or yank it\n * out of the DOM, because it might have transitions. Instead, we 'pause' it.\n * It stays around (in memory, and in the DOM) until outro transitions have\n * completed, and if the state change is reversed then we _resume_ it.\n * A paused effect does not update, and the DOM subtree becomes inert.\n * @param {Effect} effect\n * @param {() => void} [callback]\n */\nexport function pause_effect(effect, callback) {\n\t/** @type {TransitionManager[]} */\n\tvar transitions = [];\n\n\tpause_children(effect, transitions, true);\n\n\trun_out_transitions(transitions, () => {\n\t\tdestroy_effect(effect);\n\t\tif (callback) callback();\n\t});\n}\n\n/**\n * @param {TransitionManager[]} transitions\n * @param {() => void} fn\n */\nexport function run_out_transitions(transitions, fn) {\n\tvar remaining = transitions.length;\n\tif (remaining > 0) {\n\t\tvar check = () => --remaining || fn();\n\t\tfor (var transition of transitions) {\n\t\t\ttransition.out(check);\n\t\t}\n\t} else {\n\t\tfn();\n\t}\n}\n\n/**\n * @param {Effect} effect\n * @param {TransitionManager[]} transitions\n * @param {boolean} local\n */\nexport function pause_children(effect, transitions, local) {\n\tif ((effect.f & INERT) !== 0) return;\n\teffect.f ^= INERT;\n\n\tif (effect.transitions !== null) {\n\t\tfor (const transition of effect.transitions) {\n\t\t\tif (transition.is_global || local) {\n\t\t\t\ttransitions.push(transition);\n\t\t\t}\n\t\t}\n\t}\n\n\tvar child = effect.first;\n\n\twhile (child !== null) {\n\t\tvar sibling = child.next;\n\t\tvar transparent = (child.f & EFFECT_TRANSPARENT) !== 0 || (child.f & BRANCH_EFFECT) !== 0;\n\t\t// TODO we don't need to call pause_children recursively with a linked list in place\n\t\t// it's slightly more involved though as we have to account for `transparent` changing\n\t\t// through the tree.\n\t\tpause_children(child, transitions, transparent ? local : false);\n\t\tchild = sibling;\n\t}\n}\n\n/**\n * The opposite of `pause_effect`. We call this if (for example)\n * `x` becomes falsy then truthy: `{#if x}...{/if}`\n * @param {Effect} effect\n */\nexport function resume_effect(effect) {\n\tresume_children(effect, true);\n}\n\n/**\n * @param {Effect} effect\n * @param {boolean} local\n */\nfunction resume_children(effect, local) {\n\tif ((effect.f & INERT) === 0) return;\n\n\t// If a dependency of this effect changed while it was paused,\n\t// apply the change now\n\tif (check_dirtiness(effect)) {\n\t\tupdate_effect(effect);\n\t}\n\n\t// Ensure we toggle the flag after possibly updating the effect so that\n\t// each block logic can correctly operate on inert items\n\teffect.f ^= INERT;\n\n\tvar child = effect.first;\n\n\twhile (child !== null) {\n\t\tvar sibling = child.next;\n\t\tvar transparent = (child.f & EFFECT_TRANSPARENT) !== 0 || (child.f & BRANCH_EFFECT) !== 0;\n\t\t// TODO we don't need to call resume_children recursively with a linked list in place\n\t\t// it's slightly more involved though as we have to account for `transparent` changing\n\t\t// through the tree.\n\t\tresume_children(child, transparent ? local : false);\n\t\tchild = sibling;\n\t}\n\n\tif (effect.transitions !== null) {\n\t\tfor (const transition of effect.transitions) {\n\t\t\tif (transition.is_global || local) {\n\t\t\t\ttransition.in();\n\t\t\t}\n\t\t}\n\t}\n}\n","import { run_all } from '../../shared/utils.js';\n\n// Fallback for when requestIdleCallback is not available\nconst request_idle_callback =\n\ttypeof requestIdleCallback === 'undefined'\n\t\t? (/** @type {() => void} */ cb) => setTimeout(cb, 1)\n\t\t: requestIdleCallback;\n\nlet is_micro_task_queued = false;\nlet is_idle_task_queued = false;\n\n/** @type {Array<() => void>} */\nlet current_queued_micro_tasks = [];\n/** @type {Array<() => void>} */\nlet current_queued_idle_tasks = [];\n\nfunction process_micro_tasks() {\n\tis_micro_task_queued = false;\n\tconst tasks = current_queued_micro_tasks.slice();\n\tcurrent_queued_micro_tasks = [];\n\trun_all(tasks);\n}\n\nfunction process_idle_tasks() {\n\tis_idle_task_queued = false;\n\tconst tasks = current_queued_idle_tasks.slice();\n\tcurrent_queued_idle_tasks = [];\n\trun_all(tasks);\n}\n\n/**\n * @param {() => void} fn\n */\nexport function queue_micro_task(fn) {\n\tif (!is_micro_task_queued) {\n\t\tis_micro_task_queued = true;\n\t\tqueueMicrotask(process_micro_tasks);\n\t}\n\tcurrent_queued_micro_tasks.push(fn);\n}\n\n/**\n * @param {() => void} fn\n */\nexport function queue_idle_task(fn) {\n\tif (!is_idle_task_queued) {\n\t\tis_idle_task_queued = true;\n\t\trequest_idle_callback(process_idle_tasks);\n\t}\n\tcurrent_queued_idle_tasks.push(fn);\n}\n\n/**\n * Synchronously run any queued tasks.\n */\nexport function flush_tasks() {\n\tif (is_micro_task_queued) {\n\t\tprocess_micro_tasks();\n\t}\n\tif (is_idle_task_queued) {\n\t\tprocess_idle_tasks();\n\t}\n}\n","/* This file is generated by scripts/process-messages/index.js. Do not edit! */\n\nimport { DEV } from 'esm-env';\n\n/**\n * Cannot use `{@render children(...)}` if the parent component uses `let:` directives. Consider using a named snippet instead\n * @returns {never}\n */\nexport function invalid_default_snippet() {\n\tif (DEV) {\n\t\tconst error = new Error(`invalid_default_snippet\\nCannot use \\`{@render children(...)}\\` if the parent component uses \\`let:\\` directives. Consider using a named snippet instead`);\n\n\t\terror.name = 'Svelte error';\n\t\tthrow error;\n\t} else {\n\t\t// TODO print a link to the documentation\n\t\tthrow new Error(\"invalid_default_snippet\");\n\t}\n}\n\n/**\n * `%name%(...)` can only be used during component initialisation\n * @param {string} name\n * @returns {never}\n */\nexport function lifecycle_outside_component(name) {\n\tif (DEV) {\n\t\tconst error = new Error(`lifecycle_outside_component\\n\\`${name}(...)\\` can only be used during component initialisation`);\n\n\t\terror.name = 'Svelte error';\n\t\tthrow error;\n\t} else {\n\t\t// TODO print a link to the documentation\n\t\tthrow new Error(\"lifecycle_outside_component\");\n\t}\n}\n\n/**\n * `%name%` is not a store with a `subscribe` method\n * @param {string} name\n * @returns {never}\n */\nexport function store_invalid_shape(name) {\n\tif (DEV) {\n\t\tconst error = new Error(`store_invalid_shape\\n\\`${name}\\` is not a store with a \\`subscribe\\` method`);\n\n\t\terror.name = 'Svelte error';\n\t\tthrow error;\n\t} else {\n\t\t// TODO print a link to the documentation\n\t\tthrow new Error(\"store_invalid_shape\");\n\t}\n}\n\n/**\n * The `this` prop on `<svelte:element>` must be a string, if defined\n * @returns {never}\n */\nexport function svelte_element_invalid_this_value() {\n\tif (DEV) {\n\t\tconst error = new Error(`svelte_element_invalid_this_value\\nThe \\`this\\` prop on \\`<svelte:element>\\` must be a string, if defined`);\n\n\t\terror.name = 'Svelte error';\n\t\tthrow error;\n\t} else {\n\t\t// TODO print a link to the documentation\n\t\tthrow new Error(\"svelte_element_invalid_this_value\");\n\t}\n}","/** @import { ComponentContext, Derived, Effect, Reaction, Signal, Source, Value } from '#client' */\nimport { DEV } from 'esm-env';\nimport { define_property, get_descriptors, get_prototype_of } from '../shared/utils.js';\nimport {\n\tdestroy_block_effect_children,\n\tdestroy_effect_children,\n\tdestroy_effect_deriveds,\n\teffect,\n\texecute_effect_teardown,\n\tunlink_effect\n} from './reactivity/effects.js';\nimport {\n\tEFFECT,\n\tRENDER_EFFECT,\n\tDIRTY,\n\tMAYBE_DIRTY,\n\tCLEAN,\n\tDERIVED,\n\tUNOWNED,\n\tDESTROYED,\n\tINERT,\n\tBRANCH_EFFECT,\n\tSTATE_SYMBOL,\n\tBLOCK_EFFECT,\n\tROOT_EFFECT,\n\tLEGACY_DERIVED_PROP,\n\tDISCONNECTED\n} from './constants.js';\nimport { flush_tasks } from './dom/task.js';\nimport { add_owner } from './dev/ownership.js';\nimport { mutate, set, source } from './reactivity/sources.js';\nimport { destroy_derived, execute_derived, update_derived } from './reactivity/deriveds.js';\nimport * as e from './errors.js';\nimport { lifecycle_outside_component } from '../shared/errors.js';\nimport { FILENAME } from '../../constants.js';\n\nconst FLUSH_MICROTASK = 0;\nconst FLUSH_SYNC = 1;\n\n// Used for DEV time error handling\n/** @param {WeakSet<Error>} value */\nconst handled_errors = new WeakSet();\n// Used for controlling the flush of effects.\nlet scheduler_mode = FLUSH_MICROTASK;\n// Used for handling scheduling\nlet is_micro_task_queued = false;\n\nexport let is_flushing_effect = false;\nexport let is_destroying_effect = false;\n\n/** @param {boolean} value */\nexport function set_is_flushing_effect(value) {\n\tis_flushing_effect = value;\n}\n\n/** @param {boolean} value */\nexport function set_is_destroying_effect(value) {\n\tis_destroying_effect = value;\n}\n\n// Handle effect queues\n\n/** @type {Effect[]} */\nlet queued_root_effects = [];\n\nlet flush_count = 0;\n/** @type {Effect[]} Stack of effects, dev only */\nlet dev_effect_stack = [];\n// Handle signal reactivity tree dependencies and reactions\n\n/** @type {null | Reaction} */\nexport let active_reaction = null;\n\n/** @param {null | Reaction} reaction */\nexport function set_active_reaction(reaction) {\n\tactive_reaction = reaction;\n}\n\n/** @type {null | Effect} */\nexport let active_effect = null;\n\n/** @param {null | Effect} effect */\nexport function set_active_effect(effect) {\n\tactive_effect = effect;\n}\n\n/**\n * When sources are created within a derived, we record them so that we can safely allow\n * local mutations to these sources without the side-effect error being invoked unnecessarily.\n * @type {null | Source[]}\n */\nexport let derived_sources = null;\n\n/**\n * @param {Source[] | null} sources\n */\nexport function set_derived_sources(sources) {\n\tderived_sources = sources;\n}\n\n/**\n * The dependencies of the reaction that is currently being executed. In many cases,\n * the dependencies are unchanged between runs, and so this will be `null` unless\n * and until a new dependency is accessed  we track this via `skipped_deps`\n * @type {null | Value[]}\n */\nexport let new_deps = null;\n\nlet skipped_deps = 0;\n\n/**\n * Tracks writes that the effect it's executed in doesn't listen to yet,\n * so that the dependency can be added to the effect later on if it then reads it\n * @type {null | Source[]}\n */\nexport let untracked_writes = null;\n\n/** @param {null | Source[]} value */\nexport function set_untracked_writes(value) {\n\tuntracked_writes = value;\n}\n\n/** @type {number} Used by sources and deriveds for handling updates to unowned deriveds */\nlet current_version = 0;\n\n// If we are working with a get() chain that has no active container,\n// to prevent memory leaks, we skip adding the reaction.\nexport let skip_reaction = false;\n// Handle collecting all signals which are read during a specific time frame\nexport let is_signals_recorded = false;\nlet captured_signals = new Set();\n\n// Handling runtime component context\n/** @type {ComponentContext | null} */\nexport let component_context = null;\n\n/** @param {ComponentContext | null} context */\nexport function set_component_context(context) {\n\tcomponent_context = context;\n}\n\n/**\n * The current component function. Different from current component context:\n * ```html\n * <!-- App.svelte -->\n * <Foo>\n *   <Bar /> <!-- context == Foo.svelte, function == App.svelte -->\n * </Foo>\n * ```\n * @type {ComponentContext['function']}\n */\nexport let dev_current_component_function = null;\n\n/** @param {ComponentContext['function']} fn */\nexport function set_dev_current_component_function(fn) {\n\tdev_current_component_function = fn;\n}\n\nexport function increment_version() {\n\treturn ++current_version;\n}\n\n/** @returns {boolean} */\nexport function is_runes() {\n\treturn component_context !== null && component_context.l === null;\n}\n\n/**\n * Determines whether a derived or effect is dirty.\n * If it is MAYBE_DIRTY, will set the status to CLEAN\n * @param {Reaction} reaction\n * @returns {boolean}\n */\nexport function check_dirtiness(reaction) {\n\tvar flags = reaction.f;\n\n\tif ((flags & DIRTY) !== 0) {\n\t\treturn true;\n\t}\n\n\tif ((flags & MAYBE_DIRTY) !== 0) {\n\t\tvar dependencies = reaction.deps;\n\t\tvar is_unowned = (flags & UNOWNED) !== 0;\n\n\t\tif (dependencies !== null) {\n\t\t\tvar i;\n\n\t\t\tif ((flags & DISCONNECTED) !== 0) {\n\t\t\t\tfor (i = 0; i < dependencies.length; i++) {\n\t\t\t\t\t(dependencies[i].reactions ??= []).push(reaction);\n\t\t\t\t}\n\n\t\t\t\treaction.f ^= DISCONNECTED;\n\t\t\t}\n\n\t\t\tfor (i = 0; i < dependencies.length; i++) {\n\t\t\t\tvar dependency = dependencies[i];\n\n\t\t\t\tif (check_dirtiness(/** @type {Derived} */ (dependency))) {\n\t\t\t\t\tupdate_derived(/** @type {Derived} */ (dependency));\n\t\t\t\t}\n\n\t\t\t\t// If we are working with an unowned signal as part of an effect (due to !skip_reaction)\n\t\t\t\t// and the version hasn't changed, we still need to check that this reaction\n\t\t\t\t// is linked to the dependency source  otherwise future updates will not be caught.\n\t\t\t\tif (\n\t\t\t\t\tis_unowned &&\n\t\t\t\t\tactive_effect !== null &&\n\t\t\t\t\t!skip_reaction &&\n\t\t\t\t\t!dependency?.reactions?.includes(reaction)\n\t\t\t\t) {\n\t\t\t\t\t(dependency.reactions ??= []).push(reaction);\n\t\t\t\t}\n\n\t\t\t\tif (dependency.version > reaction.version) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Unowned signals should never be marked as clean.\n\t\tif (!is_unowned) {\n\t\t\tset_signal_status(reaction, CLEAN);\n\t\t}\n\t}\n\n\treturn false;\n}\n\n/**\n * @param {Error} error\n * @param {Effect} effect\n * @param {ComponentContext | null} component_context\n */\nfunction handle_error(error, effect, component_context) {\n\t// Given we don't yet have error boundaries, we will just always throw.\n\tif (!DEV || handled_errors.has(error) || component_context === null) {\n\t\tthrow error;\n\t}\n\n\tconst component_stack = [];\n\n\tconst effect_name = effect.fn?.name;\n\n\tif (effect_name) {\n\t\tcomponent_stack.push(effect_name);\n\t}\n\n\t/** @type {ComponentContext | null} */\n\tlet current_context = component_context;\n\n\twhile (current_context !== null) {\n\t\tif (DEV) {\n\t\t\t/** @type {string} */\n\t\t\tvar filename = current_context.function?.[FILENAME];\n\n\t\t\tif (filename) {\n\t\t\t\tconst file = filename.split('/').pop();\n\t\t\t\tcomponent_stack.push(file);\n\t\t\t}\n\t\t}\n\n\t\tcurrent_context = current_context.p;\n\t}\n\n\tconst indent = /Firefox/.test(navigator.userAgent) ? '  ' : '\\t';\n\tdefine_property(error, 'message', {\n\t\tvalue: error.message + `\\n${component_stack.map((name) => `\\n${indent}in ${name}`).join('')}\\n`\n\t});\n\n\tconst stack = error.stack;\n\n\t// Filter out internal files from callstack\n\tif (stack) {\n\t\tconst lines = stack.split('\\n');\n\t\tconst new_lines = [];\n\t\tfor (let i = 0; i < lines.length; i++) {\n\t\t\tconst line = lines[i];\n\t\t\tif (line.includes('svelte/src/internal')) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tnew_lines.push(line);\n\t\t}\n\t\tdefine_property(error, 'stack', {\n\t\t\tvalue: error.stack + new_lines.join('\\n')\n\t\t});\n\t}\n\n\thandled_errors.add(error);\n\tthrow error;\n}\n\n/**\n * @template V\n * @param {Reaction} reaction\n * @returns {V}\n */\nexport function update_reaction(reaction) {\n\tvar previous_deps = new_deps;\n\tvar previous_skipped_deps = skipped_deps;\n\tvar previous_untracked_writes = untracked_writes;\n\tvar previous_reaction = active_reaction;\n\tvar previous_skip_reaction = skip_reaction;\n\tvar prev_derived_sources = derived_sources;\n\tvar previous_component_context = component_context;\n\tvar flags = reaction.f;\n\n\tnew_deps = /** @type {null | Value[]} */ (null);\n\tskipped_deps = 0;\n\tuntracked_writes = null;\n\tactive_reaction = (flags & (BRANCH_EFFECT | ROOT_EFFECT)) === 0 ? reaction : null;\n\tskip_reaction = !is_flushing_effect && (flags & UNOWNED) !== 0;\n\tderived_sources = null;\n\tcomponent_context = reaction.ctx;\n\n\ttry {\n\t\tvar result = /** @type {Function} */ (0, reaction.fn)();\n\t\tvar deps = reaction.deps;\n\n\t\tif (new_deps !== null) {\n\t\t\tvar i;\n\n\t\t\tremove_reactions(reaction, skipped_deps);\n\n\t\t\tif (deps !== null && skipped_deps > 0) {\n\t\t\t\tdeps.length = skipped_deps + new_deps.length;\n\t\t\t\tfor (i = 0; i < new_deps.length; i++) {\n\t\t\t\t\tdeps[skipped_deps + i] = new_deps[i];\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\treaction.deps = deps = new_deps;\n\t\t\t}\n\n\t\t\tif (!skip_reaction) {\n\t\t\t\tfor (i = skipped_deps; i < deps.length; i++) {\n\t\t\t\t\t(deps[i].reactions ??= []).push(reaction);\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (deps !== null && skipped_deps < deps.length) {\n\t\t\tremove_reactions(reaction, skipped_deps);\n\t\t\tdeps.length = skipped_deps;\n\t\t}\n\n\t\treturn result;\n\t} finally {\n\t\tnew_deps = previous_deps;\n\t\tskipped_deps = previous_skipped_deps;\n\t\tuntracked_writes = previous_untracked_writes;\n\t\tactive_reaction = previous_reaction;\n\t\tskip_reaction = previous_skip_reaction;\n\t\tderived_sources = prev_derived_sources;\n\t\tcomponent_context = previous_component_context;\n\t}\n}\n\n/**\n * @template V\n * @param {Reaction} signal\n * @param {Value<V>} dependency\n * @returns {void}\n */\nfunction remove_reaction(signal, dependency) {\n\tlet reactions = dependency.reactions;\n\tif (reactions !== null) {\n\t\tvar index = reactions.indexOf(signal);\n\t\tif (index !== -1) {\n\t\t\tvar new_length = reactions.length - 1;\n\t\t\tif (new_length === 0) {\n\t\t\t\treactions = dependency.reactions = null;\n\t\t\t} else {\n\t\t\t\t// Swap with last element and then remove.\n\t\t\t\treactions[index] = reactions[new_length];\n\t\t\t\treactions.pop();\n\t\t\t}\n\t\t}\n\t}\n\t// If the derived has no reactions, then we can disconnect it from the graph,\n\t// allowing it to either reconnect in the future, or be GC'd by the VM.\n\tif (\n\t\treactions === null &&\n\t\t(dependency.f & DERIVED) !== 0 &&\n\t\t// Destroying a child effect while updating a parent effect can cause a dependency to appear\n\t\t// to be unused, when in fact it is used by the currently-updating parent. Checking `new_deps`\n\t\t// allows us to skip the expensive work of disconnecting and immediately reconnecting it\n\t\t(new_deps === null || !new_deps.includes(dependency))\n\t) {\n\t\tset_signal_status(dependency, MAYBE_DIRTY);\n\t\t// If we are working with a derived that is owned by an effect, then mark it as being\n\t\t// disconnected.\n\t\tif ((dependency.f & (UNOWNED | DISCONNECTED)) === 0) {\n\t\t\tdependency.f ^= DISCONNECTED;\n\t\t}\n\t\tremove_reactions(/** @type {Derived} **/ (dependency), 0);\n\t}\n}\n\n/**\n * @param {Reaction} signal\n * @param {number} start_index\n * @returns {void}\n */\nexport function remove_reactions(signal, start_index) {\n\tvar dependencies = signal.deps;\n\tif (dependencies === null) return;\n\n\tfor (var i = start_index; i < dependencies.length; i++) {\n\t\tremove_reaction(signal, dependencies[i]);\n\t}\n}\n\n/**\n * @param {Effect} effect\n * @returns {void}\n */\nexport function update_effect(effect) {\n\tvar flags = effect.f;\n\n\tif ((flags & DESTROYED) !== 0) {\n\t\treturn;\n\t}\n\n\tset_signal_status(effect, CLEAN);\n\n\tvar previous_effect = active_effect;\n\tvar previous_component_context = component_context;\n\n\tactive_effect = effect;\n\n\tif (DEV) {\n\t\tvar previous_component_fn = dev_current_component_function;\n\t\tdev_current_component_function = effect.component_function;\n\t}\n\n\ttry {\n\t\tif ((flags & BLOCK_EFFECT) !== 0) {\n\t\t\tdestroy_block_effect_children(effect);\n\t\t} else {\n\t\t\tdestroy_effect_children(effect);\n\t\t}\n\t\tdestroy_effect_deriveds(effect);\n\n\t\texecute_effect_teardown(effect);\n\t\tvar teardown = update_reaction(effect);\n\t\teffect.teardown = typeof teardown === 'function' ? teardown : null;\n\t\teffect.version = current_version;\n\n\t\tif (DEV) {\n\t\t\tdev_effect_stack.push(effect);\n\t\t}\n\t} catch (error) {\n\t\thandle_error(/** @type {Error} */ (error), effect, previous_component_context);\n\t} finally {\n\t\tactive_effect = previous_effect;\n\n\t\tif (DEV) {\n\t\t\tdev_current_component_function = previous_component_fn;\n\t\t}\n\t}\n}\n\nfunction infinite_loop_guard() {\n\tif (flush_count > 1000) {\n\t\tflush_count = 0;\n\t\tif (DEV) {\n\t\t\ttry {\n\t\t\t\te.effect_update_depth_exceeded();\n\t\t\t} catch (error) {\n\t\t\t\t// stack is garbage, ignore. Instead add a console.error message.\n\t\t\t\tdefine_property(error, 'stack', {\n\t\t\t\t\tvalue: ''\n\t\t\t\t});\n\t\t\t\t// eslint-disable-next-line no-console\n\t\t\t\tconsole.error(\n\t\t\t\t\t'Last ten effects were: ',\n\t\t\t\t\tdev_effect_stack.slice(-10).map((d) => d.fn)\n\t\t\t\t);\n\t\t\t\tdev_effect_stack = [];\n\t\t\t\tthrow error;\n\t\t\t}\n\t\t} else {\n\t\t\te.effect_update_depth_exceeded();\n\t\t}\n\t}\n\tflush_count++;\n}\n\n/**\n * @param {Array<Effect>} root_effects\n * @returns {void}\n */\nfunction flush_queued_root_effects(root_effects) {\n\tvar length = root_effects.length;\n\tif (length === 0) {\n\t\treturn;\n\t}\n\tinfinite_loop_guard();\n\n\tvar previously_flushing_effect = is_flushing_effect;\n\tis_flushing_effect = true;\n\n\ttry {\n\t\tfor (var i = 0; i < length; i++) {\n\t\t\tvar effect = root_effects[i];\n\n\t\t\tif ((effect.f & CLEAN) === 0) {\n\t\t\t\teffect.f ^= CLEAN;\n\t\t\t}\n\n\t\t\t/** @type {Effect[]} */\n\t\t\tvar collected_effects = [];\n\n\t\t\tprocess_effects(effect, collected_effects);\n\t\t\tflush_queued_effects(collected_effects);\n\t\t}\n\t} finally {\n\t\tis_flushing_effect = previously_flushing_effect;\n\t}\n}\n\n/**\n * @param {Array<Effect>} effects\n * @returns {void}\n */\nfunction flush_queued_effects(effects) {\n\tvar length = effects.length;\n\tif (length === 0) return;\n\n\tfor (var i = 0; i < length; i++) {\n\t\tvar effect = effects[i];\n\n\t\tif ((effect.f & (DESTROYED | INERT)) === 0 && check_dirtiness(effect)) {\n\t\t\tupdate_effect(effect);\n\n\t\t\t// Effects with no dependencies or teardown do not get added to the effect tree.\n\t\t\t// Deferred effects (e.g. `$effect(...)`) _are_ added to the tree because we\n\t\t\t// don't know if we need to keep them until they are executed. Doing the check\n\t\t\t// here (rather than in `update_effect`) allows us to skip the work for\n\t\t\t// immediate effects.\n\t\t\tif (effect.deps === null && effect.first === null && effect.nodes_start === null) {\n\t\t\t\tif (effect.teardown === null) {\n\t\t\t\t\t// remove this effect from the graph\n\t\t\t\t\tunlink_effect(effect);\n\t\t\t\t} else {\n\t\t\t\t\t// keep the effect in the graph, but free up some memory\n\t\t\t\t\teffect.fn = null;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunction process_deferred() {\n\tis_micro_task_queued = false;\n\tif (flush_count > 1001) {\n\t\treturn;\n\t}\n\tconst previous_queued_root_effects = queued_root_effects;\n\tqueued_root_effects = [];\n\tflush_queued_root_effects(previous_queued_root_effects);\n\tif (!is_micro_task_queued) {\n\t\tflush_count = 0;\n\t\tif (DEV) {\n\t\t\tdev_effect_stack = [];\n\t\t}\n\t}\n}\n\n/**\n * @param {Effect} signal\n * @returns {void}\n */\nexport function schedule_effect(signal) {\n\tif (scheduler_mode === FLUSH_MICROTASK) {\n\t\tif (!is_micro_task_queued) {\n\t\t\tis_micro_task_queued = true;\n\t\t\tqueueMicrotask(process_deferred);\n\t\t}\n\t}\n\n\tvar effect = signal;\n\n\twhile (effect.parent !== null) {\n\t\teffect = effect.parent;\n\t\tvar flags = effect.f;\n\n\t\tif ((flags & (ROOT_EFFECT | BRANCH_EFFECT)) !== 0) {\n\t\t\tif ((flags & CLEAN) === 0) return;\n\t\t\teffect.f ^= CLEAN;\n\t\t}\n\t}\n\n\tqueued_root_effects.push(effect);\n}\n\n/**\n *\n * This function both runs render effects and collects user effects in topological order\n * from the starting effect passed in. Effects will be collected when they match the filtered\n * bitwise flag passed in only. The collected effects array will be populated with all the user\n * effects to be flushed.\n *\n * @param {Effect} effect\n * @param {Effect[]} collected_effects\n * @returns {void}\n */\nfunction process_effects(effect, collected_effects) {\n\tvar current_effect = effect.first;\n\tvar effects = [];\n\n\tmain_loop: while (current_effect !== null) {\n\t\tvar flags = current_effect.f;\n\t\tvar is_branch = (flags & BRANCH_EFFECT) !== 0;\n\t\tvar is_skippable_branch = is_branch && (flags & CLEAN) !== 0;\n\n\t\tif (!is_skippable_branch && (flags & INERT) === 0) {\n\t\t\tif ((flags & RENDER_EFFECT) !== 0) {\n\t\t\t\tif (is_branch) {\n\t\t\t\t\tcurrent_effect.f ^= CLEAN;\n\t\t\t\t} else if (check_dirtiness(current_effect)) {\n\t\t\t\t\tupdate_effect(current_effect);\n\t\t\t\t}\n\n\t\t\t\tvar child = current_effect.first;\n\n\t\t\t\tif (child !== null) {\n\t\t\t\t\tcurrent_effect = child;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t} else if ((flags & EFFECT) !== 0) {\n\t\t\t\teffects.push(current_effect);\n\t\t\t}\n\t\t}\n\n\t\tvar sibling = current_effect.next;\n\n\t\tif (sibling === null) {\n\t\t\tlet parent = current_effect.parent;\n\n\t\t\twhile (parent !== null) {\n\t\t\t\tif (effect === parent) {\n\t\t\t\t\tbreak main_loop;\n\t\t\t\t}\n\t\t\t\tvar parent_sibling = parent.next;\n\t\t\t\tif (parent_sibling !== null) {\n\t\t\t\t\tcurrent_effect = parent_sibling;\n\t\t\t\t\tcontinue main_loop;\n\t\t\t\t}\n\t\t\t\tparent = parent.parent;\n\t\t\t}\n\t\t}\n\n\t\tcurrent_effect = sibling;\n\t}\n\n\t// We might be dealing with many effects here, far more than can be spread into\n\t// an array push call (callstack overflow). So let's deal with each effect in a loop.\n\tfor (var i = 0; i < effects.length; i++) {\n\t\tchild = effects[i];\n\t\tcollected_effects.push(child);\n\t\tprocess_effects(child, collected_effects);\n\t}\n}\n\n/**\n * Internal version of `flushSync` with the option to not flush previous effects.\n * Returns the result of the passed function, if given.\n * @param {() => any} [fn]\n * @returns {any}\n */\nexport function flush_sync(fn) {\n\tvar previous_scheduler_mode = scheduler_mode;\n\tvar previous_queued_root_effects = queued_root_effects;\n\n\ttry {\n\t\tinfinite_loop_guard();\n\n\t\t/** @type {Effect[]} */\n\t\tconst root_effects = [];\n\n\t\tscheduler_mode = FLUSH_SYNC;\n\t\tqueued_root_effects = root_effects;\n\t\tis_micro_task_queued = false;\n\n\t\tflush_queued_root_effects(previous_queued_root_effects);\n\n\t\tvar result = fn?.();\n\n\t\tflush_tasks();\n\t\tif (queued_root_effects.length > 0 || root_effects.length > 0) {\n\t\t\tflush_sync();\n\t\t}\n\n\t\tflush_count = 0;\n\t\tif (DEV) {\n\t\t\tdev_effect_stack = [];\n\t\t}\n\n\t\treturn result;\n\t} finally {\n\t\tscheduler_mode = previous_scheduler_mode;\n\t\tqueued_root_effects = previous_queued_root_effects;\n\t}\n}\n\n/**\n * Returns a promise that resolves once any pending state changes have been applied.\n * @returns {Promise<void>}\n */\nexport async function tick() {\n\tawait Promise.resolve();\n\t// By calling flush_sync we guarantee that any pending state changes are applied after one tick.\n\t// TODO look into whether we can make flushing subsequent updates synchronously in the future.\n\tflush_sync();\n}\n\n/**\n * @template V\n * @param {Value<V>} signal\n * @returns {V}\n */\nexport function get(signal) {\n\tvar flags = signal.f;\n\tvar is_derived = (flags & DERIVED) !== 0;\n\n\t// If the derived is destroyed, just execute it again without retaining\n\t// its memoisation properties as the derived is stale\n\tif (is_derived && (flags & DESTROYED) !== 0) {\n\t\tvar value = execute_derived(/** @type {Derived} */ (signal));\n\t\t// Ensure the derived remains destroyed\n\t\tdestroy_derived(/** @type {Derived} */ (signal));\n\t\treturn value;\n\t}\n\n\tif (is_signals_recorded) {\n\t\tcaptured_signals.add(signal);\n\t}\n\n\t// Register the dependency on the current reaction signal.\n\tif (active_reaction !== null) {\n\t\tif (derived_sources !== null && derived_sources.includes(signal)) {\n\t\t\te.state_unsafe_local_read();\n\t\t}\n\t\tvar deps = active_reaction.deps;\n\n\t\t// If the signal is accessing the same dependencies in the same\n\t\t// order as it did last time, increment `skipped_deps`\n\t\t// rather than updating `new_deps`, which creates GC cost\n\t\tif (new_deps === null && deps !== null && deps[skipped_deps] === signal) {\n\t\t\tskipped_deps++;\n\t\t} else if (new_deps === null) {\n\t\t\tnew_deps = [signal];\n\t\t} else {\n\t\t\tnew_deps.push(signal);\n\t\t}\n\n\t\tif (\n\t\t\tuntracked_writes !== null &&\n\t\t\tactive_effect !== null &&\n\t\t\t(active_effect.f & CLEAN) !== 0 &&\n\t\t\t(active_effect.f & BRANCH_EFFECT) === 0 &&\n\t\t\tuntracked_writes.includes(signal)\n\t\t) {\n\t\t\tset_signal_status(active_effect, DIRTY);\n\t\t\tschedule_effect(active_effect);\n\t\t}\n\t} else if (is_derived && /** @type {Derived} */ (signal).deps === null) {\n\t\tvar derived = /** @type {Derived} */ (signal);\n\t\tvar parent = derived.parent;\n\n\t\tif (parent !== null && !parent.deriveds?.includes(derived)) {\n\t\t\t(parent.deriveds ??= []).push(derived);\n\t\t}\n\t}\n\n\tif (is_derived) {\n\t\tderived = /** @type {Derived} */ (signal);\n\n\t\tif (check_dirtiness(derived)) {\n\t\t\tupdate_derived(derived);\n\t\t}\n\t}\n\n\treturn signal.v;\n}\n\n/**\n * Like `get`, but checks for `undefined`. Used for `var` declarations because they can be accessed before being declared\n * @template V\n * @param {Value<V> | undefined} signal\n * @returns {V | undefined}\n */\nexport function safe_get(signal) {\n\treturn signal && get(signal);\n}\n\n/**\n * Invokes a function and captures all signals that are read during the invocation,\n * then invalidates them.\n * @param {() => any} fn\n */\nexport function invalidate_inner_signals(fn) {\n\tvar previous_is_signals_recorded = is_signals_recorded;\n\tvar previous_captured_signals = captured_signals;\n\tis_signals_recorded = true;\n\tcaptured_signals = new Set();\n\tvar captured = captured_signals;\n\tvar signal;\n\ttry {\n\t\tuntrack(fn);\n\t} finally {\n\t\tis_signals_recorded = previous_is_signals_recorded;\n\t\tif (is_signals_recorded) {\n\t\t\tfor (signal of captured_signals) {\n\t\t\t\tprevious_captured_signals.add(signal);\n\t\t\t}\n\t\t}\n\t\tcaptured_signals = previous_captured_signals;\n\t}\n\tfor (signal of captured) {\n\t\t// Go one level up because derived signals created as part of props in legacy mode\n\t\tif ((signal.f & LEGACY_DERIVED_PROP) !== 0) {\n\t\t\tfor (const dep of /** @type {Derived} */ (signal).deps || []) {\n\t\t\t\tif ((dep.f & DERIVED) === 0) {\n\t\t\t\t\tmutate(dep, null /* doesnt matter */);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tmutate(signal, null /* doesnt matter */);\n\t\t}\n\t}\n}\n\n/**\n * Use `untrack` to prevent something from being treated as an `$effect`/`$derived` dependency.\n * @template T\n * @param {() => T} fn\n * @returns {T}\n */\nexport function untrack(fn) {\n\tconst previous_reaction = active_reaction;\n\ttry {\n\t\tactive_reaction = null;\n\t\treturn fn();\n\t} finally {\n\t\tactive_reaction = previous_reaction;\n\t}\n}\n\nconst STATUS_MASK = ~(DIRTY | MAYBE_DIRTY | CLEAN);\n\n/**\n * @param {Signal} signal\n * @param {number} status\n * @returns {void}\n */\nexport function set_signal_status(signal, status) {\n\tsignal.f = (signal.f & STATUS_MASK) | status;\n}\n\n/**\n * Retrieves the context that belongs to the closest parent component with the specified `key`.\n * Must be called during component initialisation.\n *\n * @template T\n * @param {any} key\n * @returns {T}\n */\nexport function getContext(key) {\n\tconst context_map = get_or_init_context_map('getContext');\n\tconst result = /** @type {T} */ (context_map.get(key));\n\n\tif (DEV) {\n\t\tconst fn = /** @type {ComponentContext} */ (component_context).function;\n\t\tif (fn) {\n\t\t\tadd_owner(result, fn, true);\n\t\t}\n\t}\n\n\treturn result;\n}\n\n/**\n * Associates an arbitrary `context` object with the current component and the specified `key`\n * and returns that object. The context is then available to children of the component\n * (including slotted content) with `getContext`.\n *\n * Like lifecycle functions, this must be called during component initialisation.\n *\n * @template T\n * @param {any} key\n * @param {T} context\n * @returns {T}\n */\nexport function setContext(key, context) {\n\tconst context_map = get_or_init_context_map('setContext');\n\tcontext_map.set(key, context);\n\treturn context;\n}\n\n/**\n * Checks whether a given `key` has been set in the context of a parent component.\n * Must be called during component initialisation.\n *\n * @param {any} key\n * @returns {boolean}\n */\nexport function hasContext(key) {\n\tconst context_map = get_or_init_context_map('hasContext');\n\treturn context_map.has(key);\n}\n\n/**\n * Retrieves the whole context map that belongs to the closest parent component.\n * Must be called during component initialisation. Useful, for example, if you\n * programmatically create a component and want to pass the existing context to it.\n *\n * @template {Map<any, any>} [T=Map<any, any>]\n * @returns {T}\n */\nexport function getAllContexts() {\n\tconst context_map = get_or_init_context_map('getAllContexts');\n\n\tif (DEV) {\n\t\tconst fn = component_context?.function;\n\t\tif (fn) {\n\t\t\tfor (const value of context_map.values()) {\n\t\t\t\tadd_owner(value, fn, true);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn /** @type {T} */ (context_map);\n}\n\n/**\n * @param {string} name\n * @returns {Map<unknown, unknown>}\n */\nfunction get_or_init_context_map(name) {\n\tif (component_context === null) {\n\t\tlifecycle_outside_component(name);\n\t}\n\n\treturn (component_context.c ??= new Map(get_parent_context(component_context) || undefined));\n}\n\n/**\n * @param {ComponentContext} component_context\n * @returns {Map<unknown, unknown> | null}\n */\nfunction get_parent_context(component_context) {\n\tlet parent = component_context.p;\n\twhile (parent !== null) {\n\t\tconst context_map = parent.c;\n\t\tif (context_map !== null) {\n\t\t\treturn context_map;\n\t\t}\n\t\tparent = parent.p;\n\t}\n\treturn null;\n}\n\n/**\n * @param {Value<number>} signal\n * @param {1 | -1} [d]\n * @returns {number}\n */\nexport function update(signal, d = 1) {\n\tvar value = +get(signal);\n\tset(signal, value + d);\n\treturn value;\n}\n\n/**\n * @param {Value<number>} signal\n * @param {1 | -1} [d]\n * @returns {number}\n */\nexport function update_pre(signal, d = 1) {\n\treturn set(signal, +get(signal) + d);\n}\n\n/**\n * @param {Record<string, unknown>} obj\n * @param {string[]} keys\n * @returns {Record<string, unknown>}\n */\nexport function exclude_from_object(obj, keys) {\n\t/** @type {Record<string, unknown>} */\n\tvar result = {};\n\n\tfor (var key in obj) {\n\t\tif (!keys.includes(key)) {\n\t\t\tresult[key] = obj[key];\n\t\t}\n\t}\n\n\treturn result;\n}\n\n/**\n * @param {Record<string, unknown>} props\n * @param {any} runes\n * @param {Function} [fn]\n * @returns {void}\n */\nexport function push(props, runes = false, fn) {\n\tcomponent_context = {\n\t\tp: component_context,\n\t\tc: null,\n\t\te: null,\n\t\tm: false,\n\t\ts: props,\n\t\tx: null,\n\t\tl: null\n\t};\n\n\tif (!runes) {\n\t\tcomponent_context.l = {\n\t\t\ts: null,\n\t\t\tu: null,\n\t\t\tr1: [],\n\t\t\tr2: source(false)\n\t\t};\n\t}\n\n\tif (DEV) {\n\t\t// component function\n\t\tcomponent_context.function = fn;\n\t\tdev_current_component_function = fn;\n\t}\n}\n\n/**\n * @template {Record<string, any>} T\n * @param {T} [component]\n * @returns {T}\n */\nexport function pop(component) {\n\tconst context_stack_item = component_context;\n\tif (context_stack_item !== null) {\n\t\tif (component !== undefined) {\n\t\t\tcontext_stack_item.x = component;\n\t\t}\n\t\tconst component_effects = context_stack_item.e;\n\t\tif (component_effects !== null) {\n\t\t\tvar previous_effect = active_effect;\n\t\t\tvar previous_reaction = active_reaction;\n\t\t\tcontext_stack_item.e = null;\n\t\t\ttry {\n\t\t\t\tfor (var i = 0; i < component_effects.length; i++) {\n\t\t\t\t\tvar component_effect = component_effects[i];\n\t\t\t\t\tset_active_effect(component_effect.effect);\n\t\t\t\t\tset_active_reaction(component_effect.reaction);\n\t\t\t\t\teffect(component_effect.fn);\n\t\t\t\t}\n\t\t\t} finally {\n\t\t\t\tset_active_effect(previous_effect);\n\t\t\t\tset_active_reaction(previous_reaction);\n\t\t\t}\n\t\t}\n\t\tcomponent_context = context_stack_item.p;\n\t\tif (DEV) {\n\t\t\tdev_current_component_function = context_stack_item.p?.function ?? null;\n\t\t}\n\t\tcontext_stack_item.m = true;\n\t}\n\t// Micro-optimization: Don't set .a above to the empty object\n\t// so it can be garbage-collected when the return here is unused\n\treturn component || /** @type {T} */ ({});\n}\n\n/**\n * Possibly traverse an object and read all its properties so that they're all reactive in case this is `$state`.\n * Does only check first level of an object for performance reasons (heuristic should be good for 99% of all cases).\n * @param {any} value\n * @returns {void}\n */\nexport function deep_read_state(value) {\n\tif (typeof value !== 'object' || !value || value instanceof EventTarget) {\n\t\treturn;\n\t}\n\n\tif (STATE_SYMBOL in value) {\n\t\tdeep_read(value);\n\t} else if (!Array.isArray(value)) {\n\t\tfor (let key in value) {\n\t\t\tconst prop = value[key];\n\t\t\tif (typeof prop === 'object' && prop && STATE_SYMBOL in prop) {\n\t\t\t\tdeep_read(prop);\n\t\t\t}\n\t\t}\n\t}\n}\n\n/**\n * Deeply traverse an object and read all its properties\n * so that they're all reactive in case this is `$state`\n * @param {any} value\n * @param {Set<any>} visited\n * @returns {void}\n */\nexport function deep_read(value, visited = new Set()) {\n\tif (\n\t\ttypeof value === 'object' &&\n\t\tvalue !== null &&\n\t\t// We don't want to traverse DOM elements\n\t\t!(value instanceof EventTarget) &&\n\t\t!visited.has(value)\n\t) {\n\t\tvisited.add(value);\n\t\t// When working with a possible SvelteDate, this\n\t\t// will ensure we capture changes to it.\n\t\tif (value instanceof Date) {\n\t\t\tvalue.getTime();\n\t\t}\n\t\tfor (let key in value) {\n\t\t\ttry {\n\t\t\t\tdeep_read(value[key], visited);\n\t\t\t} catch (e) {\n\t\t\t\t// continue\n\t\t\t}\n\t\t}\n\t\tconst proto = get_prototype_of(value);\n\t\tif (\n\t\t\tproto !== Object.prototype &&\n\t\t\tproto !== Array.prototype &&\n\t\t\tproto !== Map.prototype &&\n\t\t\tproto !== Set.prototype &&\n\t\t\tproto !== Date.prototype\n\t\t) {\n\t\t\tconst descriptors = get_descriptors(proto);\n\t\t\tfor (let key in descriptors) {\n\t\t\t\tconst get = descriptors[key].get;\n\t\t\t\tif (get) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tget.call(value);\n\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\t// continue\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nif (DEV) {\n\t/**\n\t * @param {string} rune\n\t */\n\tfunction throw_rune_error(rune) {\n\t\tif (!(rune in globalThis)) {\n\t\t\t// TODO if people start adjusting the \"this can contain runes\" config through v-p-s more, adjust this message\n\t\t\t/** @type {any} */\n\t\t\tlet value; // let's hope noone modifies this global, but belts and braces\n\t\t\tObject.defineProperty(globalThis, rune, {\n\t\t\t\tconfigurable: true,\n\t\t\t\t// eslint-disable-next-line getter-return\n\t\t\t\tget: () => {\n\t\t\t\t\tif (value !== undefined) {\n\t\t\t\t\t\treturn value;\n\t\t\t\t\t}\n\n\t\t\t\t\te.rune_outside_svelte(rune);\n\t\t\t\t},\n\t\t\t\tset: (v) => {\n\t\t\t\t\tvalue = v;\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t}\n\n\tthrow_rune_error('$state');\n\tthrow_rune_error('$effect');\n\tthrow_rune_error('$derived');\n\tthrow_rune_error('$inspect');\n\tthrow_rune_error('$props');\n\tthrow_rune_error('$bindable');\n}\n","/** @import { ProxyMetadata, ProxyStateObject, Source } from '#client' */\nimport { DEV } from 'esm-env';\nimport { get, component_context, active_effect } from './runtime.js';\nimport {\n\tarray_prototype,\n\tget_descriptor,\n\tget_prototype_of,\n\tis_array,\n\tobject_prototype\n} from '../shared/utils.js';\nimport { check_ownership, widen_ownership } from './dev/ownership.js';\nimport { source, set } from './reactivity/sources.js';\nimport { STATE_SYMBOL, STATE_SYMBOL_METADATA } from './constants.js';\nimport { UNINITIALIZED } from '../../constants.js';\nimport * as e from './errors.js';\n\n/**\n * @template T\n * @param {T} value\n * @param {ProxyMetadata | null} [parent]\n * @param {Source<T>} [prev] dev mode only\n * @returns {T}\n */\nexport function proxy(value, parent = null, prev) {\n\t// if non-proxyable, or is already a proxy, return `value`\n\tif (typeof value !== 'object' || value === null || STATE_SYMBOL in value) {\n\t\treturn value;\n\t}\n\n\tconst prototype = get_prototype_of(value);\n\n\tif (prototype !== object_prototype && prototype !== array_prototype) {\n\t\treturn value;\n\t}\n\n\t/** @type {Map<any, Source<any>>} */\n\tvar sources = new Map();\n\tvar is_proxied_array = is_array(value);\n\tvar version = source(0);\n\n\tif (is_proxied_array) {\n\t\t// We need to create the length source eagerly to ensure that\n\t\t// mutations to the array are properly synced with our proxy\n\t\tsources.set('length', source(/** @type {any[]} */ (value).length));\n\t}\n\n\t/** @type {ProxyMetadata} */\n\tvar metadata;\n\n\tif (DEV) {\n\t\tmetadata = {\n\t\t\tparent,\n\t\t\towners: null\n\t\t};\n\n\t\tif (prev) {\n\t\t\t// Reuse owners from previous state; necessary because reassignment is not guaranteed to have correct component context.\n\t\t\t// If no previous proxy exists we play it safe and assume ownerless state\n\t\t\t// @ts-expect-error\n\t\t\tconst prev_owners = prev.v?.[STATE_SYMBOL_METADATA]?.owners;\n\t\t\tmetadata.owners = prev_owners ? new Set(prev_owners) : null;\n\t\t} else {\n\t\t\tmetadata.owners =\n\t\t\t\tparent === null\n\t\t\t\t\t? component_context !== null\n\t\t\t\t\t\t? new Set([component_context.function])\n\t\t\t\t\t\t: null\n\t\t\t\t\t: new Set();\n\t\t}\n\t}\n\n\treturn new Proxy(/** @type {any} */ (value), {\n\t\tdefineProperty(_, prop, descriptor) {\n\t\t\tif (\n\t\t\t\t!('value' in descriptor) ||\n\t\t\t\tdescriptor.configurable === false ||\n\t\t\t\tdescriptor.enumerable === false ||\n\t\t\t\tdescriptor.writable === false\n\t\t\t) {\n\t\t\t\t// we disallow non-basic descriptors, because unless they are applied to the\n\t\t\t\t// target object  which we avoid, so that state can be forked  we will run\n\t\t\t\t// afoul of the various invariants\n\t\t\t\t// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy/Proxy/getOwnPropertyDescriptor#invariants\n\t\t\t\te.state_descriptors_fixed();\n\t\t\t}\n\n\t\t\tvar s = sources.get(prop);\n\n\t\t\tif (s === undefined) {\n\t\t\t\ts = source(descriptor.value);\n\t\t\t\tsources.set(prop, s);\n\t\t\t} else {\n\t\t\t\tset(s, proxy(descriptor.value, metadata));\n\t\t\t}\n\n\t\t\treturn true;\n\t\t},\n\n\t\tdeleteProperty(target, prop) {\n\t\t\tvar s = sources.get(prop);\n\n\t\t\tif (s === undefined) {\n\t\t\t\tif (prop in target) {\n\t\t\t\t\tsources.set(prop, source(UNINITIALIZED));\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// When working with arrays, we need to also ensure we update the length when removing\n\t\t\t\t// an indexed property\n\t\t\t\tif (is_proxied_array && typeof prop === 'string') {\n\t\t\t\t\tvar ls = /** @type {Source<number>} */ (sources.get('length'));\n\t\t\t\t\tvar n = Number(prop);\n\n\t\t\t\t\tif (Number.isInteger(n) && n < ls.v) {\n\t\t\t\t\t\tset(ls, n);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tset(s, UNINITIALIZED);\n\t\t\t\tupdate_version(version);\n\t\t\t}\n\n\t\t\treturn true;\n\t\t},\n\n\t\tget(target, prop, receiver) {\n\t\t\tif (DEV && prop === STATE_SYMBOL_METADATA) {\n\t\t\t\treturn metadata;\n\t\t\t}\n\n\t\t\tif (prop === STATE_SYMBOL) {\n\t\t\t\treturn value;\n\t\t\t}\n\n\t\t\tvar s = sources.get(prop);\n\t\t\tvar exists = prop in target;\n\n\t\t\t// create a source, but only if it's an own property and not a prototype property\n\t\t\tif (s === undefined && (!exists || get_descriptor(target, prop)?.writable)) {\n\t\t\t\ts = source(proxy(exists ? target[prop] : UNINITIALIZED, metadata));\n\t\t\t\tsources.set(prop, s);\n\t\t\t}\n\n\t\t\tif (s !== undefined) {\n\t\t\t\tvar v = get(s);\n\n\t\t\t\t// In case of something like `foo = bar.map(...)`, foo would have ownership\n\t\t\t\t// of the array itself, while the individual items would have ownership\n\t\t\t\t// of the component that created bar. That means if we later do `foo[0].baz = 42`,\n\t\t\t\t// we could get a false-positive ownership violation, since the two proxies\n\t\t\t\t// are not connected to each other via the parent metadata relationship.\n\t\t\t\t// For this reason, we need to widen the ownership of the children\n\t\t\t\t// upon access when we detect they are not connected.\n\t\t\t\tif (DEV) {\n\t\t\t\t\t/** @type {ProxyMetadata | undefined} */\n\t\t\t\t\tvar prop_metadata = v?.[STATE_SYMBOL_METADATA];\n\t\t\t\t\tif (prop_metadata && prop_metadata?.parent !== metadata) {\n\t\t\t\t\t\twiden_ownership(metadata, prop_metadata);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn v === UNINITIALIZED ? undefined : v;\n\t\t\t}\n\n\t\t\treturn Reflect.get(target, prop, receiver);\n\t\t},\n\n\t\tgetOwnPropertyDescriptor(target, prop) {\n\t\t\tvar descriptor = Reflect.getOwnPropertyDescriptor(target, prop);\n\n\t\t\tif (descriptor && 'value' in descriptor) {\n\t\t\t\tvar s = sources.get(prop);\n\t\t\t\tif (s) descriptor.value = get(s);\n\t\t\t} else if (descriptor === undefined) {\n\t\t\t\tvar source = sources.get(prop);\n\t\t\t\tvar value = source?.v;\n\n\t\t\t\tif (source !== undefined && value !== UNINITIALIZED) {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tenumerable: true,\n\t\t\t\t\t\tconfigurable: true,\n\t\t\t\t\t\tvalue,\n\t\t\t\t\t\twritable: true\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn descriptor;\n\t\t},\n\n\t\thas(target, prop) {\n\t\t\tif (DEV && prop === STATE_SYMBOL_METADATA) {\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tif (prop === STATE_SYMBOL) {\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tvar s = sources.get(prop);\n\t\t\tvar has = (s !== undefined && s.v !== UNINITIALIZED) || Reflect.has(target, prop);\n\n\t\t\tif (\n\t\t\t\ts !== undefined ||\n\t\t\t\t(active_effect !== null && (!has || get_descriptor(target, prop)?.writable))\n\t\t\t) {\n\t\t\t\tif (s === undefined) {\n\t\t\t\t\ts = source(has ? proxy(target[prop], metadata) : UNINITIALIZED);\n\t\t\t\t\tsources.set(prop, s);\n\t\t\t\t}\n\n\t\t\t\tvar value = get(s);\n\t\t\t\tif (value === UNINITIALIZED) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn has;\n\t\t},\n\n\t\tset(target, prop, value, receiver) {\n\t\t\tvar s = sources.get(prop);\n\t\t\tvar has = prop in target;\n\n\t\t\t// variable.length = value -> clear all signals with index >= value\n\t\t\tif (is_proxied_array && prop === 'length') {\n\t\t\t\tfor (var i = value; i < /** @type {Source<number>} */ (s).v; i += 1) {\n\t\t\t\t\tvar other_s = sources.get(i + '');\n\t\t\t\t\tif (other_s !== undefined) {\n\t\t\t\t\t\tset(other_s, UNINITIALIZED);\n\t\t\t\t\t} else if (i in target) {\n\t\t\t\t\t\t// If the item exists in the original, we need to create a uninitialized source,\n\t\t\t\t\t\t// else a later read of the property would result in a source being created with\n\t\t\t\t\t\t// the value of the original item at that index.\n\t\t\t\t\t\tother_s = source(UNINITIALIZED);\n\t\t\t\t\t\tsources.set(i + '', other_s);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// If we haven't yet created a source for this property, we need to ensure\n\t\t\t// we do so otherwise if we read it later, then the write won't be tracked and\n\t\t\t// the heuristics of effects will be different vs if we had read the proxied\n\t\t\t// object property before writing to that property.\n\t\t\tif (s === undefined) {\n\t\t\t\tif (!has || get_descriptor(target, prop)?.writable) {\n\t\t\t\t\ts = source(undefined);\n\t\t\t\t\tset(s, proxy(value, metadata));\n\t\t\t\t\tsources.set(prop, s);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\thas = s.v !== UNINITIALIZED;\n\t\t\t\tset(s, proxy(value, metadata));\n\t\t\t}\n\n\t\t\tif (DEV) {\n\t\t\t\t/** @type {ProxyMetadata | undefined} */\n\t\t\t\tvar prop_metadata = value?.[STATE_SYMBOL_METADATA];\n\t\t\t\tif (prop_metadata && prop_metadata?.parent !== metadata) {\n\t\t\t\t\twiden_ownership(metadata, prop_metadata);\n\t\t\t\t}\n\t\t\t\tcheck_ownership(metadata);\n\t\t\t}\n\n\t\t\tvar descriptor = Reflect.getOwnPropertyDescriptor(target, prop);\n\n\t\t\t// Set the new value before updating any signals so that any listeners get the new value\n\t\t\tif (descriptor?.set) {\n\t\t\t\tdescriptor.set.call(receiver, value);\n\t\t\t}\n\n\t\t\tif (!has) {\n\t\t\t\t// If we have mutated an array directly, we might need to\n\t\t\t\t// signal that length has also changed. Do it before updating metadata\n\t\t\t\t// to ensure that iterating over the array as a result of a metadata update\n\t\t\t\t// will not cause the length to be out of sync.\n\t\t\t\tif (is_proxied_array && typeof prop === 'string') {\n\t\t\t\t\tvar ls = /** @type {Source<number>} */ (sources.get('length'));\n\t\t\t\t\tvar n = Number(prop);\n\n\t\t\t\t\tif (Number.isInteger(n) && n >= ls.v) {\n\t\t\t\t\t\tset(ls, n + 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tupdate_version(version);\n\t\t\t}\n\n\t\t\treturn true;\n\t\t},\n\n\t\townKeys(target) {\n\t\t\tget(version);\n\n\t\t\tvar own_keys = Reflect.ownKeys(target).filter((key) => {\n\t\t\t\tvar source = sources.get(key);\n\t\t\t\treturn source === undefined || source.v !== UNINITIALIZED;\n\t\t\t});\n\n\t\t\tfor (var [key, source] of sources) {\n\t\t\t\tif (source.v !== UNINITIALIZED && !(key in target)) {\n\t\t\t\t\town_keys.push(key);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn own_keys;\n\t\t},\n\n\t\tsetPrototypeOf() {\n\t\t\te.state_prototype_fixed();\n\t\t}\n\t});\n}\n\n/**\n * @param {Source<number>} signal\n * @param {1 | -1} [d]\n */\nfunction update_version(signal, d = 1) {\n\tset(signal, signal.v + d);\n}\n\n/**\n * @param {any} value\n */\nexport function get_proxied_value(value) {\n\tif (value !== null && typeof value === 'object' && STATE_SYMBOL in value) {\n\t\treturn value[STATE_SYMBOL];\n\t}\n\n\treturn value;\n}\n\n/**\n * @param {any} a\n * @param {any} b\n */\nexport function is(a, b) {\n\treturn Object.is(get_proxied_value(a), get_proxied_value(b));\n}\n","/** @import { TemplateNode } from '#client' */\nimport { hydrate_node, hydrating, set_hydrate_node } from './hydration.js';\nimport { DEV } from 'esm-env';\nimport { init_array_prototype_warnings } from '../dev/equality.js';\nimport { get_descriptor } from '../../shared/utils.js';\n\n// export these for reference in the compiled code, making global name deduplication unnecessary\n/** @type {Window} */\nexport var $window;\n\n/** @type {Document} */\nexport var $document;\n\n/** @type {() => Node | null} */\nvar first_child_getter;\n/** @type {() => Node | null} */\nvar next_sibling_getter;\n\n/**\n * Initialize these lazily to avoid issues when using the runtime in a server context\n * where these globals are not available while avoiding a separate server entry point\n */\nexport function init_operations() {\n\tif ($window !== undefined) {\n\t\treturn;\n\t}\n\n\t$window = window;\n\t$document = document;\n\n\tvar element_prototype = Element.prototype;\n\tvar node_prototype = Node.prototype;\n\n\t// @ts-ignore\n\tfirst_child_getter = get_descriptor(node_prototype, 'firstChild').get;\n\t// @ts-ignore\n\tnext_sibling_getter = get_descriptor(node_prototype, 'nextSibling').get;\n\n\t// the following assignments improve perf of lookups on DOM nodes\n\t// @ts-expect-error\n\telement_prototype.__click = undefined;\n\t// @ts-expect-error\n\telement_prototype.__className = '';\n\t// @ts-expect-error\n\telement_prototype.__attributes = null;\n\t// @ts-expect-error\n\telement_prototype.__styles = null;\n\t// @ts-expect-error\n\telement_prototype.__e = undefined;\n\n\t// @ts-expect-error\n\tText.prototype.__t = undefined;\n\n\tif (DEV) {\n\t\t// @ts-expect-error\n\t\telement_prototype.__svelte_meta = null;\n\n\t\tinit_array_prototype_warnings();\n\t}\n}\n\n/**\n * @param {string} value\n * @returns {Text}\n */\nexport function create_text(value = '') {\n\treturn document.createTextNode(value);\n}\n\n/**\n * @template {Node} N\n * @param {N} node\n * @returns {Node | null}\n */\n/*@__NO_SIDE_EFFECTS__*/\nexport function get_first_child(node) {\n\treturn first_child_getter.call(node);\n}\n\n/**\n * @template {Node} N\n * @param {N} node\n * @returns {Node | null}\n */\n/*@__NO_SIDE_EFFECTS__*/\nexport function get_next_sibling(node) {\n\treturn next_sibling_getter.call(node);\n}\n\n/**\n * Don't mark this as side-effect-free, hydration needs to walk all nodes\n * @template {Node} N\n * @param {N} node\n * @param {boolean} is_text\n * @returns {Node | null}\n */\nexport function child(node, is_text) {\n\tif (!hydrating) {\n\t\treturn get_first_child(node);\n\t}\n\n\tvar child = /** @type {TemplateNode} */ (get_first_child(hydrate_node));\n\n\t// Child can be null if we have an element with a single child, like `<p>{text}</p>`, where `text` is empty\n\tif (child === null) {\n\t\tchild = hydrate_node.appendChild(create_text());\n\t} else if (is_text && child.nodeType !== 3) {\n\t\tvar text = create_text();\n\t\tchild?.before(text);\n\t\tset_hydrate_node(text);\n\t\treturn text;\n\t}\n\n\tset_hydrate_node(child);\n\treturn child;\n}\n\n/**\n * Don't mark this as side-effect-free, hydration needs to walk all nodes\n * @param {DocumentFragment | TemplateNode[]} fragment\n * @param {boolean} is_text\n * @returns {Node | null}\n */\nexport function first_child(fragment, is_text) {\n\tif (!hydrating) {\n\t\t// when not hydrating, `fragment` is a `DocumentFragment` (the result of calling `open_frag`)\n\t\tvar first = /** @type {DocumentFragment} */ (get_first_child(/** @type {Node} */ (fragment)));\n\n\t\t// TODO prevent user comments with the empty string when preserveComments is true\n\t\tif (first instanceof Comment && first.data === '') return get_next_sibling(first);\n\n\t\treturn first;\n\t}\n\n\t// if an {expression} is empty during SSR, there might be no\n\t// text node to hydrate  we must therefore create one\n\tif (is_text && hydrate_node?.nodeType !== 3) {\n\t\tvar text = create_text();\n\n\t\thydrate_node?.before(text);\n\t\tset_hydrate_node(text);\n\t\treturn text;\n\t}\n\n\treturn hydrate_node;\n}\n\n/**\n * Don't mark this as side-effect-free, hydration needs to walk all nodes\n * @param {TemplateNode} node\n * @param {number} count\n * @param {boolean} is_text\n * @returns {Node | null}\n */\nexport function sibling(node, count = 1, is_text = false) {\n\tlet next_sibling = hydrating ? hydrate_node : node;\n\n\twhile (count--) {\n\t\tnext_sibling = /** @type {TemplateNode} */ (get_next_sibling(next_sibling));\n\t}\n\n\tif (!hydrating) {\n\t\treturn next_sibling;\n\t}\n\n\tvar type = next_sibling.nodeType;\n\n\t// if a sibling {expression} is empty during SSR, there might be no\n\t// text node to hydrate  we must therefore create one\n\tif (is_text && type !== 3) {\n\t\tvar text = create_text();\n\t\tnext_sibling?.before(text);\n\t\tset_hydrate_node(text);\n\t\treturn text;\n\t}\n\n\tset_hydrate_node(next_sibling);\n\treturn /** @type {TemplateNode} */ (next_sibling);\n}\n\n/**\n * @template {Node} N\n * @param {N} node\n * @returns {void}\n */\nexport function clear_text_content(node) {\n\tnode.textContent = '';\n}\n","/** @import { TemplateNode } from '#client' */\n\nimport {\n\tHYDRATION_END,\n\tHYDRATION_ERROR,\n\tHYDRATION_START,\n\tHYDRATION_START_ELSE\n} from '../../../constants.js';\nimport * as w from '../warnings.js';\nimport { get_next_sibling } from './operations.js';\n\n/**\n * Use this variable to guard everything related to hydration code so it can be treeshaken out\n * if the user doesn't use the `hydrate` method and these code paths are therefore not needed.\n */\nexport let hydrating = false;\n\n/** @param {boolean} value */\nexport function set_hydrating(value) {\n\thydrating = value;\n}\n\n/**\n * The node that is currently being hydrated. This starts out as the first node inside the opening\n * <!--[--> comment, and updates each time a component calls `$.child(...)` or `$.sibling(...)`.\n * When entering a block (e.g. `{#if ...}`), `hydrate_node` is the block opening comment; by the\n * time we leave the block it is the closing comment, which serves as the block's anchor.\n * @type {TemplateNode}\n */\nexport let hydrate_node;\n\n/** @param {TemplateNode} node */\nexport function set_hydrate_node(node) {\n\tif (node === null) {\n\t\tw.hydration_mismatch();\n\t\tthrow HYDRATION_ERROR;\n\t}\n\n\treturn (hydrate_node = node);\n}\n\nexport function hydrate_next() {\n\treturn set_hydrate_node(/** @type {TemplateNode} */ (get_next_sibling(hydrate_node)));\n}\n\n/** @param {TemplateNode} node */\nexport function reset(node) {\n\tif (!hydrating) return;\n\n\t// If the node has remaining siblings, something has gone wrong\n\tif (get_next_sibling(hydrate_node) !== null) {\n\t\tw.hydration_mismatch();\n\t\tthrow HYDRATION_ERROR;\n\t}\n\n\thydrate_node = node;\n}\n\n/**\n * @param {HTMLTemplateElement} template\n */\nexport function hydrate_template(template) {\n\tif (hydrating) {\n\t\t// @ts-expect-error TemplateNode doesn't include DocumentFragment, but it's actually fine\n\t\thydrate_node = template.content;\n\t}\n}\n\nexport function next(count = 1) {\n\tif (hydrating) {\n\t\tvar i = count;\n\t\tvar node = hydrate_node;\n\n\t\twhile (i--) {\n\t\t\tnode = /** @type {TemplateNode} */ (get_next_sibling(node));\n\t\t}\n\n\t\thydrate_node = node;\n\t}\n}\n\n/**\n * Removes all nodes starting at `hydrate_node` up until the next hydration end comment\n */\nexport function remove_nodes() {\n\tvar depth = 0;\n\tvar node = hydrate_node;\n\n\twhile (true) {\n\t\tif (node.nodeType === 8) {\n\t\t\tvar data = /** @type {Comment} */ (node).data;\n\n\t\t\tif (data === HYDRATION_END) {\n\t\t\t\tif (depth === 0) return node;\n\t\t\t\tdepth -= 1;\n\t\t\t} else if (data === HYDRATION_START || data === HYDRATION_START_ELSE) {\n\t\t\t\tdepth += 1;\n\t\t\t}\n\t\t}\n\n\t\tvar next = /** @type {TemplateNode} */ (get_next_sibling(node));\n\t\tnode.remove();\n\t\tnode = next;\n\t}\n}\n","/** @import { Location } from 'locate-character' */\nimport { teardown } from '../../reactivity/effects.js';\nimport { define_property, is_array } from '../../../shared/utils.js';\nimport { hydrating } from '../hydration.js';\nimport { queue_micro_task } from '../task.js';\nimport { FILENAME } from '../../../../constants.js';\nimport * as w from '../../warnings.js';\nimport {\n\tactive_effect,\n\tactive_reaction,\n\tset_active_effect,\n\tset_active_reaction\n} from '../../runtime.js';\n\n/** @type {Set<string>} */\nexport const all_registered_events = new Set();\n\n/** @type {Set<(events: Array<string>) => void>} */\nexport const root_event_handles = new Set();\n\n/**\n * SSR adds onload and onerror attributes to catch those events before the hydration.\n * This function detects those cases, removes the attributes and replays the events.\n * @param {HTMLElement} dom\n */\nexport function replay_events(dom) {\n\tif (!hydrating) return;\n\n\tif (dom.onload) {\n\t\tdom.removeAttribute('onload');\n\t}\n\tif (dom.onerror) {\n\t\tdom.removeAttribute('onerror');\n\t}\n\t// @ts-expect-error\n\tconst event = dom.__e;\n\tif (event !== undefined) {\n\t\t// @ts-expect-error\n\t\tdom.__e = undefined;\n\t\tqueueMicrotask(() => {\n\t\t\tif (dom.isConnected) {\n\t\t\t\tdom.dispatchEvent(event);\n\t\t\t}\n\t\t});\n\t}\n}\n\n/**\n * @param {string} event_name\n * @param {EventTarget} dom\n * @param {EventListener} handler\n * @param {AddEventListenerOptions} options\n */\nexport function create_event(event_name, dom, handler, options) {\n\t/**\n\t * @this {EventTarget}\n\t */\n\tfunction target_handler(/** @type {Event} */ event) {\n\t\tif (!options.capture) {\n\t\t\t// Only call in the bubble phase, else delegated events would be called before the capturing events\n\t\t\thandle_event_propagation.call(dom, event);\n\t\t}\n\t\tif (!event.cancelBubble) {\n\t\t\tvar previous_reaction = active_reaction;\n\t\t\tvar previous_effect = active_effect;\n\n\t\t\tset_active_reaction(null);\n\t\t\tset_active_effect(null);\n\t\t\ttry {\n\t\t\t\treturn handler.call(this, event);\n\t\t\t} finally {\n\t\t\t\tset_active_reaction(previous_reaction);\n\t\t\t\tset_active_effect(previous_effect);\n\t\t\t}\n\t\t}\n\t}\n\n\t// Chrome has a bug where pointer events don't work when attached to a DOM element that has been cloned\n\t// with cloneNode() and the DOM element is disconnected from the document. To ensure the event works, we\n\t// defer the attachment till after it's been appended to the document. TODO: remove this once Chrome fixes\n\t// this bug. The same applies to wheel events and touch events.\n\tif (\n\t\tevent_name.startsWith('pointer') ||\n\t\tevent_name.startsWith('touch') ||\n\t\tevent_name === 'wheel'\n\t) {\n\t\tqueue_micro_task(() => {\n\t\t\tdom.addEventListener(event_name, target_handler, options);\n\t\t});\n\t} else {\n\t\tdom.addEventListener(event_name, target_handler, options);\n\t}\n\n\treturn target_handler;\n}\n\n/**\n * Attaches an event handler to an element and returns a function that removes the handler. Using this\n * rather than `addEventListener` will preserve the correct order relative to handlers added declaratively\n * (with attributes like `onclick`), which use event delegation for performance reasons\n *\n * @param {EventTarget} element\n * @param {string} type\n * @param {EventListener} handler\n * @param {AddEventListenerOptions} [options]\n */\nexport function on(element, type, handler, options = {}) {\n\tvar target_handler = create_event(type, element, handler, options);\n\n\treturn () => {\n\t\telement.removeEventListener(type, target_handler, options);\n\t};\n}\n\n/**\n * @param {string} event_name\n * @param {Element} dom\n * @param {EventListener} handler\n * @param {boolean} capture\n * @param {boolean} [passive]\n * @returns {void}\n */\nexport function event(event_name, dom, handler, capture, passive) {\n\tvar options = { capture, passive };\n\tvar target_handler = create_event(event_name, dom, handler, options);\n\n\t// @ts-ignore\n\tif (dom === document.body || dom === window || dom === document) {\n\t\tteardown(() => {\n\t\t\tdom.removeEventListener(event_name, target_handler, options);\n\t\t});\n\t}\n}\n\n/**\n * @param {Array<string>} events\n * @returns {void}\n */\nexport function delegate(events) {\n\tfor (var i = 0; i < events.length; i++) {\n\t\tall_registered_events.add(events[i]);\n\t}\n\n\tfor (var fn of root_event_handles) {\n\t\tfn(events);\n\t}\n}\n\n/**\n * @this {EventTarget}\n * @param {Event} event\n * @returns {void}\n */\nexport function handle_event_propagation(event) {\n\tvar handler_element = this;\n\tvar owner_document = /** @type {Node} */ (handler_element).ownerDocument;\n\tvar event_name = event.type;\n\tvar path = event.composedPath?.() || [];\n\tvar current_target = /** @type {null | Element} */ (path[0] || event.target);\n\n\t// composedPath contains list of nodes the event has propagated through.\n\t// We check __root to skip all nodes below it in case this is a\n\t// parent of the __root node, which indicates that there's nested\n\t// mounted apps. In this case we don't want to trigger events multiple times.\n\tvar path_idx = 0;\n\n\t// @ts-expect-error is added below\n\tvar handled_at = event.__root;\n\n\tif (handled_at) {\n\t\tvar at_idx = path.indexOf(handled_at);\n\t\tif (\n\t\t\tat_idx !== -1 &&\n\t\t\t(handler_element === document || handler_element === /** @type {any} */ (window))\n\t\t) {\n\t\t\t// This is the fallback document listener or a window listener, but the event was already handled\n\t\t\t// -> ignore, but set handle_at to document/window so that we're resetting the event\n\t\t\t// chain in case someone manually dispatches the same event object again.\n\t\t\t// @ts-expect-error\n\t\t\tevent.__root = handler_element;\n\t\t\treturn;\n\t\t}\n\n\t\t// We're deliberately not skipping if the index is higher, because\n\t\t// someone could create an event programmatically and emit it multiple times,\n\t\t// in which case we want to handle the whole propagation chain properly each time.\n\t\t// (this will only be a false negative if the event is dispatched multiple times and\n\t\t// the fallback document listener isn't reached in between, but that's super rare)\n\t\tvar handler_idx = path.indexOf(handler_element);\n\t\tif (handler_idx === -1) {\n\t\t\t// handle_idx can theoretically be -1 (happened in some JSDOM testing scenarios with an event listener on the window object)\n\t\t\t// so guard against that, too, and assume that everything was handled at this point.\n\t\t\treturn;\n\t\t}\n\n\t\tif (at_idx <= handler_idx) {\n\t\t\tpath_idx = at_idx;\n\t\t}\n\t}\n\n\tcurrent_target = /** @type {Element} */ (path[path_idx] || event.target);\n\t// there can only be one delegated event per element, and we either already handled the current target,\n\t// or this is the very first target in the chain which has a non-delegated listener, in which case it's safe\n\t// to handle a possible delegated event on it later (through the root delegation listener for example).\n\tif (current_target === handler_element) return;\n\n\t// Proxy currentTarget to correct target\n\tdefine_property(event, 'currentTarget', {\n\t\tconfigurable: true,\n\t\tget() {\n\t\t\treturn current_target || owner_document;\n\t\t}\n\t});\n\n\t// This started because of Chromium issue https://chromestatus.com/feature/5128696823545856,\n\t// where removal or moving of of the DOM can cause sync `blur` events to fire, which can cause logic\n\t// to run inside the current `active_reaction`, which isn't what we want at all. However, on reflection,\n\t// it's probably best that all event handled by Svelte have this behaviour, as we don't really want\n\t// an event handler to run in the context of another reaction or effect.\n\tvar previous_reaction = active_reaction;\n\tvar previous_effect = active_effect;\n\tset_active_reaction(null);\n\tset_active_effect(null);\n\n\ttry {\n\t\t/**\n\t\t * @type {unknown}\n\t\t */\n\t\tvar throw_error;\n\t\t/**\n\t\t * @type {unknown[]}\n\t\t */\n\t\tvar other_errors = [];\n\n\t\twhile (current_target !== null) {\n\t\t\t/** @type {null | Element} */\n\t\t\tvar parent_element =\n\t\t\t\tcurrent_target.assignedSlot ||\n\t\t\t\tcurrent_target.parentNode ||\n\t\t\t\t/** @type {any} */ (current_target).host ||\n\t\t\t\tnull;\n\n\t\t\ttry {\n\t\t\t\t// @ts-expect-error\n\t\t\t\tvar delegated = current_target['__' + event_name];\n\n\t\t\t\tif (delegated !== undefined && !(/** @type {any} */ (current_target).disabled)) {\n\t\t\t\t\tif (is_array(delegated)) {\n\t\t\t\t\t\tvar [fn, ...data] = delegated;\n\t\t\t\t\t\tfn.apply(current_target, [event, ...data]);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdelegated.call(current_target, event);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} catch (error) {\n\t\t\t\tif (throw_error) {\n\t\t\t\t\tother_errors.push(error);\n\t\t\t\t} else {\n\t\t\t\t\tthrow_error = error;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (event.cancelBubble || parent_element === handler_element || parent_element === null) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcurrent_target = parent_element;\n\t\t}\n\n\t\tif (throw_error) {\n\t\t\tfor (let error of other_errors) {\n\t\t\t\t// Throw the rest of the errors, one-by-one on a microtask\n\t\t\t\tqueueMicrotask(() => {\n\t\t\t\t\tthrow error;\n\t\t\t\t});\n\t\t\t}\n\t\t\tthrow throw_error;\n\t\t}\n\t} finally {\n\t\t// @ts-expect-error is used above\n\t\tevent.__root = handler_element;\n\t\t// @ts-ignore remove proxy on currentTarget\n\t\tdelete event.currentTarget;\n\t\tset_active_reaction(previous_reaction);\n\t\tset_active_effect(previous_effect);\n\t}\n}\n\n/**\n * In dev, warn if an event handler is not a function, as it means the\n * user probably called the handler or forgot to add a `() =>`\n * @param {() => (event: Event, ...args: any) => void} thunk\n * @param {EventTarget} element\n * @param {[Event, ...any]} args\n * @param {any} component\n * @param {[number, number]} [loc]\n * @param {boolean} [remove_parens]\n */\nexport function apply(\n\tthunk,\n\telement,\n\targs,\n\tcomponent,\n\tloc,\n\thas_side_effects = false,\n\tremove_parens = false\n) {\n\tlet handler;\n\tlet error;\n\n\ttry {\n\t\thandler = thunk();\n\t} catch (e) {\n\t\terror = e;\n\t}\n\n\tif (typeof handler === 'function') {\n\t\thandler.apply(element, args);\n\t} else if (has_side_effects || handler != null || error) {\n\t\tconst filename = component?.[FILENAME];\n\t\tconst location = loc ? ` at ${filename}:${loc[0]}:${loc[1]}` : ` in ${filename}`;\n\n\t\tconst event_name = args[0].type;\n\t\tconst description = `\\`${event_name}\\` handler${location}`;\n\t\tconst suggestion = remove_parens ? 'remove the trailing `()`' : 'add a leading `() =>`';\n\n\t\tw.event_handler_invalid(description, suggestion);\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\t}\n}\n","/** @param {string} html */\nexport function create_fragment_from_html(html) {\n\tvar elem = document.createElement('template');\n\telem.innerHTML = html;\n\treturn elem.content;\n}\n","/** @import { Effect, TemplateNode } from '#client' */\nimport { hydrate_next, hydrate_node, hydrating, set_hydrate_node } from './hydration.js';\nimport { create_text, get_first_child } from './operations.js';\nimport { create_fragment_from_html } from './reconciler.js';\nimport { active_effect } from '../runtime.js';\nimport { TEMPLATE_FRAGMENT, TEMPLATE_USE_IMPORT_NODE } from '../../../constants.js';\nimport { queue_micro_task } from './task.js';\n\n/**\n * @param {TemplateNode} start\n * @param {TemplateNode | null} end\n */\nexport function assign_nodes(start, end) {\n\tvar effect = /** @type {Effect} */ (active_effect);\n\tif (effect.nodes_start === null) {\n\t\teffect.nodes_start = start;\n\t\teffect.nodes_end = end;\n\t}\n}\n\n/**\n * @param {string} content\n * @param {number} flags\n * @returns {() => Node | Node[]}\n */\n/*#__NO_SIDE_EFFECTS__*/\nexport function template(content, flags) {\n\tvar is_fragment = (flags & TEMPLATE_FRAGMENT) !== 0;\n\tvar use_import_node = (flags & TEMPLATE_USE_IMPORT_NODE) !== 0;\n\n\t/** @type {Node} */\n\tvar node;\n\n\t/**\n\t * Whether or not the first item is a text/element node. If not, we need to\n\t * create an additional comment node to act as `effect.nodes.start`\n\t */\n\tvar has_start = !content.startsWith('<!>');\n\n\treturn () => {\n\t\tif (hydrating) {\n\t\t\tassign_nodes(hydrate_node, null);\n\t\t\treturn hydrate_node;\n\t\t}\n\n\t\tif (node === undefined) {\n\t\t\tnode = create_fragment_from_html(has_start ? content : '<!>' + content);\n\t\t\tif (!is_fragment) node = /** @type {Node} */ (get_first_child(node));\n\t\t}\n\n\t\tvar clone = /** @type {TemplateNode} */ (\n\t\t\tuse_import_node ? document.importNode(node, true) : node.cloneNode(true)\n\t\t);\n\n\t\tif (is_fragment) {\n\t\t\tvar start = /** @type {TemplateNode} */ (get_first_child(clone));\n\t\t\tvar end = /** @type {TemplateNode} */ (clone.lastChild);\n\n\t\t\tassign_nodes(start, end);\n\t\t} else {\n\t\t\tassign_nodes(clone, clone);\n\t\t}\n\n\t\treturn clone;\n\t};\n}\n\n/**\n * @param {string} content\n * @param {number} flags\n * @returns {() => Node | Node[]}\n */\n/*#__NO_SIDE_EFFECTS__*/\nexport function template_with_script(content, flags) {\n\tvar fn = template(content, flags);\n\treturn () => run_scripts(/** @type {Element | DocumentFragment} */ (fn()));\n}\n\n/**\n * @param {string} content\n * @param {number} flags\n * @param {'svg' | 'math'} ns\n * @returns {() => Node | Node[]}\n */\n/*#__NO_SIDE_EFFECTS__*/\nexport function ns_template(content, flags, ns = 'svg') {\n\t/**\n\t * Whether or not the first item is a text/element node. If not, we need to\n\t * create an additional comment node to act as `effect.nodes.start`\n\t */\n\tvar has_start = !content.startsWith('<!>');\n\n\tvar is_fragment = (flags & TEMPLATE_FRAGMENT) !== 0;\n\tvar wrapped = `<${ns}>${has_start ? content : '<!>' + content}</${ns}>`;\n\n\t/** @type {Element | DocumentFragment} */\n\tvar node;\n\n\treturn () => {\n\t\tif (hydrating) {\n\t\t\tassign_nodes(hydrate_node, null);\n\t\t\treturn hydrate_node;\n\t\t}\n\n\t\tif (!node) {\n\t\t\tvar fragment = /** @type {DocumentFragment} */ (create_fragment_from_html(wrapped));\n\t\t\tvar root = /** @type {Element} */ (get_first_child(fragment));\n\n\t\t\tif (is_fragment) {\n\t\t\t\tnode = document.createDocumentFragment();\n\t\t\t\twhile (get_first_child(root)) {\n\t\t\t\t\tnode.appendChild(/** @type {Node} */ (get_first_child(root)));\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tnode = /** @type {Element} */ (get_first_child(root));\n\t\t\t}\n\t\t}\n\n\t\tvar clone = /** @type {TemplateNode} */ (node.cloneNode(true));\n\n\t\tif (is_fragment) {\n\t\t\tvar start = /** @type {TemplateNode} */ (get_first_child(clone));\n\t\t\tvar end = /** @type {TemplateNode} */ (clone.lastChild);\n\n\t\t\tassign_nodes(start, end);\n\t\t} else {\n\t\t\tassign_nodes(clone, clone);\n\t\t}\n\n\t\treturn clone;\n\t};\n}\n\n/**\n * @param {string} content\n * @param {number} flags\n * @returns {() => Node | Node[]}\n */\n/*#__NO_SIDE_EFFECTS__*/\nexport function svg_template_with_script(content, flags) {\n\tvar fn = ns_template(content, flags);\n\treturn () => run_scripts(/** @type {Element | DocumentFragment} */ (fn()));\n}\n\n/**\n * @param {string} content\n * @param {number} flags\n * @returns {() => Node | Node[]}\n */\n/*#__NO_SIDE_EFFECTS__*/\nexport function mathml_template(content, flags) {\n\treturn ns_template(content, flags, 'math');\n}\n\n/**\n * Creating a document fragment from HTML that contains script tags will not execute\n * the scripts. We need to replace the script tags with new ones so that they are executed.\n * @param {Element | DocumentFragment} node\n * @returns {Node | Node[]}\n */\nfunction run_scripts(node) {\n\t// scripts were SSR'd, in which case they will run\n\tif (hydrating) return node;\n\n\tconst is_fragment = node.nodeType === 11;\n\tconst scripts =\n\t\t/** @type {HTMLElement} */ (node).tagName === 'SCRIPT'\n\t\t\t? [/** @type {HTMLScriptElement} */ (node)]\n\t\t\t: node.querySelectorAll('script');\n\tconst effect = /** @type {Effect} */ (active_effect);\n\n\tfor (const script of scripts) {\n\t\tconst clone = document.createElement('script');\n\t\tfor (var attribute of script.attributes) {\n\t\t\tclone.setAttribute(attribute.name, attribute.value);\n\t\t}\n\n\t\tclone.textContent = script.textContent;\n\n\t\t// The script has changed - if it's at the edges, the effect now points at dead nodes\n\t\tif (is_fragment ? node.firstChild === script : node === script) {\n\t\t\teffect.nodes_start = clone;\n\t\t}\n\t\tif (is_fragment ? node.lastChild === script : node === script) {\n\t\t\teffect.nodes_end = clone;\n\t\t}\n\n\t\tscript.replaceWith(clone);\n\t}\n\treturn node;\n}\n\n/**\n * Don't mark this as side-effect-free, hydration needs to walk all nodes\n * @param {any} value\n */\nexport function text(value = '') {\n\tif (!hydrating) {\n\t\tvar t = create_text(value + '');\n\t\tassign_nodes(t, t);\n\t\treturn t;\n\t}\n\n\tvar node = hydrate_node;\n\n\tif (node.nodeType !== 3) {\n\t\t// if an {expression} is empty during SSR, we need to insert an empty text node\n\t\tnode.before((node = create_text()));\n\t\tset_hydrate_node(node);\n\t}\n\n\tassign_nodes(node, node);\n\treturn node;\n}\n\nexport function comment() {\n\t// we're not delegating to `template` here for performance reasons\n\tif (hydrating) {\n\t\tassign_nodes(hydrate_node, null);\n\t\treturn hydrate_node;\n\t}\n\n\tvar frag = document.createDocumentFragment();\n\tvar start = document.createComment('');\n\tvar anchor = create_text();\n\tfrag.append(start, anchor);\n\n\tassign_nodes(start, anchor);\n\n\treturn frag;\n}\n\n/**\n * Assign the created (or in hydration mode, traversed) dom elements to the current block\n * and insert the elements into the dom (in client mode).\n * @param {Text | Comment | Element} anchor\n * @param {DocumentFragment | Element} dom\n */\nexport function append(anchor, dom) {\n\tif (hydrating) {\n\t\t/** @type {Effect} */ (active_effect).nodes_end = hydrate_node;\n\t\thydrate_next();\n\t\treturn;\n\t}\n\n\tif (anchor === null) {\n\t\t// edge case  void `<svelte:element>` with content\n\t\treturn;\n\t}\n\n\tanchor.before(/** @type {Node} */ (dom));\n}\n","const regex_return_characters = /\\r/g;\n\n/**\n * @param {string} str\n * @returns {string}\n */\nexport function hash(str) {\n\tstr = str.replace(regex_return_characters, '');\n\tlet hash = 5381;\n\tlet i = str.length;\n\n\twhile (i--) hash = ((hash << 5) - hash) ^ str.charCodeAt(i);\n\treturn (hash >>> 0).toString(36);\n}\n\nconst VOID_ELEMENT_NAMES = [\n\t'area',\n\t'base',\n\t'br',\n\t'col',\n\t'command',\n\t'embed',\n\t'hr',\n\t'img',\n\t'input',\n\t'keygen',\n\t'link',\n\t'meta',\n\t'param',\n\t'source',\n\t'track',\n\t'wbr'\n];\n\n/**\n * Returns `true` if `name` is of a void element\n * @param {string} name\n */\nexport function is_void(name) {\n\treturn VOID_ELEMENT_NAMES.includes(name) || name.toLowerCase() === '!doctype';\n}\n\nconst RESERVED_WORDS = [\n\t'arguments',\n\t'await',\n\t'break',\n\t'case',\n\t'catch',\n\t'class',\n\t'const',\n\t'continue',\n\t'debugger',\n\t'default',\n\t'delete',\n\t'do',\n\t'else',\n\t'enum',\n\t'eval',\n\t'export',\n\t'extends',\n\t'false',\n\t'finally',\n\t'for',\n\t'function',\n\t'if',\n\t'implements',\n\t'import',\n\t'in',\n\t'instanceof',\n\t'interface',\n\t'let',\n\t'new',\n\t'null',\n\t'package',\n\t'private',\n\t'protected',\n\t'public',\n\t'return',\n\t'static',\n\t'super',\n\t'switch',\n\t'this',\n\t'throw',\n\t'true',\n\t'try',\n\t'typeof',\n\t'var',\n\t'void',\n\t'while',\n\t'with',\n\t'yield'\n];\n\n/**\n * Returns `true` if `word` is a reserved JavaScript keyword\n * @param {string} word\n */\nexport function is_reserved(word) {\n\treturn RESERVED_WORDS.includes(word);\n}\n\n/**\n * @param {string} name\n */\nexport function is_capture_event(name) {\n\treturn name.endsWith('capture') && name !== 'gotpointercapture' && name !== 'lostpointercapture';\n}\n\n/** List of Element events that will be delegated */\nconst DELEGATED_EVENTS = [\n\t'beforeinput',\n\t'click',\n\t'change',\n\t'dblclick',\n\t'contextmenu',\n\t'focusin',\n\t'focusout',\n\t'input',\n\t'keydown',\n\t'keyup',\n\t'mousedown',\n\t'mousemove',\n\t'mouseout',\n\t'mouseover',\n\t'mouseup',\n\t'pointerdown',\n\t'pointermove',\n\t'pointerout',\n\t'pointerover',\n\t'pointerup',\n\t'touchend',\n\t'touchmove',\n\t'touchstart'\n];\n\n/**\n * Returns `true` if `event_name` is a delegated event\n * @param {string} event_name\n */\nexport function is_delegated(event_name) {\n\treturn DELEGATED_EVENTS.includes(event_name);\n}\n\n/**\n * Attributes that are boolean, i.e. they are present or not present.\n */\nconst DOM_BOOLEAN_ATTRIBUTES = [\n\t'allowfullscreen',\n\t'async',\n\t'autofocus',\n\t'autoplay',\n\t'checked',\n\t'controls',\n\t'default',\n\t'disabled',\n\t'formnovalidate',\n\t'hidden',\n\t'indeterminate',\n\t'ismap',\n\t'loop',\n\t'multiple',\n\t'muted',\n\t'nomodule',\n\t'novalidate',\n\t'open',\n\t'playsinline',\n\t'readonly',\n\t'required',\n\t'reversed',\n\t'seamless',\n\t'selected',\n\t'webkitdirectory'\n];\n\n/**\n * Returns `true` if `name` is a boolean attribute\n * @param {string} name\n */\nexport function is_boolean_attribute(name) {\n\treturn DOM_BOOLEAN_ATTRIBUTES.includes(name);\n}\n\n/**\n * @type {Record<string, string>}\n * List of attribute names that should be aliased to their property names\n * because they behave differently between setting them as an attribute and\n * setting them as a property.\n */\nconst ATTRIBUTE_ALIASES = {\n\t// no `class: 'className'` because we handle that separately\n\tformnovalidate: 'formNoValidate',\n\tismap: 'isMap',\n\tnomodule: 'noModule',\n\tplaysinline: 'playsInline',\n\treadonly: 'readOnly'\n};\n\n/**\n * @param {string} name\n */\nexport function normalize_attribute(name) {\n\tname = name.toLowerCase();\n\treturn ATTRIBUTE_ALIASES[name] ?? name;\n}\n\nconst DOM_PROPERTIES = [\n\t...DOM_BOOLEAN_ATTRIBUTES,\n\t'formNoValidate',\n\t'isMap',\n\t'noModule',\n\t'playsInline',\n\t'readOnly',\n\t'value',\n\t'inert',\n\t'volume'\n];\n\n/**\n * @param {string} name\n */\nexport function is_dom_property(name) {\n\treturn DOM_PROPERTIES.includes(name);\n}\n\n/**\n * Subset of delegated events which should be passive by default.\n * These two are already passive via browser defaults on window, document and body.\n * But since\n * - we're delegating them\n * - they happen often\n * - they apply to mobile which is generally less performant\n * we're marking them as passive by default for other elements, too.\n */\nconst PASSIVE_EVENTS = ['touchstart', 'touchmove'];\n\n/**\n * Returns `true` if `name` is a passive event\n * @param {string} name\n */\nexport function is_passive_event(name) {\n\treturn PASSIVE_EVENTS.includes(name);\n}\n\nconst CONTENT_EDITABLE_BINDINGS = ['textContent', 'innerHTML', 'innerText'];\n\n/** @param {string} name */\nexport function is_content_editable_binding(name) {\n\treturn CONTENT_EDITABLE_BINDINGS.includes(name);\n}\n\nconst LOAD_ERROR_ELEMENTS = [\n\t'body',\n\t'embed',\n\t'iframe',\n\t'img',\n\t'link',\n\t'object',\n\t'script',\n\t'style',\n\t'track'\n];\n\n/**\n * Returns `true` if the element emits `load` and `error` events\n * @param {string} name\n */\nexport function is_load_error_element(name) {\n\treturn LOAD_ERROR_ELEMENTS.includes(name);\n}\n\nconst SVG_ELEMENTS = [\n\t'altGlyph',\n\t'altGlyphDef',\n\t'altGlyphItem',\n\t'animate',\n\t'animateColor',\n\t'animateMotion',\n\t'animateTransform',\n\t'circle',\n\t'clipPath',\n\t'color-profile',\n\t'cursor',\n\t'defs',\n\t'desc',\n\t'discard',\n\t'ellipse',\n\t'feBlend',\n\t'feColorMatrix',\n\t'feComponentTransfer',\n\t'feComposite',\n\t'feConvolveMatrix',\n\t'feDiffuseLighting',\n\t'feDisplacementMap',\n\t'feDistantLight',\n\t'feDropShadow',\n\t'feFlood',\n\t'feFuncA',\n\t'feFuncB',\n\t'feFuncG',\n\t'feFuncR',\n\t'feGaussianBlur',\n\t'feImage',\n\t'feMerge',\n\t'feMergeNode',\n\t'feMorphology',\n\t'feOffset',\n\t'fePointLight',\n\t'feSpecularLighting',\n\t'feSpotLight',\n\t'feTile',\n\t'feTurbulence',\n\t'filter',\n\t'font',\n\t'font-face',\n\t'font-face-format',\n\t'font-face-name',\n\t'font-face-src',\n\t'font-face-uri',\n\t'foreignObject',\n\t'g',\n\t'glyph',\n\t'glyphRef',\n\t'hatch',\n\t'hatchpath',\n\t'hkern',\n\t'image',\n\t'line',\n\t'linearGradient',\n\t'marker',\n\t'mask',\n\t'mesh',\n\t'meshgradient',\n\t'meshpatch',\n\t'meshrow',\n\t'metadata',\n\t'missing-glyph',\n\t'mpath',\n\t'path',\n\t'pattern',\n\t'polygon',\n\t'polyline',\n\t'radialGradient',\n\t'rect',\n\t'set',\n\t'solidcolor',\n\t'stop',\n\t'svg',\n\t'switch',\n\t'symbol',\n\t'text',\n\t'textPath',\n\t'tref',\n\t'tspan',\n\t'unknown',\n\t'use',\n\t'view',\n\t'vkern'\n];\n\n/** @param {string} name */\nexport function is_svg(name) {\n\treturn SVG_ELEMENTS.includes(name);\n}\n\nconst MATHML_ELEMENTS = [\n\t'annotation',\n\t'annotation-xml',\n\t'maction',\n\t'math',\n\t'merror',\n\t'mfrac',\n\t'mi',\n\t'mmultiscripts',\n\t'mn',\n\t'mo',\n\t'mover',\n\t'mpadded',\n\t'mphantom',\n\t'mprescripts',\n\t'mroot',\n\t'mrow',\n\t'ms',\n\t'mspace',\n\t'msqrt',\n\t'mstyle',\n\t'msub',\n\t'msubsup',\n\t'msup',\n\t'mtable',\n\t'mtd',\n\t'mtext',\n\t'mtr',\n\t'munder',\n\t'munderover',\n\t'semantics'\n];\n\n/** @param {string} name */\nexport function is_mathml(name) {\n\treturn MATHML_ELEMENTS.includes(name);\n}\n\nconst RUNES = /** @type {const} */ ([\n\t'$state',\n\t'$state.raw',\n\t'$state.snapshot',\n\t'$props',\n\t'$bindable',\n\t'$derived',\n\t'$derived.by',\n\t'$effect',\n\t'$effect.pre',\n\t'$effect.tracking',\n\t'$effect.root',\n\t'$inspect',\n\t'$inspect().with',\n\t'$host'\n]);\n\n/**\n * @param {string} name\n * @returns {name is RUNES[number]}\n */\nexport function is_rune(name) {\n\treturn RUNES.includes(/** @type {RUNES[number]} */ (name));\n}\n","/** @import { ComponentContext, Effect, TemplateNode } from '#client' */\n/** @import { Component, ComponentType, SvelteComponent, MountOptions } from '../../index.js' */\nimport { DEV } from 'esm-env';\nimport {\n\tclear_text_content,\n\tcreate_text,\n\tget_first_child,\n\tget_next_sibling,\n\tinit_operations\n} from './dom/operations.js';\nimport { HYDRATION_END, HYDRATION_ERROR, HYDRATION_START } from '../../constants.js';\nimport { push, pop, component_context, active_effect } from './runtime.js';\nimport { effect_root, branch } from './reactivity/effects.js';\nimport {\n\thydrate_next,\n\thydrate_node,\n\thydrating,\n\tset_hydrate_node,\n\tset_hydrating\n} from './dom/hydration.js';\nimport { array_from } from '../shared/utils.js';\nimport {\n\tall_registered_events,\n\thandle_event_propagation,\n\troot_event_handles\n} from './dom/elements/events.js';\nimport { reset_head_anchor } from './dom/blocks/svelte-head.js';\nimport * as w from './warnings.js';\nimport * as e from './errors.js';\nimport { assign_nodes } from './dom/template.js';\nimport { is_passive_event } from '../../utils.js';\n\n/**\n * This is normally true  block effects should run their intro transitions \n * but is false during hydration (unless `options.intro` is `true`) and\n * when creating the children of a `<svelte:element>` that just changed tag\n */\nexport let should_intro = true;\n\n/** @param {boolean} value */\nexport function set_should_intro(value) {\n\tshould_intro = value;\n}\n\n/**\n * @param {Element} text\n * @param {string} value\n * @returns {void}\n */\nexport function set_text(text, value) {\n\t// For objects, we apply string coercion (which might make things like $state array references in the template reactive) before diffing\n\tvar str = value == null ? '' : typeof value === 'object' ? value + '' : value;\n\t// @ts-expect-error\n\tif (str !== (text.__t ??= text.nodeValue)) {\n\t\t// @ts-expect-error\n\t\ttext.__t = str;\n\t\ttext.nodeValue = str == null ? '' : str + '';\n\t}\n}\n\n/**\n * Mounts a component to the given target and returns the exports and potentially the props (if compiled with `accessors: true`) of the component.\n * Transitions will play during the initial render unless the `intro` option is set to `false`.\n *\n * @template {Record<string, any>} Props\n * @template {Record<string, any>} Exports\n * @param {ComponentType<SvelteComponent<Props>> | Component<Props, Exports, any>} component\n * @param {MountOptions<Props>} options\n * @returns {Exports}\n */\nexport function mount(component, options) {\n\treturn _mount(component, options);\n}\n\n/**\n * Hydrates a component on the given target and returns the exports and potentially the props (if compiled with `accessors: true`) of the component\n *\n * @template {Record<string, any>} Props\n * @template {Record<string, any>} Exports\n * @param {ComponentType<SvelteComponent<Props>> | Component<Props, Exports, any>} component\n * @param {{} extends Props ? {\n * \t\ttarget: Document | Element | ShadowRoot;\n * \t\tprops?: Props;\n * \t\tevents?: Record<string, (e: any) => any>;\n *  \tcontext?: Map<any, any>;\n * \t\tintro?: boolean;\n * \t\trecover?: boolean;\n * \t} : {\n * \t\ttarget: Document | Element | ShadowRoot;\n * \t\tprops: Props;\n * \t\tevents?: Record<string, (e: any) => any>;\n *  \tcontext?: Map<any, any>;\n * \t\tintro?: boolean;\n * \t\trecover?: boolean;\n * \t}} options\n * @returns {Exports}\n */\nexport function hydrate(component, options) {\n\tinit_operations();\n\toptions.intro = options.intro ?? false;\n\tconst target = options.target;\n\tconst was_hydrating = hydrating;\n\tconst previous_hydrate_node = hydrate_node;\n\n\ttry {\n\t\tvar anchor = /** @type {TemplateNode} */ (get_first_child(target));\n\t\twhile (\n\t\t\tanchor &&\n\t\t\t(anchor.nodeType !== 8 || /** @type {Comment} */ (anchor).data !== HYDRATION_START)\n\t\t) {\n\t\t\tanchor = /** @type {TemplateNode} */ (get_next_sibling(anchor));\n\t\t}\n\n\t\tif (!anchor) {\n\t\t\tthrow HYDRATION_ERROR;\n\t\t}\n\n\t\tset_hydrating(true);\n\t\tset_hydrate_node(/** @type {Comment} */ (anchor));\n\t\thydrate_next();\n\n\t\tconst instance = _mount(component, { ...options, anchor });\n\n\t\tif (\n\t\t\thydrate_node === null ||\n\t\t\thydrate_node.nodeType !== 8 ||\n\t\t\t/** @type {Comment} */ (hydrate_node).data !== HYDRATION_END\n\t\t) {\n\t\t\tw.hydration_mismatch();\n\t\t\tthrow HYDRATION_ERROR;\n\t\t}\n\n\t\tset_hydrating(false);\n\n\t\treturn /**  @type {Exports} */ (instance);\n\t} catch (error) {\n\t\tif (error === HYDRATION_ERROR) {\n\t\t\tif (options.recover === false) {\n\t\t\t\te.hydration_failed();\n\t\t\t}\n\n\t\t\t// If an error occured above, the operations might not yet have been initialised.\n\t\t\tinit_operations();\n\t\t\tclear_text_content(target);\n\n\t\t\tset_hydrating(false);\n\t\t\treturn mount(component, options);\n\t\t}\n\n\t\tthrow error;\n\t} finally {\n\t\tset_hydrating(was_hydrating);\n\t\tset_hydrate_node(previous_hydrate_node);\n\t\treset_head_anchor();\n\t}\n}\n\n/** @type {Map<string, number>} */\nconst document_listeners = new Map();\n\n/**\n * @template {Record<string, any>} Exports\n * @param {ComponentType<SvelteComponent<any>> | Component<any>} Component\n * @param {MountOptions} options\n * @returns {Exports}\n */\nfunction _mount(Component, { target, anchor, props = {}, events, context, intro = true }) {\n\tinit_operations();\n\n\tvar registered_events = new Set();\n\n\t/** @param {Array<string>} events */\n\tvar event_handle = (events) => {\n\t\tfor (var i = 0; i < events.length; i++) {\n\t\t\tvar event_name = events[i];\n\n\t\t\tif (registered_events.has(event_name)) continue;\n\t\t\tregistered_events.add(event_name);\n\n\t\t\tvar passive = is_passive_event(event_name);\n\n\t\t\t// Add the event listener to both the container and the document.\n\t\t\t// The container listener ensures we catch events from within in case\n\t\t\t// the outer content stops propagation of the event.\n\t\t\ttarget.addEventListener(event_name, handle_event_propagation, { passive });\n\n\t\t\tvar n = document_listeners.get(event_name);\n\n\t\t\tif (n === undefined) {\n\t\t\t\t// The document listener ensures we catch events that originate from elements that were\n\t\t\t\t// manually moved outside of the container (e.g. via manual portals).\n\t\t\t\tdocument.addEventListener(event_name, handle_event_propagation, { passive });\n\t\t\t\tdocument_listeners.set(event_name, 1);\n\t\t\t} else {\n\t\t\t\tdocument_listeners.set(event_name, n + 1);\n\t\t\t}\n\t\t}\n\t};\n\n\tevent_handle(array_from(all_registered_events));\n\troot_event_handles.add(event_handle);\n\n\t/** @type {Exports} */\n\t// @ts-expect-error will be defined because the render effect runs synchronously\n\tvar component = undefined;\n\n\tvar unmount = effect_root(() => {\n\t\tvar anchor_node = anchor ?? target.appendChild(create_text());\n\n\t\tbranch(() => {\n\t\t\tif (context) {\n\t\t\t\tpush({});\n\t\t\t\tvar ctx = /** @type {ComponentContext} */ (component_context);\n\t\t\t\tctx.c = context;\n\t\t\t}\n\n\t\t\tif (events) {\n\t\t\t\t// We can't spread the object or else we'd lose the state proxy stuff, if it is one\n\t\t\t\t/** @type {any} */ (props).$$events = events;\n\t\t\t}\n\n\t\t\tif (hydrating) {\n\t\t\t\tassign_nodes(/** @type {TemplateNode} */ (anchor_node), null);\n\t\t\t}\n\n\t\t\tshould_intro = intro;\n\t\t\t// @ts-expect-error the public typings are not what the actual function looks like\n\t\t\tcomponent = Component(anchor_node, props) || {};\n\t\t\tshould_intro = true;\n\n\t\t\tif (hydrating) {\n\t\t\t\t/** @type {Effect} */ (active_effect).nodes_end = hydrate_node;\n\t\t\t}\n\n\t\t\tif (context) {\n\t\t\t\tpop();\n\t\t\t}\n\t\t});\n\n\t\treturn () => {\n\t\t\tfor (var event_name of registered_events) {\n\t\t\t\ttarget.removeEventListener(event_name, handle_event_propagation);\n\n\t\t\t\tvar n = /** @type {number} */ (document_listeners.get(event_name));\n\n\t\t\t\tif (--n === 0) {\n\t\t\t\t\tdocument.removeEventListener(event_name, handle_event_propagation);\n\t\t\t\t\tdocument_listeners.delete(event_name);\n\t\t\t\t} else {\n\t\t\t\t\tdocument_listeners.set(event_name, n);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\troot_event_handles.delete(event_handle);\n\t\t\tmounted_components.delete(component);\n\t\t\tif (anchor_node !== anchor) {\n\t\t\t\tanchor_node.parentNode?.removeChild(anchor_node);\n\t\t\t}\n\t\t};\n\t});\n\n\tmounted_components.set(component, unmount);\n\treturn component;\n}\n\n/**\n * References of the components that were mounted or hydrated.\n * Uses a `WeakMap` to avoid memory leaks.\n */\nlet mounted_components = new WeakMap();\n\n/**\n * Unmounts a component that was previously mounted using `mount` or `hydrate`.\n * @param {Record<string, any>} component\n */\nexport function unmount(component) {\n\tconst fn = mounted_components.get(component);\n\n\tif (fn) {\n\t\tfn();\n\t} else if (DEV) {\n\t\tw.lifecycle_double_unmount();\n\t}\n}\n","/** @import { Effect, TemplateNode } from '#client' */\nimport { EFFECT_TRANSPARENT } from '../../constants.js';\nimport {\n\thydrate_next,\n\thydrate_node,\n\thydrating,\n\tremove_nodes,\n\tset_hydrate_node,\n\tset_hydrating\n} from '../hydration.js';\nimport { block, branch, pause_effect, resume_effect } from '../../reactivity/effects.js';\nimport { HYDRATION_START_ELSE } from '../../../../constants.js';\n\n/**\n * @param {TemplateNode} node\n * @param {() => boolean} get_condition\n * @param {(anchor: Node) => void} consequent_fn\n * @param {null | ((anchor: Node) => void)} [alternate_fn]\n * @param {boolean} [elseif] True if this is an `{:else if ...}` block rather than an `{#if ...}`, as that affects which transitions are considered 'local'\n * @returns {void}\n */\nexport function if_block(node, get_condition, consequent_fn, alternate_fn = null, elseif = false) {\n\tif (hydrating) {\n\t\thydrate_next();\n\t}\n\n\tvar anchor = node;\n\n\t/** @type {Effect | null} */\n\tvar consequent_effect = null;\n\n\t/** @type {Effect | null} */\n\tvar alternate_effect = null;\n\n\t/** @type {boolean | null} */\n\tvar condition = null;\n\n\tvar flags = elseif ? EFFECT_TRANSPARENT : 0;\n\n\tblock(() => {\n\t\tif (condition === (condition = !!get_condition())) return;\n\n\t\t/** Whether or not there was a hydration mismatch. Needs to be a `let` or else it isn't treeshaken out */\n\t\tlet mismatch = false;\n\n\t\tif (hydrating) {\n\t\t\tconst is_else = /** @type {Comment} */ (anchor).data === HYDRATION_START_ELSE;\n\n\t\t\tif (condition === is_else) {\n\t\t\t\t// Hydration mismatch: remove everything inside the anchor and start fresh.\n\t\t\t\t// This could happen with `{#if browser}...{/if}`, for example\n\t\t\t\tanchor = remove_nodes();\n\n\t\t\t\tset_hydrate_node(anchor);\n\t\t\t\tset_hydrating(false);\n\t\t\t\tmismatch = true;\n\t\t\t}\n\t\t}\n\n\t\tif (condition) {\n\t\t\tif (consequent_effect) {\n\t\t\t\tresume_effect(consequent_effect);\n\t\t\t} else {\n\t\t\t\tconsequent_effect = branch(() => consequent_fn(anchor));\n\t\t\t}\n\n\t\t\tif (alternate_effect) {\n\t\t\t\tpause_effect(alternate_effect, () => {\n\t\t\t\t\talternate_effect = null;\n\t\t\t\t});\n\t\t\t}\n\t\t} else {\n\t\t\tif (alternate_effect) {\n\t\t\t\tresume_effect(alternate_effect);\n\t\t\t} else if (alternate_fn) {\n\t\t\t\talternate_effect = branch(() => alternate_fn(anchor));\n\t\t\t}\n\n\t\t\tif (consequent_effect) {\n\t\t\t\tpause_effect(consequent_effect, () => {\n\t\t\t\t\tconsequent_effect = null;\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\tif (mismatch) {\n\t\t\t// continue in hydration mode\n\t\t\tset_hydrating(true);\n\t\t}\n\t}, flags);\n\n\tif (hydrating) {\n\t\tanchor = hydrate_node;\n\t}\n}\n","/** @import { Effect, TemplateNode } from '#client' */\nimport { UNINITIALIZED } from '../../../../constants.js';\nimport { block, branch, pause_effect } from '../../reactivity/effects.js';\nimport { safe_not_equal } from '../../reactivity/equality.js';\nimport { hydrate_next, hydrate_node, hydrating } from '../hydration.js';\n\n/**\n * @template V\n * @param {TemplateNode} node\n * @param {() => V} get_key\n * @param {(anchor: Node) => TemplateNode | void} render_fn\n * @returns {void}\n */\nexport function key_block(node, get_key, render_fn) {\n\tif (hydrating) {\n\t\thydrate_next();\n\t}\n\n\tvar anchor = node;\n\n\t/** @type {V | typeof UNINITIALIZED} */\n\tvar key = UNINITIALIZED;\n\n\t/** @type {Effect} */\n\tvar effect;\n\n\tblock(() => {\n\t\tif (safe_not_equal(key, (key = get_key()))) {\n\t\t\tif (effect) {\n\t\t\t\tpause_effect(effect);\n\t\t\t}\n\n\t\t\teffect = branch(() => render_fn(anchor));\n\t\t}\n\t});\n\n\tif (hydrating) {\n\t\tanchor = hydrate_node;\n\t}\n}\n","/** @import { EachItem, EachState, Effect, MaybeSource, Source, TemplateNode, TransitionManager, Value } from '#client' */\nimport {\n\tEACH_INDEX_REACTIVE,\n\tEACH_IS_ANIMATED,\n\tEACH_IS_CONTROLLED,\n\tEACH_ITEM_IMMUTABLE,\n\tEACH_ITEM_REACTIVE,\n\tHYDRATION_END,\n\tHYDRATION_START_ELSE\n} from '../../../../constants.js';\nimport {\n\thydrate_next,\n\thydrate_node,\n\thydrating,\n\tremove_nodes,\n\tset_hydrate_node,\n\tset_hydrating\n} from '../hydration.js';\nimport {\n\tclear_text_content,\n\tcreate_text,\n\tget_first_child,\n\tget_next_sibling\n} from '../operations.js';\nimport {\n\tblock,\n\tbranch,\n\tdestroy_effect,\n\trun_out_transitions,\n\tpause_children,\n\tpause_effect,\n\tresume_effect\n} from '../../reactivity/effects.js';\nimport { source, mutable_source, internal_set } from '../../reactivity/sources.js';\nimport { array_from, is_array } from '../../../shared/utils.js';\nimport { INERT } from '../../constants.js';\nimport { queue_micro_task } from '../task.js';\nimport { active_effect, active_reaction } from '../../runtime.js';\n\n/**\n * The row of a keyed each block that is currently updating. We track this\n * so that `animate:` directives have something to attach themselves to\n * @type {EachItem | null}\n */\nexport let current_each_item = null;\n\n/** @param {EachItem | null} item */\nexport function set_current_each_item(item) {\n\tcurrent_each_item = item;\n}\n\n/**\n * @param {any} _\n * @param {number} i\n */\nexport function index(_, i) {\n\treturn i;\n}\n\n/**\n * Pause multiple effects simultaneously, and coordinate their\n * subsequent destruction. Used in each blocks\n * @param {EachState} state\n * @param {EachItem[]} items\n * @param {null | Node} controlled_anchor\n * @param {Map<any, EachItem>} items_map\n */\nfunction pause_effects(state, items, controlled_anchor, items_map) {\n\t/** @type {TransitionManager[]} */\n\tvar transitions = [];\n\tvar length = items.length;\n\n\tfor (var i = 0; i < length; i++) {\n\t\tpause_children(items[i].e, transitions, true);\n\t}\n\n\tvar is_controlled = length > 0 && transitions.length === 0 && controlled_anchor !== null;\n\t// If we have a controlled anchor, it means that the each block is inside a single\n\t// DOM element, so we can apply a fast-path for clearing the contents of the element.\n\tif (is_controlled) {\n\t\tvar parent_node = /** @type {Element} */ (\n\t\t\t/** @type {Element} */ (controlled_anchor).parentNode\n\t\t);\n\t\tclear_text_content(parent_node);\n\t\tparent_node.append(/** @type {Element} */ (controlled_anchor));\n\t\titems_map.clear();\n\t\tlink(state, items[0].prev, items[length - 1].next);\n\t}\n\n\trun_out_transitions(transitions, () => {\n\t\tfor (var i = 0; i < length; i++) {\n\t\t\tvar item = items[i];\n\t\t\tif (!is_controlled) {\n\t\t\t\titems_map.delete(item.k);\n\t\t\t\tlink(state, item.prev, item.next);\n\t\t\t}\n\t\t\tdestroy_effect(item.e, !is_controlled);\n\t\t}\n\t});\n}\n\n/**\n * @template V\n * @param {Element | Comment} node The next sibling node, or the parent node if this is a 'controlled' block\n * @param {number} flags\n * @param {() => V[]} get_collection\n * @param {(value: V, index: number) => any} get_key\n * @param {(anchor: Node, item: MaybeSource<V>, index: MaybeSource<number>) => void} render_fn\n * @param {null | ((anchor: Node) => void)} fallback_fn\n * @returns {void}\n */\nexport function each(node, flags, get_collection, get_key, render_fn, fallback_fn = null) {\n\tvar anchor = node;\n\n\t/** @type {EachState} */\n\tvar state = { flags, items: new Map(), first: null };\n\n\tvar is_controlled = (flags & EACH_IS_CONTROLLED) !== 0;\n\n\tif (is_controlled) {\n\t\tvar parent_node = /** @type {Element} */ (node);\n\n\t\tanchor = hydrating\n\t\t\t? set_hydrate_node(/** @type {Comment | Text} */ (get_first_child(parent_node)))\n\t\t\t: parent_node.appendChild(create_text());\n\t}\n\n\tif (hydrating) {\n\t\thydrate_next();\n\t}\n\n\t/** @type {Effect | null} */\n\tvar fallback = null;\n\n\tvar was_empty = false;\n\n\tblock(() => {\n\t\tvar collection = get_collection();\n\n\t\tvar array = is_array(collection)\n\t\t\t? collection\n\t\t\t: collection == null\n\t\t\t\t? []\n\t\t\t\t: array_from(collection);\n\n\t\tvar length = array.length;\n\n\t\tif (was_empty && length === 0) {\n\t\t\t// ignore updates if the array is empty,\n\t\t\t// and it already was empty on previous run\n\t\t\treturn;\n\t\t}\n\t\twas_empty = length === 0;\n\n\t\t/** `true` if there was a hydration mismatch. Needs to be a `let` or else it isn't treeshaken out */\n\t\tlet mismatch = false;\n\n\t\tif (hydrating) {\n\t\t\tvar is_else = /** @type {Comment} */ (anchor).data === HYDRATION_START_ELSE;\n\n\t\t\tif (is_else !== (length === 0)) {\n\t\t\t\t// hydration mismatch  remove the server-rendered DOM and start over\n\t\t\t\tanchor = remove_nodes();\n\n\t\t\t\tset_hydrate_node(anchor);\n\t\t\t\tset_hydrating(false);\n\t\t\t\tmismatch = true;\n\t\t\t}\n\t\t}\n\n\t\t// this is separate to the previous block because `hydrating` might change\n\t\tif (hydrating) {\n\t\t\t/** @type {EachItem | null} */\n\t\t\tvar prev = null;\n\n\t\t\t/** @type {EachItem} */\n\t\t\tvar item;\n\n\t\t\tfor (var i = 0; i < length; i++) {\n\t\t\t\tif (\n\t\t\t\t\thydrate_node.nodeType === 8 &&\n\t\t\t\t\t/** @type {Comment} */ (hydrate_node).data === HYDRATION_END\n\t\t\t\t) {\n\t\t\t\t\t// The server rendered fewer items than expected,\n\t\t\t\t\t// so break out and continue appending non-hydrated items\n\t\t\t\t\tanchor = /** @type {Comment} */ (hydrate_node);\n\t\t\t\t\tmismatch = true;\n\t\t\t\t\tset_hydrating(false);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tvar value = array[i];\n\t\t\t\tvar key = get_key(value, i);\n\t\t\t\titem = create_item(hydrate_node, state, prev, null, value, key, i, render_fn, flags);\n\t\t\t\tstate.items.set(key, item);\n\n\t\t\t\tprev = item;\n\t\t\t}\n\n\t\t\t// remove excess nodes\n\t\t\tif (length > 0) {\n\t\t\t\tset_hydrate_node(remove_nodes());\n\t\t\t}\n\t\t}\n\n\t\tif (!hydrating) {\n\t\t\tvar effect = /** @type {Effect} */ (active_reaction);\n\t\t\treconcile(array, state, anchor, render_fn, flags, (effect.f & INERT) !== 0, get_key);\n\t\t}\n\n\t\tif (fallback_fn !== null) {\n\t\t\tif (length === 0) {\n\t\t\t\tif (fallback) {\n\t\t\t\t\tresume_effect(fallback);\n\t\t\t\t} else {\n\t\t\t\t\tfallback = branch(() => fallback_fn(anchor));\n\t\t\t\t}\n\t\t\t} else if (fallback !== null) {\n\t\t\t\tpause_effect(fallback, () => {\n\t\t\t\t\tfallback = null;\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\tif (mismatch) {\n\t\t\t// continue in hydration mode\n\t\t\tset_hydrating(true);\n\t\t}\n\n\t\t// When we mount the each block for the first time, the collection won't be\n\t\t// connected to this effect as the effect hasn't finished running yet and its deps\n\t\t// won't be assigned. However, it's possible that when reconciling the each block\n\t\t// that a mutation occurred and it's made the collection MAYBE_DIRTY, so reading the\n\t\t// collection again can provide consistency to the reactive graph again as the deriveds\n\t\t// will now be `CLEAN`.\n\t\tget_collection();\n\t});\n\n\tif (hydrating) {\n\t\tanchor = hydrate_node;\n\t}\n}\n\n/**\n * Add, remove, or reorder items output by an each block as its input changes\n * @template V\n * @param {Array<V>} array\n * @param {EachState} state\n * @param {Element | Comment | Text} anchor\n * @param {(anchor: Node, item: MaybeSource<V>, index: number | Source<number>) => void} render_fn\n * @param {number} flags\n * @param {boolean} is_inert\n * @param {(value: V, index: number) => any} get_key\n * @returns {void}\n */\nfunction reconcile(array, state, anchor, render_fn, flags, is_inert, get_key) {\n\tvar is_animated = (flags & EACH_IS_ANIMATED) !== 0;\n\tvar should_update = (flags & (EACH_ITEM_REACTIVE | EACH_INDEX_REACTIVE)) !== 0;\n\n\tvar length = array.length;\n\tvar items = state.items;\n\tvar first = state.first;\n\tvar current = first;\n\n\t/** @type {undefined | Set<EachItem>} */\n\tvar seen;\n\n\t/** @type {EachItem | null} */\n\tvar prev = null;\n\n\t/** @type {undefined | Set<EachItem>} */\n\tvar to_animate;\n\n\t/** @type {EachItem[]} */\n\tvar matched = [];\n\n\t/** @type {EachItem[]} */\n\tvar stashed = [];\n\n\t/** @type {V} */\n\tvar value;\n\n\t/** @type {any} */\n\tvar key;\n\n\t/** @type {EachItem | undefined} */\n\tvar item;\n\n\t/** @type {number} */\n\tvar i;\n\n\tif (is_animated) {\n\t\tfor (i = 0; i < length; i += 1) {\n\t\t\tvalue = array[i];\n\t\t\tkey = get_key(value, i);\n\t\t\titem = items.get(key);\n\n\t\t\tif (item !== undefined) {\n\t\t\t\titem.a?.measure();\n\t\t\t\t(to_animate ??= new Set()).add(item);\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (i = 0; i < length; i += 1) {\n\t\tvalue = array[i];\n\t\tkey = get_key(value, i);\n\t\titem = items.get(key);\n\n\t\tif (item === undefined) {\n\t\t\tvar child_anchor = current ? /** @type {TemplateNode} */ (current.e.nodes_start) : anchor;\n\n\t\t\tprev = create_item(\n\t\t\t\tchild_anchor,\n\t\t\t\tstate,\n\t\t\t\tprev,\n\t\t\t\tprev === null ? state.first : prev.next,\n\t\t\t\tvalue,\n\t\t\t\tkey,\n\t\t\t\ti,\n\t\t\t\trender_fn,\n\t\t\t\tflags\n\t\t\t);\n\n\t\t\titems.set(key, prev);\n\n\t\t\tmatched = [];\n\t\t\tstashed = [];\n\n\t\t\tcurrent = prev.next;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (should_update) {\n\t\t\tupdate_item(item, value, i, flags);\n\t\t}\n\n\t\tif ((item.e.f & INERT) !== 0) {\n\t\t\tresume_effect(item.e);\n\t\t\tif (is_animated) {\n\t\t\t\titem.a?.unfix();\n\t\t\t\t(to_animate ??= new Set()).delete(item);\n\t\t\t}\n\t\t}\n\n\t\tif (item !== current) {\n\t\t\tif (seen !== undefined && seen.has(item)) {\n\t\t\t\tif (matched.length < stashed.length) {\n\t\t\t\t\t// more efficient to move later items to the front\n\t\t\t\t\tvar start = stashed[0];\n\t\t\t\t\tvar j;\n\n\t\t\t\t\tprev = start.prev;\n\n\t\t\t\t\tvar a = matched[0];\n\t\t\t\t\tvar b = matched[matched.length - 1];\n\n\t\t\t\t\tfor (j = 0; j < matched.length; j += 1) {\n\t\t\t\t\t\tmove(matched[j], start, anchor);\n\t\t\t\t\t}\n\n\t\t\t\t\tfor (j = 0; j < stashed.length; j += 1) {\n\t\t\t\t\t\tseen.delete(stashed[j]);\n\t\t\t\t\t}\n\n\t\t\t\t\tlink(state, a.prev, b.next);\n\t\t\t\t\tlink(state, prev, a);\n\t\t\t\t\tlink(state, b, start);\n\n\t\t\t\t\tcurrent = start;\n\t\t\t\t\tprev = b;\n\t\t\t\t\ti -= 1;\n\n\t\t\t\t\tmatched = [];\n\t\t\t\t\tstashed = [];\n\t\t\t\t} else {\n\t\t\t\t\t// more efficient to move earlier items to the back\n\t\t\t\t\tseen.delete(item);\n\t\t\t\t\tmove(item, current, anchor);\n\n\t\t\t\t\tlink(state, item.prev, item.next);\n\t\t\t\t\tlink(state, item, prev === null ? state.first : prev.next);\n\t\t\t\t\tlink(state, prev, item);\n\n\t\t\t\t\tprev = item;\n\t\t\t\t}\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tmatched = [];\n\t\t\tstashed = [];\n\n\t\t\twhile (current !== null && current.k !== key) {\n\t\t\t\t// If the each block isn't inert and an item has an effect that is already inert,\n\t\t\t\t// skip over adding it to our seen Set as the item is already being handled\n\t\t\t\tif (is_inert || (current.e.f & INERT) === 0) {\n\t\t\t\t\t(seen ??= new Set()).add(current);\n\t\t\t\t}\n\t\t\t\tstashed.push(current);\n\t\t\t\tcurrent = current.next;\n\t\t\t}\n\n\t\t\tif (current === null) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\titem = current;\n\t\t}\n\n\t\tmatched.push(item);\n\t\tprev = item;\n\t\tcurrent = item.next;\n\t}\n\n\tif (current !== null || seen !== undefined) {\n\t\tvar to_destroy = seen === undefined ? [] : array_from(seen);\n\n\t\twhile (current !== null) {\n\t\t\t// If the each block isn't inert, then inert effects are currently outroing and will be removed once the transition is finished\n\t\t\tif (is_inert || (current.e.f & INERT) === 0) {\n\t\t\t\tto_destroy.push(current);\n\t\t\t}\n\t\t\tcurrent = current.next;\n\t\t}\n\n\t\tvar destroy_length = to_destroy.length;\n\n\t\tif (destroy_length > 0) {\n\t\t\tvar controlled_anchor = (flags & EACH_IS_CONTROLLED) !== 0 && length === 0 ? anchor : null;\n\n\t\t\tif (is_animated) {\n\t\t\t\tfor (i = 0; i < destroy_length; i += 1) {\n\t\t\t\t\tto_destroy[i].a?.measure();\n\t\t\t\t}\n\n\t\t\t\tfor (i = 0; i < destroy_length; i += 1) {\n\t\t\t\t\tto_destroy[i].a?.fix();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tpause_effects(state, to_destroy, controlled_anchor, items);\n\t\t}\n\t}\n\n\tif (is_animated) {\n\t\tqueue_micro_task(() => {\n\t\t\tif (to_animate === undefined) return;\n\t\t\tfor (item of to_animate) {\n\t\t\t\titem.a?.apply();\n\t\t\t}\n\t\t});\n\t}\n\n\t/** @type {Effect} */ (active_effect).first = state.first && state.first.e;\n\t/** @type {Effect} */ (active_effect).last = prev && prev.e;\n}\n\n/**\n * @param {EachItem} item\n * @param {any} value\n * @param {number} index\n * @param {number} type\n * @returns {void}\n */\nfunction update_item(item, value, index, type) {\n\tif ((type & EACH_ITEM_REACTIVE) !== 0) {\n\t\tinternal_set(item.v, value);\n\t}\n\n\tif ((type & EACH_INDEX_REACTIVE) !== 0) {\n\t\tinternal_set(/** @type {Value<number>} */ (item.i), index);\n\t} else {\n\t\titem.i = index;\n\t}\n}\n\n/**\n * @template V\n * @param {Node} anchor\n * @param {EachState} state\n * @param {EachItem | null} prev\n * @param {EachItem | null} next\n * @param {V} value\n * @param {unknown} key\n * @param {number} index\n * @param {(anchor: Node, item: V | Source<V>, index: number | Value<number>) => void} render_fn\n * @param {number} flags\n * @returns {EachItem}\n */\nfunction create_item(anchor, state, prev, next, value, key, index, render_fn, flags) {\n\tvar previous_each_item = current_each_item;\n\n\ttry {\n\t\tvar reactive = (flags & EACH_ITEM_REACTIVE) !== 0;\n\t\tvar mutable = (flags & EACH_ITEM_IMMUTABLE) === 0;\n\n\t\tvar v = reactive ? (mutable ? mutable_source(value) : source(value)) : value;\n\t\tvar i = (flags & EACH_INDEX_REACTIVE) === 0 ? index : source(index);\n\n\t\t/** @type {EachItem} */\n\t\tvar item = {\n\t\t\ti,\n\t\t\tv,\n\t\t\tk: key,\n\t\t\ta: null,\n\t\t\t// @ts-expect-error\n\t\t\te: null,\n\t\t\tprev,\n\t\t\tnext\n\t\t};\n\n\t\tcurrent_each_item = item;\n\t\titem.e = branch(() => render_fn(anchor, v, i), hydrating);\n\n\t\titem.e.prev = prev && prev.e;\n\t\titem.e.next = next && next.e;\n\n\t\tif (prev === null) {\n\t\t\tstate.first = item;\n\t\t} else {\n\t\t\tprev.next = item;\n\t\t\tprev.e.next = item.e;\n\t\t}\n\n\t\tif (next !== null) {\n\t\t\tnext.prev = item;\n\t\t\tnext.e.prev = item.e;\n\t\t}\n\n\t\treturn item;\n\t} finally {\n\t\tcurrent_each_item = previous_each_item;\n\t}\n}\n\n/**\n * @param {EachItem} item\n * @param {EachItem | null} next\n * @param {Text | Element | Comment} anchor\n */\nfunction move(item, next, anchor) {\n\tvar end = item.next ? /** @type {TemplateNode} */ (item.next.e.nodes_start) : anchor;\n\n\tvar dest = next ? /** @type {TemplateNode} */ (next.e.nodes_start) : anchor;\n\tvar node = /** @type {TemplateNode} */ (item.e.nodes_start);\n\n\twhile (node !== end) {\n\t\tvar next_node = /** @type {TemplateNode} */ (get_next_sibling(node));\n\t\tdest.before(node);\n\t\tnode = next_node;\n\t}\n}\n\n/**\n * @param {EachState} state\n * @param {EachItem | null} prev\n * @param {EachItem | null} next\n */\nfunction link(state, prev, next) {\n\tif (prev === null) {\n\t\tstate.first = next;\n\t} else {\n\t\tprev.next = next;\n\t\tprev.e.next = next && next.e;\n\t}\n\n\tif (next !== null) {\n\t\tnext.prev = prev;\n\t\tnext.e.prev = prev && prev.e;\n\t}\n}\n","/** @import { Snippet } from 'svelte' */\n/** @import { Effect, TemplateNode } from '#client' */\n/** @import { Getters } from '#shared' */\nimport { EFFECT_TRANSPARENT } from '../../constants.js';\nimport { branch, block, destroy_effect, teardown } from '../../reactivity/effects.js';\nimport {\n\tdev_current_component_function,\n\tset_dev_current_component_function\n} from '../../runtime.js';\nimport { hydrate_next, hydrate_node, hydrating } from '../hydration.js';\nimport { create_fragment_from_html } from '../reconciler.js';\nimport { assign_nodes } from '../template.js';\nimport * as w from '../../warnings.js';\nimport * as e from '../../errors.js';\nimport { DEV } from 'esm-env';\nimport { get_first_child, get_next_sibling } from '../operations.js';\nimport { noop } from '../../../shared/utils.js';\n\n/**\n * @template {(node: TemplateNode, ...args: any[]) => void} SnippetFn\n * @param {TemplateNode} node\n * @param {() => SnippetFn | null | undefined} get_snippet\n * @param {(() => any)[]} args\n * @returns {void}\n */\nexport function snippet(node, get_snippet, ...args) {\n\tvar anchor = node;\n\n\t/** @type {SnippetFn | null | undefined} */\n\t// @ts-ignore\n\tvar snippet = noop;\n\n\t/** @type {Effect | null} */\n\tvar snippet_effect;\n\n\tblock(() => {\n\t\tif (snippet === (snippet = get_snippet())) return;\n\n\t\tif (snippet_effect) {\n\t\t\tdestroy_effect(snippet_effect);\n\t\t\tsnippet_effect = null;\n\t\t}\n\n\t\tif (DEV && snippet == null) {\n\t\t\te.invalid_snippet();\n\t\t}\n\n\t\tsnippet_effect = branch(() => /** @type {SnippetFn} */ (snippet)(anchor, ...args));\n\t}, EFFECT_TRANSPARENT);\n\n\tif (hydrating) {\n\t\tanchor = hydrate_node;\n\t}\n}\n\n/**\n * In development, wrap the snippet function so that it passes validation, and so that the\n * correct component context is set for ownership checks\n * @param {any} component\n * @param {(node: TemplateNode, ...args: any[]) => void} fn\n */\nexport function wrap_snippet(component, fn) {\n\treturn (/** @type {TemplateNode} */ node, /** @type {any[]} */ ...args) => {\n\t\tvar previous_component_function = dev_current_component_function;\n\t\tset_dev_current_component_function(component);\n\n\t\ttry {\n\t\t\treturn fn(node, ...args);\n\t\t} finally {\n\t\t\tset_dev_current_component_function(previous_component_function);\n\t\t}\n\t};\n}\n\n/**\n * Create a snippet programmatically\n * @template {unknown[]} Params\n * @param {(...params: Getters<Params>) => {\n *   render: () => string\n *   setup?: (element: Element) => void | (() => void)\n * }} fn\n * @returns {Snippet<Params>}\n */\nexport function createRawSnippet(fn) {\n\t// @ts-expect-error the types are a lie\n\treturn (/** @type {TemplateNode} */ anchor, /** @type {Getters<Params>} */ ...params) => {\n\t\tvar snippet = fn(...params);\n\n\t\t/** @type {Element} */\n\t\tvar element;\n\n\t\tif (hydrating) {\n\t\t\telement = /** @type {Element} */ (hydrate_node);\n\t\t\thydrate_next();\n\t\t} else {\n\t\t\tvar html = snippet.render().trim();\n\t\t\tvar fragment = create_fragment_from_html(html);\n\t\t\telement = /** @type {Element} */ (get_first_child(fragment));\n\n\t\t\tif (DEV && (get_next_sibling(element) !== null || element.nodeType !== 1)) {\n\t\t\t\tw.invalid_raw_snippet_render();\n\t\t\t}\n\n\t\t\tanchor.before(element);\n\t\t}\n\n\t\tconst result = snippet.setup?.(element);\n\t\tassign_nodes(element, element);\n\n\t\tif (typeof result === 'function') {\n\t\t\tteardown(result);\n\t\t}\n\t};\n}\n","/** @import { TemplateNode, Dom, Effect } from '#client' */\nimport { EFFECT_TRANSPARENT } from '../../constants.js';\nimport { block, branch, pause_effect } from '../../reactivity/effects.js';\nimport { hydrate_next, hydrate_node, hydrating } from '../hydration.js';\n\n/**\n * @template P\n * @template {(props: P) => void} C\n * @param {TemplateNode} node\n * @param {() => C} get_component\n * @param {(anchor: TemplateNode, component: C) => Dom | void} render_fn\n * @returns {void}\n */\nexport function component(node, get_component, render_fn) {\n\tif (hydrating) {\n\t\thydrate_next();\n\t}\n\n\tvar anchor = node;\n\n\t/** @type {C} */\n\tvar component;\n\n\t/** @type {Effect | null} */\n\tvar effect;\n\n\tblock(() => {\n\t\tif (component === (component = get_component())) return;\n\n\t\tif (effect) {\n\t\t\tpause_effect(effect);\n\t\t\teffect = null;\n\t\t}\n\n\t\tif (component) {\n\t\t\teffect = branch(() => render_fn(anchor, component));\n\t\t}\n\t}, EFFECT_TRANSPARENT);\n\n\tif (hydrating) {\n\t\tanchor = hydrate_node;\n\t}\n}\n","import { hydrating } from '../hydration.js';\nimport { clear_text_content, get_first_child } from '../operations.js';\nimport { queue_micro_task } from '../task.js';\n\n/**\n * @param {HTMLElement} dom\n * @param {boolean} value\n * @returns {void}\n */\nexport function autofocus(dom, value) {\n\tif (value) {\n\t\tconst body = document.body;\n\t\tdom.autofocus = true;\n\n\t\tqueue_micro_task(() => {\n\t\t\tif (document.activeElement === body) {\n\t\t\t\tdom.focus();\n\t\t\t}\n\t\t});\n\t}\n}\n\n/**\n * The child of a textarea actually corresponds to the defaultValue property, so we need\n * to remove it upon hydration to avoid a bug when someone resets the form value.\n * @param {HTMLTextAreaElement} dom\n * @returns {void}\n */\nexport function remove_textarea_child(dom) {\n\tif (hydrating && get_first_child(dom) !== null) {\n\t\tclear_text_content(dom);\n\t}\n}\n\nlet listening_to_form_reset = false;\n\nexport function add_form_reset_listener() {\n\tif (!listening_to_form_reset) {\n\t\tlistening_to_form_reset = true;\n\t\tdocument.addEventListener(\n\t\t\t'reset',\n\t\t\t(evt) => {\n\t\t\t\t// Needs to happen one tick later or else the dom properties of the form\n\t\t\t\t// elements have not updated to their reset values yet\n\t\t\t\tPromise.resolve().then(() => {\n\t\t\t\t\tif (!evt.defaultPrevented) {\n\t\t\t\t\t\tfor (const e of /**@type {HTMLFormElement} */ (evt.target).elements) {\n\t\t\t\t\t\t\t// @ts-expect-error\n\t\t\t\t\t\t\te.__on_r?.();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t},\n\t\t\t// In the capture phase to guarantee we get noticed of it (no possiblity of stopPropagation)\n\t\t\t{ capture: true }\n\t\t);\n\t}\n}\n","import { DEV } from 'esm-env';\nimport { hydrating } from '../hydration.js';\nimport { get_descriptors, get_prototype_of } from '../../../shared/utils.js';\nimport { create_event, delegate } from './events.js';\nimport { add_form_reset_listener, autofocus } from './misc.js';\nimport * as w from '../../warnings.js';\nimport { LOADING_ATTR_SYMBOL } from '../../constants.js';\nimport { queue_idle_task, queue_micro_task } from '../task.js';\nimport { is_capture_event, is_delegated, normalize_attribute } from '../../../../utils.js';\nimport {\n\tactive_effect,\n\tactive_reaction,\n\tset_active_effect,\n\tset_active_reaction\n} from '../../runtime.js';\n\n/**\n * The value/checked attribute in the template actually corresponds to the defaultValue property, so we need\n * to remove it upon hydration to avoid a bug when someone resets the form value.\n * @param {HTMLInputElement} input\n * @returns {void}\n */\nexport function remove_input_defaults(input) {\n\tif (!hydrating) return;\n\n\tvar already_removed = false;\n\n\t// We try and remove the default attributes later, rather than sync during hydration.\n\t// Doing it sync during hydration has a negative impact on performance, but deferring the\n\t// work in an idle task alleviates this greatly. If a form reset event comes in before\n\t// the idle callback, then we ensure the input defaults are cleared just before.\n\tvar remove_defaults = () => {\n\t\tif (already_removed) return;\n\t\talready_removed = true;\n\n\t\t// Remove the attributes but preserve the values\n\t\tif (input.hasAttribute('value')) {\n\t\t\tvar value = input.value;\n\t\t\tset_attribute(input, 'value', null);\n\t\t\tinput.value = value;\n\t\t}\n\n\t\tif (input.hasAttribute('checked')) {\n\t\t\tvar checked = input.checked;\n\t\t\tset_attribute(input, 'checked', null);\n\t\t\tinput.checked = checked;\n\t\t}\n\t};\n\n\t// @ts-expect-error\n\tinput.__on_r = remove_defaults;\n\tqueue_idle_task(remove_defaults);\n\tadd_form_reset_listener();\n}\n\n/**\n * @param {Element} element\n * @param {any} value\n */\nexport function set_value(element, value) {\n\t// @ts-expect-error\n\tvar attributes = (element.__attributes ??= {});\n\tif (\n\t\tattributes.value === (attributes.value = value) ||\n\t\t// @ts-expect-error\n\t\t// `progress` elements always need their value set when its `0`\n\t\t(element.value === value && (value !== 0 || element.nodeName !== 'PROGRESS'))\n\t)\n\t\treturn;\n\t// @ts-expect-error\n\telement.value = value;\n}\n\n/**\n * @param {Element} element\n * @param {boolean} checked\n */\nexport function set_checked(element, checked) {\n\t// @ts-expect-error\n\tvar attributes = (element.__attributes ??= {});\n\n\tif (attributes.checked === (attributes.checked = checked)) return;\n\t// @ts-expect-error\n\telement.checked = checked;\n}\n\n/**\n * @param {Element} element\n * @param {string} attribute\n * @param {string | null} value\n * @param {boolean} [skip_warning]\n */\nexport function set_attribute(element, attribute, value, skip_warning) {\n\t// @ts-expect-error\n\tvar attributes = (element.__attributes ??= {});\n\n\tif (hydrating) {\n\t\tattributes[attribute] = element.getAttribute(attribute);\n\n\t\tif (\n\t\t\tattribute === 'src' ||\n\t\t\tattribute === 'srcset' ||\n\t\t\t(attribute === 'href' && element.nodeName === 'LINK')\n\t\t) {\n\t\t\tif (!skip_warning) {\n\t\t\t\tcheck_src_in_dev_hydration(element, attribute, value ?? '');\n\t\t\t}\n\n\t\t\t// If we reset these attributes, they would result in another network request, which we want to avoid.\n\t\t\t// We assume they are the same between client and server as checking if they are equal is expensive\n\t\t\t// (we can't just compare the strings as they can be different between client and server but result in the\n\t\t\t// same url, so we would need to create hidden anchor elements to compare them)\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (attributes[attribute] === (attributes[attribute] = value)) return;\n\n\tif (attribute === 'style' && '__styles' in element) {\n\t\t// reset styles to force style: directive to update\n\t\telement.__styles = {};\n\t}\n\n\tif (attribute === 'loading') {\n\t\t// @ts-expect-error\n\t\telement[LOADING_ATTR_SYMBOL] = value;\n\t}\n\n\tif (value == null) {\n\t\telement.removeAttribute(attribute);\n\t} else if (typeof value !== 'string' && get_setters(element).includes(attribute)) {\n\t\t// @ts-ignore\n\t\telement[attribute] = value;\n\t} else {\n\t\telement.setAttribute(attribute, value);\n\t}\n}\n\n/**\n * @param {Element} dom\n * @param {string} attribute\n * @param {string} value\n */\nexport function set_xlink_attribute(dom, attribute, value) {\n\tdom.setAttributeNS('http://www.w3.org/1999/xlink', attribute, value);\n}\n\n/**\n * @param {any} node\n * @param {string} prop\n * @param {any} value\n */\nexport function set_custom_element_data(node, prop, value) {\n\t// We need to ensure that setting custom element props, which can\n\t// invoke lifecycle methods on other custom elements, does not also\n\t// associate those lifecycle methods with the current active reaction\n\t// or effect\n\tvar previous_reaction = active_reaction;\n\tvar previous_effect = active_effect;\n\n\tset_active_reaction(null);\n\tset_active_effect(null);\n\ttry {\n\t\tif (get_setters(node).includes(prop)) {\n\t\t\tnode[prop] = value;\n\t\t} else {\n\t\t\tset_attribute(node, prop, value);\n\t\t}\n\t} finally {\n\t\tset_active_reaction(previous_reaction);\n\t\tset_active_effect(previous_effect);\n\t}\n}\n\n/**\n * Spreads attributes onto a DOM element, taking into account the currently set attributes\n * @param {Element & ElementCSSInlineStyle} element\n * @param {Record<string, any> | undefined} prev\n * @param {Record<string, any>} next New attributes - this function mutates this object\n * @param {string} [css_hash]\n * @param {boolean} [preserve_attribute_case]\n * @param {boolean} [is_custom_element]\n * @param {boolean} [skip_warning]\n * @returns {Record<string, any>}\n */\nexport function set_attributes(\n\telement,\n\tprev,\n\tnext,\n\tcss_hash,\n\tpreserve_attribute_case = false,\n\tis_custom_element = false,\n\tskip_warning = false\n) {\n\tvar current = prev || {};\n\tvar is_option_element = element.tagName === 'OPTION';\n\n\tfor (var key in prev) {\n\t\tif (!(key in next)) {\n\t\t\tnext[key] = null;\n\t\t}\n\t}\n\n\tif (css_hash !== undefined) {\n\t\tnext.class = next.class ? next.class + ' ' + css_hash : css_hash;\n\t}\n\n\tvar setters = get_setters(element);\n\n\t// @ts-expect-error\n\tvar attributes = /** @type {Record<string, unknown>} **/ (element.__attributes ??= {});\n\t/** @type {Array<[string, any, () => void]>} */\n\tvar events = [];\n\n\t// since key is captured we use const\n\tfor (const key in next) {\n\t\t// let instead of var because referenced in a closure\n\t\tlet value = next[key];\n\n\t\t// Up here because we want to do this for the initial value, too, even if it's undefined,\n\t\t// and this wouldn't be reached in case of undefined because of the equality check below\n\t\tif (is_option_element && key === 'value' && value == null) {\n\t\t\t// The <option> element is a special case because removing the value attribute means\n\t\t\t// the value is set to the text content of the option element, and setting the value\n\t\t\t// to null or undefined means the value is set to the string \"null\" or \"undefined\".\n\t\t\t// To align with how we handle this case in non-spread-scenarios, this logic is needed.\n\t\t\t// There's a super-edge-case bug here that is left in in favor of smaller code size:\n\t\t\t// Because of the \"set missing props to null\" logic above, we can't differentiate\n\t\t\t// between a missing value and an explicitly set value of null or undefined. That means\n\t\t\t// that once set, the value attribute of an <option> element can't be removed. This is\n\t\t\t// a very rare edge case, and removing the attribute altogether isn't possible either\n\t\t\t// for the <option value={undefined}> case, so we're not losing any functionality here.\n\t\t\t// @ts-ignore\n\t\t\telement.value = element.__value = '';\n\t\t\tcurrent[key] = value;\n\t\t\tcontinue;\n\t\t}\n\n\t\tvar prev_value = current[key];\n\t\tif (value === prev_value) continue;\n\n\t\tcurrent[key] = value;\n\n\t\tvar prefix = key[0] + key[1]; // this is faster than key.slice(0, 2)\n\t\tif (prefix === '$$') continue;\n\n\t\tif (prefix === 'on') {\n\t\t\t/** @type {{ capture?: true }} */\n\t\t\tconst opts = {};\n\t\t\tconst event_handle_key = '$$' + key;\n\t\t\tlet event_name = key.slice(2);\n\t\t\tvar delegated = is_delegated(event_name);\n\n\t\t\tif (is_capture_event(event_name)) {\n\t\t\t\tevent_name = event_name.slice(0, -7);\n\t\t\t\topts.capture = true;\n\t\t\t}\n\n\t\t\tif (!delegated && prev_value) {\n\t\t\t\t// Listening to same event but different handler -> our handle function below takes care of this\n\t\t\t\t// If we were to remove and add listeners in this case, it could happen that the event is \"swallowed\"\n\t\t\t\t// (the browser seems to not know yet that a new one exists now) and doesn't reach the handler\n\t\t\t\t// https://github.com/sveltejs/svelte/issues/11903\n\t\t\t\tif (value != null) continue;\n\n\t\t\t\telement.removeEventListener(event_name, current[event_handle_key], opts);\n\t\t\t\tcurrent[event_handle_key] = null;\n\t\t\t}\n\n\t\t\tif (value != null) {\n\t\t\t\tif (!delegated) {\n\t\t\t\t\t/**\n\t\t\t\t\t * @this {any}\n\t\t\t\t\t * @param {Event} evt\n\t\t\t\t\t */\n\t\t\t\t\tfunction handle(evt) {\n\t\t\t\t\t\tcurrent[key].call(this, evt);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!prev) {\n\t\t\t\t\t\tevents.push([\n\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\tvalue,\n\t\t\t\t\t\t\t() => (current[event_handle_key] = create_event(event_name, element, handle, opts))\n\t\t\t\t\t\t]);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcurrent[event_handle_key] = create_event(event_name, element, handle, opts);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// @ts-ignore\n\t\t\t\t\telement[`__${event_name}`] = value;\n\t\t\t\t\tdelegate([event_name]);\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (key === 'style' && value != null) {\n\t\t\telement.style.cssText = value + '';\n\t\t} else if (key === 'autofocus') {\n\t\t\tautofocus(/** @type {HTMLElement} */ (element), Boolean(value));\n\t\t} else if (key === '__value' || (key === 'value' && value != null)) {\n\t\t\t// @ts-ignore\n\t\t\telement.value = element[key] = element.__value = value;\n\t\t} else {\n\t\t\tvar name = key;\n\t\t\tif (!preserve_attribute_case) {\n\t\t\t\tname = normalize_attribute(name);\n\t\t\t}\n\n\t\t\tif (value == null && !is_custom_element) {\n\t\t\t\tattributes[key] = null;\n\t\t\t\telement.removeAttribute(key);\n\t\t\t} else if (setters.includes(name) && (is_custom_element || typeof value !== 'string')) {\n\t\t\t\t// @ts-ignore\n\t\t\t\telement[name] = value;\n\t\t\t} else if (typeof value !== 'function') {\n\t\t\t\tif (hydrating && (name === 'src' || name === 'href' || name === 'srcset')) {\n\t\t\t\t\tif (!skip_warning) check_src_in_dev_hydration(element, name, value ?? '');\n\t\t\t\t} else {\n\t\t\t\t\tset_attribute(element, name, value);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (key === 'style' && '__styles' in element) {\n\t\t\t// reset styles to force style: directive to update\n\t\t\telement.__styles = {};\n\t\t}\n\t}\n\n\t// On the first run, ensure that events are added after bindings so\n\t// that their listeners fire after the binding listeners\n\tif (!prev) {\n\t\tqueue_micro_task(() => {\n\t\t\tif (!element.isConnected) return;\n\t\t\tfor (const [key, value, evt] of events) {\n\t\t\t\tif (current[key] === value) {\n\t\t\t\t\tevt();\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n\n\treturn current;\n}\n\n/** @type {Map<string, string[]>} */\nvar setters_cache = new Map();\n\n/** @param {Element} element */\nfunction get_setters(element) {\n\tvar setters = setters_cache.get(element.nodeName);\n\tif (setters) return setters;\n\tsetters_cache.set(element.nodeName, (setters = []));\n\tvar descriptors;\n\tvar proto = get_prototype_of(element);\n\tvar element_proto = Element.prototype;\n\n\t// Stop at Element, from there on there's only unnecessary setters we're not interested in\n\t// Do not use contructor.name here as that's unreliable in some browser environments\n\twhile (element_proto !== proto) {\n\t\tdescriptors = get_descriptors(proto);\n\n\t\tfor (var key in descriptors) {\n\t\t\tif (descriptors[key].set) {\n\t\t\t\tsetters.push(key);\n\t\t\t}\n\t\t}\n\n\t\tproto = get_prototype_of(proto);\n\t}\n\n\treturn setters;\n}\n\n/**\n * @param {any} element\n * @param {string} attribute\n * @param {string} value\n */\nfunction check_src_in_dev_hydration(element, attribute, value) {\n\tif (!DEV) return;\n\tif (attribute === 'srcset' && srcset_url_equal(element, value)) return;\n\tif (src_url_equal(element.getAttribute(attribute) ?? '', value)) return;\n\n\tw.hydration_attribute_changed(\n\t\tattribute,\n\t\telement.outerHTML.replace(element.innerHTML, element.innerHTML && '...'),\n\t\tString(value)\n\t);\n}\n\n/**\n * @param {string} element_src\n * @param {string} url\n * @returns {boolean}\n */\nfunction src_url_equal(element_src, url) {\n\tif (element_src === url) return true;\n\treturn new URL(element_src, document.baseURI).href === new URL(url, document.baseURI).href;\n}\n\n/** @param {string} srcset */\nfunction split_srcset(srcset) {\n\treturn srcset.split(',').map((src) => src.trim().split(' ').filter(Boolean));\n}\n\n/**\n * @param {HTMLSourceElement | HTMLImageElement} element\n * @param {string} srcset\n * @returns {boolean}\n */\nfunction srcset_url_equal(element, srcset) {\n\tvar element_urls = split_srcset(element.srcset);\n\tvar urls = split_srcset(srcset);\n\n\treturn (\n\t\turls.length === element_urls.length &&\n\t\turls.every(\n\t\t\t([url, width], i) =>\n\t\t\t\twidth === element_urls[i][1] &&\n\t\t\t\t// We need to test both ways because Vite will create an a full URL with\n\t\t\t\t// `new URL(asset, import.meta.url).href` for the client when `base: './'`, and the\n\t\t\t\t// relative URLs inside srcset are not automatically resolved to absolute URLs by\n\t\t\t\t// browsers (in contrast to img.src). This means both SSR and DOM code could\n\t\t\t\t// contain relative or absolute URLs.\n\t\t\t\t(src_url_equal(element_urls[i][0], url) || src_url_equal(url, element_urls[i][0]))\n\t\t)\n\t);\n}\n\n/**\n * @param {HTMLImageElement} element\n * @returns {void}\n */\nexport function handle_lazy_img(element) {\n\t// If we're using an image that has a lazy loading attribute, we need to apply\n\t// the loading and src after the img element has been appended to the document.\n\t// Otherwise the lazy behaviour will not work due to our cloneNode heuristic for\n\t// templates.\n\tif (!hydrating && element.loading === 'lazy') {\n\t\tvar src = element.src;\n\t\t// @ts-expect-error\n\t\telement[LOADING_ATTR_SYMBOL] = null;\n\t\telement.loading = 'eager';\n\t\telement.removeAttribute('src');\n\t\trequestAnimationFrame(() => {\n\t\t\t// @ts-expect-error\n\t\t\tif (element[LOADING_ATTR_SYMBOL] !== 'eager') {\n\t\t\t\telement.loading = 'lazy';\n\t\t\t}\n\t\t\telement.src = src;\n\t\t});\n\t}\n}\n","import { hydrating } from '../hydration.js';\n\n/**\n * @param {SVGElement} dom\n * @param {string} value\n * @returns {void}\n */\nexport function set_svg_class(dom, value) {\n\t// @ts-expect-error need to add __className to patched prototype\n\tvar prev_class_name = dom.__className;\n\tvar next_class_name = to_class(value);\n\n\tif (hydrating && dom.getAttribute('class') === next_class_name) {\n\t\t// In case of hydration don't reset the class as it's already correct.\n\t\t// @ts-expect-error need to add __className to patched prototype\n\t\tdom.__className = next_class_name;\n\t} else if (\n\t\tprev_class_name !== next_class_name ||\n\t\t(hydrating && dom.getAttribute('class') !== next_class_name)\n\t) {\n\t\tif (next_class_name === '') {\n\t\t\tdom.removeAttribute('class');\n\t\t} else {\n\t\t\tdom.setAttribute('class', next_class_name);\n\t\t}\n\n\t\t// @ts-expect-error need to add __className to patched prototype\n\t\tdom.__className = next_class_name;\n\t}\n}\n\n/**\n * @param {MathMLElement} dom\n * @param {string} value\n * @returns {void}\n */\nexport function set_mathml_class(dom, value) {\n\t// @ts-expect-error need to add __className to patched prototype\n\tvar prev_class_name = dom.__className;\n\tvar next_class_name = to_class(value);\n\n\tif (hydrating && dom.getAttribute('class') === next_class_name) {\n\t\t// In case of hydration don't reset the class as it's already correct.\n\t\t// @ts-expect-error need to add __className to patched prototype\n\t\tdom.__className = next_class_name;\n\t} else if (\n\t\tprev_class_name !== next_class_name ||\n\t\t(hydrating && dom.getAttribute('class') !== next_class_name)\n\t) {\n\t\tif (next_class_name === '') {\n\t\t\tdom.removeAttribute('class');\n\t\t} else {\n\t\t\tdom.setAttribute('class', next_class_name);\n\t\t}\n\n\t\t// @ts-expect-error need to add __className to patched prototype\n\t\tdom.__className = next_class_name;\n\t}\n}\n\n/**\n * @param {HTMLElement} dom\n * @param {string} value\n * @returns {void}\n */\nexport function set_class(dom, value) {\n\t// @ts-expect-error need to add __className to patched prototype\n\tvar prev_class_name = dom.__className;\n\tvar next_class_name = to_class(value);\n\n\tif (hydrating && dom.className === next_class_name) {\n\t\t// In case of hydration don't reset the class as it's already correct.\n\t\t// @ts-expect-error need to add __className to patched prototype\n\t\tdom.__className = next_class_name;\n\t} else if (\n\t\tprev_class_name !== next_class_name ||\n\t\t(hydrating && dom.className !== next_class_name)\n\t) {\n\t\t// Removing the attribute when the value is only an empty string causes\n\t\t// peformance issues vs simply making the className an empty string. So\n\t\t// we should only remove the class if the the value is nullish.\n\t\tif (value == null) {\n\t\t\tdom.removeAttribute('class');\n\t\t} else {\n\t\t\tdom.className = next_class_name;\n\t\t}\n\n\t\t// @ts-expect-error need to add __className to patched prototype\n\t\tdom.__className = next_class_name;\n\t}\n}\n\n/**\n * @template V\n * @param {V} value\n * @returns {string | V}\n */\nfunction to_class(value) {\n\treturn value == null ? '' : value;\n}\n\n/**\n * @param {Element} dom\n * @param {string} class_name\n * @param {boolean} value\n * @returns {void}\n */\nexport function toggle_class(dom, class_name, value) {\n\tif (value) {\n\t\tif (dom.classList.contains(class_name)) return;\n\t\tdom.classList.add(class_name);\n\t} else {\n\t\tif (!dom.classList.contains(class_name)) return;\n\t\tdom.classList.remove(class_name);\n\t}\n}\n","/** @import { ComponentContext, ComponentContextLegacy } from '#client' */\n/** @import { EventDispatcher } from './index.js' */\n/** @import { NotFunction } from './internal/types.js' */\nimport { component_context, flush_sync, untrack } from './internal/client/runtime.js';\nimport { is_array } from './internal/shared/utils.js';\nimport { user_effect } from './internal/client/index.js';\nimport * as e from './internal/client/errors.js';\nimport { lifecycle_outside_component } from './internal/shared/errors.js';\n\n/**\n * The `onMount` function schedules a callback to run as soon as the component has been mounted to the DOM.\n * It must be called during the component's initialisation (but doesn't need to live *inside* the component;\n * it can be called from an external module).\n *\n * If a function is returned _synchronously_ from `onMount`, it will be called when the component is unmounted.\n *\n * `onMount` does not run inside [server-side components](https://svelte.dev/docs/svelte/svelte-server#render).\n *\n * @template T\n * @param {() => NotFunction<T> | Promise<NotFunction<T>> | (() => any)} fn\n * @returns {void}\n */\nexport function onMount(fn) {\n\tif (component_context === null) {\n\t\tlifecycle_outside_component('onMount');\n\t}\n\n\tif (component_context.l !== null) {\n\t\tinit_update_callbacks(component_context).m.push(fn);\n\t} else {\n\t\tuser_effect(() => {\n\t\t\tconst cleanup = untrack(fn);\n\t\t\tif (typeof cleanup === 'function') return /** @type {() => void} */ (cleanup);\n\t\t});\n\t}\n}\n\n/**\n * Schedules a callback to run immediately before the component is unmounted.\n *\n * Out of `onMount`, `beforeUpdate`, `afterUpdate` and `onDestroy`, this is the\n * only one that runs inside a server-side component.\n *\n * @param {() => any} fn\n * @returns {void}\n */\nexport function onDestroy(fn) {\n\tif (component_context === null) {\n\t\tlifecycle_outside_component('onDestroy');\n\t}\n\n\tonMount(() => () => untrack(fn));\n}\n\n/**\n * @template [T=any]\n * @param {string} type\n * @param {T} [detail]\n * @param {any}params_0\n * @returns {CustomEvent<T>}\n */\nfunction create_custom_event(type, detail, { bubbles = false, cancelable = false } = {}) {\n\treturn new CustomEvent(type, { detail, bubbles, cancelable });\n}\n\n/**\n * Creates an event dispatcher that can be used to dispatch [component events](https://svelte.dev/docs/svelte/legacy-on#Component-events).\n * Event dispatchers are functions that can take two arguments: `name` and `detail`.\n *\n * Component events created with `createEventDispatcher` create a\n * [CustomEvent](https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent).\n * These events do not [bubble](https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Building_blocks/Events#Event_bubbling_and_capture).\n * The `detail` argument corresponds to the [CustomEvent.detail](https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent/detail)\n * property and can contain any type of data.\n *\n * The event dispatcher can be typed to narrow the allowed event names and the type of the `detail` argument:\n * ```ts\n * const dispatch = createEventDispatcher<{\n *  loaded: never; // does not take a detail argument\n *  change: string; // takes a detail argument of type string, which is required\n *  optional: number | null; // takes an optional detail argument of type number\n * }>();\n * ```\n *\n * @deprecated Use callback props and/or the `$host()` rune instead  see https://svelte.dev/docs/svelte/v5-migration-guide#Event-changes-Component-events\n * @template {Record<string, any>} [EventMap = any]\n * @returns {EventDispatcher<EventMap>}\n */\nexport function createEventDispatcher() {\n\tconst active_component_context = component_context;\n\tif (active_component_context === null) {\n\t\tlifecycle_outside_component('createEventDispatcher');\n\t}\n\n\treturn (type, detail, options) => {\n\t\tconst events = /** @type {Record<string, Function | Function[]>} */ (\n\t\t\tactive_component_context.s.$$events\n\t\t)?.[/** @type {any} */ (type)];\n\n\t\tif (events) {\n\t\t\tconst callbacks = is_array(events) ? events.slice() : [events];\n\t\t\t// TODO are there situations where events could be dispatched\n\t\t\t// in a server (non-DOM) environment?\n\t\t\tconst event = create_custom_event(/** @type {string} */ (type), detail, options);\n\t\t\tfor (const fn of callbacks) {\n\t\t\t\tfn.call(active_component_context.x, event);\n\t\t\t}\n\t\t\treturn !event.defaultPrevented;\n\t\t}\n\n\t\treturn true;\n\t};\n}\n\n// TODO mark beforeUpdate and afterUpdate as deprecated in Svelte 6\n\n/**\n * Schedules a callback to run immediately before the component is updated after any state change.\n *\n * The first time the callback runs will be before the initial `onMount`.\n *\n * In runes mode use `$effect.pre` instead.\n *\n * @deprecated Use `$effect.pre` instead  see https://svelte.dev/docs/svelte/$effect#$effect.pre\n * @param {() => void} fn\n * @returns {void}\n */\nexport function beforeUpdate(fn) {\n\tif (component_context === null) {\n\t\tlifecycle_outside_component('beforeUpdate');\n\t}\n\n\tif (component_context.l === null) {\n\t\te.lifecycle_legacy_only('beforeUpdate');\n\t}\n\n\tinit_update_callbacks(component_context).b.push(fn);\n}\n\n/**\n * Schedules a callback to run immediately after the component has been updated.\n *\n * The first time the callback runs will be after the initial `onMount`.\n *\n * In runes mode use `$effect` instead.\n *\n * @deprecated Use `$effect` instead  see https://svelte.dev/docs/svelte/$effect\n * @param {() => void} fn\n * @returns {void}\n */\nexport function afterUpdate(fn) {\n\tif (component_context === null) {\n\t\tlifecycle_outside_component('afterUpdate');\n\t}\n\n\tif (component_context.l === null) {\n\t\te.lifecycle_legacy_only('afterUpdate');\n\t}\n\n\tinit_update_callbacks(component_context).a.push(fn);\n}\n\n/**\n * Legacy-mode: Init callbacks object for onMount/beforeUpdate/afterUpdate\n * @param {ComponentContext} context\n */\nfunction init_update_callbacks(context) {\n\tvar l = /** @type {ComponentContextLegacy} */ (context).l;\n\treturn (l.u ??= { a: [], b: [], m: [] });\n}\n\n/**\n * Synchronously flushes any pending state changes and those that result from it.\n * @param {() => void} [fn]\n * @returns {void}\n */\nexport function flushSync(fn) {\n\tflush_sync(fn);\n}\n\nexport { hydrate, mount, unmount } from './internal/client/render.js';\n\nexport {\n\tgetContext,\n\tgetAllContexts,\n\thasContext,\n\tsetContext,\n\ttick,\n\tuntrack\n} from './internal/client/runtime.js';\n\nexport { createRawSnippet } from './internal/client/dom/blocks/snippet.js';\n","/** @import { StoreReferencesContainer } from '#client' */\n/** @import { Store } from '#shared' */\nimport { subscribe_to_store } from '../../../store/utils.js';\nimport { noop } from '../../shared/utils.js';\nimport { get } from '../runtime.js';\nimport { teardown } from './effects.js';\nimport { mutable_source, set } from './sources.js';\n\n/**\n * Whether or not the prop currently being read is a store binding, as in\n * `<Child bind:x={$y} />`. If it is, we treat the prop as mutable even in\n * runes mode, and skip `binding_property_non_reactive` validation\n */\nlet is_store_binding = false;\n\n/**\n * Gets the current value of a store. If the store isn't subscribed to yet, it will create a proxy\n * signal that will be updated when the store is. The store references container is needed to\n * track reassignments to stores and to track the correct component context.\n * @template V\n * @param {Store<V> | null | undefined} store\n * @param {string} store_name\n * @param {StoreReferencesContainer} stores\n * @returns {V}\n */\nexport function store_get(store, store_name, stores) {\n\tconst entry = (stores[store_name] ??= {\n\t\tstore: null,\n\t\tsource: mutable_source(undefined),\n\t\tunsubscribe: noop\n\t});\n\n\tif (entry.store !== store) {\n\t\tentry.unsubscribe();\n\t\tentry.store = store ?? null;\n\n\t\tif (store == null) {\n\t\t\tentry.source.v = undefined; // see synchronous callback comment below\n\t\t\tentry.unsubscribe = noop;\n\t\t} else {\n\t\t\tvar is_synchronous_callback = true;\n\n\t\t\tentry.unsubscribe = subscribe_to_store(store, (v) => {\n\t\t\t\tif (is_synchronous_callback) {\n\t\t\t\t\t// If the first updates to the store value (possibly multiple of them) are synchronously\n\t\t\t\t\t// inside a derived, we will hit the `state_unsafe_mutation` error if we `set` the value\n\t\t\t\t\tentry.source.v = v;\n\t\t\t\t} else {\n\t\t\t\t\tset(entry.source, v);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tis_synchronous_callback = false;\n\t\t}\n\t}\n\n\treturn get(entry.source);\n}\n\n/**\n * Unsubscribe from a store if it's not the same as the one in the store references container.\n * We need this in addition to `store_get` because someone could unsubscribe from a store but\n * then never subscribe to the new one (if any), causing the subscription to stay open wrongfully.\n * @param {Store<any> | null | undefined} store\n * @param {string} store_name\n * @param {StoreReferencesContainer} stores\n */\nexport function store_unsub(store, store_name, stores) {\n\t/** @type {StoreReferencesContainer[''] | undefined} */\n\tlet entry = stores[store_name];\n\n\tif (entry && entry.store !== store) {\n\t\t// Don't reset store yet, so that store_get above can resubscribe to new store if necessary\n\t\tentry.unsubscribe();\n\t\tentry.unsubscribe = noop;\n\t}\n\n\treturn store;\n}\n\n/**\n * Sets the new value of a store and returns that value.\n * @template V\n * @param {Store<V>} store\n * @param {V} value\n * @returns {V}\n */\nexport function store_set(store, value) {\n\tstore.set(value);\n\treturn value;\n}\n\n/**\n * @param {StoreReferencesContainer} stores\n * @param {string} store_name\n */\nexport function invalidate_store(stores, store_name) {\n\tvar entry = stores[store_name];\n\tif (entry.store !== null) {\n\t\tstore_set(entry.store, entry.source.v);\n\t}\n}\n\n/**\n * Unsubscribes from all auto-subscribed stores on destroy\n * @returns {StoreReferencesContainer}\n */\nexport function setup_stores() {\n\t/** @type {StoreReferencesContainer} */\n\tconst stores = {};\n\n\tteardown(() => {\n\t\tfor (var store_name in stores) {\n\t\t\tconst ref = stores[store_name];\n\t\t\tref.unsubscribe();\n\t\t}\n\t});\n\n\treturn stores;\n}\n\n/**\n * Updates a store with a new value.\n * @param {Store<V>} store  the store to update\n * @param {any} expression  the expression that mutates the store\n * @param {V} new_value  the new store value\n * @template V\n */\nexport function store_mutate(store, expression, new_value) {\n\tstore.set(new_value);\n\treturn expression;\n}\n\n/**\n * @param {Store<number>} store\n * @param {number} store_value\n * @param {1 | -1} [d]\n * @returns {number}\n */\nexport function update_store(store, store_value, d = 1) {\n\tstore.set(store_value + d);\n\treturn store_value;\n}\n\n/**\n * @param {Store<number>} store\n * @param {number} store_value\n * @param {1 | -1} [d]\n * @returns {number}\n */\nexport function update_pre_store(store, store_value, d = 1) {\n\tconst value = store_value + d;\n\tstore.set(value);\n\treturn value;\n}\n\n/**\n * Called inside prop getters to communicate that the prop is a store binding\n */\nexport function mark_store_binding() {\n\tis_store_binding = true;\n}\n\n/**\n * Returns a tuple that indicates whether `fn()` reads a prop that is a store binding.\n * Used to prevent `binding_property_non_reactive` validation false positives and\n * ensure that these props are treated as mutable even in runes mode\n * @template T\n * @param {() => T} fn\n * @returns {[T, boolean]}\n */\nexport function capture_store_binding(fn) {\n\tvar previous_is_store_binding = is_store_binding;\n\n\ttry {\n\t\tis_store_binding = false;\n\t\treturn [fn(), is_store_binding];\n\t} finally {\n\t\tis_store_binding = previous_is_store_binding;\n\t}\n}\n","/** @import { Source } from './types.js' */\nimport { DEV } from 'esm-env';\nimport {\n\tPROPS_IS_BINDABLE,\n\tPROPS_IS_IMMUTABLE,\n\tPROPS_IS_LAZY_INITIAL,\n\tPROPS_IS_RUNES,\n\tPROPS_IS_UPDATED\n} from '../../../constants.js';\nimport { get_descriptor, is_function } from '../../shared/utils.js';\nimport { mutable_source, set, source } from './sources.js';\nimport { derived, derived_safe_equal } from './deriveds.js';\nimport {\n\tactive_effect,\n\tget,\n\tis_signals_recorded,\n\tset_active_effect,\n\tuntrack,\n\tupdate\n} from '../runtime.js';\nimport { safe_equals } from './equality.js';\nimport * as e from '../errors.js';\nimport { BRANCH_EFFECT, LEGACY_DERIVED_PROP, ROOT_EFFECT } from '../constants.js';\nimport { proxy } from '../proxy.js';\nimport { capture_store_binding } from './store.js';\n\n/**\n * @param {((value?: number) => number)} fn\n * @param {1 | -1} [d]\n * @returns {number}\n */\nexport function update_prop(fn, d = 1) {\n\tconst value = fn();\n\tfn(value + d);\n\treturn value;\n}\n\n/**\n * @param {((value?: number) => number)} fn\n * @param {1 | -1} [d]\n * @returns {number}\n */\nexport function update_pre_prop(fn, d = 1) {\n\tconst value = fn() + d;\n\tfn(value);\n\treturn value;\n}\n\n/**\n * The proxy handler for rest props (i.e. `const { x, ...rest } = $props()`).\n * Is passed the full `$$props` object and excludes the named props.\n * @type {ProxyHandler<{ props: Record<string | symbol, unknown>, exclude: Array<string | symbol>, name?: string }>}}\n */\nconst rest_props_handler = {\n\tget(target, key) {\n\t\tif (target.exclude.includes(key)) return;\n\t\treturn target.props[key];\n\t},\n\tset(target, key) {\n\t\tif (DEV) {\n\t\t\t// TODO should this happen in prod too?\n\t\t\te.props_rest_readonly(`${target.name}.${String(key)}`);\n\t\t}\n\n\t\treturn false;\n\t},\n\tgetOwnPropertyDescriptor(target, key) {\n\t\tif (target.exclude.includes(key)) return;\n\t\tif (key in target.props) {\n\t\t\treturn {\n\t\t\t\tenumerable: true,\n\t\t\t\tconfigurable: true,\n\t\t\t\tvalue: target.props[key]\n\t\t\t};\n\t\t}\n\t},\n\thas(target, key) {\n\t\tif (target.exclude.includes(key)) return false;\n\t\treturn key in target.props;\n\t},\n\townKeys(target) {\n\t\treturn Reflect.ownKeys(target.props).filter((key) => !target.exclude.includes(key));\n\t}\n};\n\n/**\n * @param {Record<string, unknown>} props\n * @param {string[]} exclude\n * @param {string} [name]\n * @returns {Record<string, unknown>}\n */\n/*#__NO_SIDE_EFFECTS__*/\nexport function rest_props(props, exclude, name) {\n\treturn new Proxy(\n\t\tDEV ? { props, exclude, name, other: {}, to_proxy: [] } : { props, exclude },\n\t\trest_props_handler\n\t);\n}\n\n/**\n * The proxy handler for legacy $$restProps and $$props\n * @type {ProxyHandler<{ props: Record<string | symbol, unknown>, exclude: Array<string | symbol>, special: Record<string | symbol, (v?: unknown) => unknown>, version: Source<number> }>}}\n */\nconst legacy_rest_props_handler = {\n\tget(target, key) {\n\t\tif (target.exclude.includes(key)) return;\n\t\tget(target.version);\n\t\treturn key in target.special ? target.special[key]() : target.props[key];\n\t},\n\tset(target, key, value) {\n\t\tif (!(key in target.special)) {\n\t\t\t// Handle props that can temporarily get out of sync with the parent\n\t\t\t/** @type {Record<string, (v?: unknown) => unknown>} */\n\t\t\ttarget.special[key] = prop(\n\t\t\t\t{\n\t\t\t\t\tget [key]() {\n\t\t\t\t\t\treturn target.props[key];\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t/** @type {string} */ (key),\n\t\t\t\tPROPS_IS_UPDATED\n\t\t\t);\n\t\t}\n\n\t\ttarget.special[key](value);\n\t\tupdate(target.version); // $$props is coarse-grained: when $$props.x is updated, usages of $$props.y etc are also rerun\n\t\treturn true;\n\t},\n\tgetOwnPropertyDescriptor(target, key) {\n\t\tif (target.exclude.includes(key)) return;\n\t\tif (key in target.props) {\n\t\t\treturn {\n\t\t\t\tenumerable: true,\n\t\t\t\tconfigurable: true,\n\t\t\t\tvalue: target.props[key]\n\t\t\t};\n\t\t}\n\t},\n\tdeleteProperty(target, key) {\n\t\t// Svelte 4 allowed for deletions on $$restProps\n\t\tif (target.exclude.includes(key)) return true;\n\t\ttarget.exclude.push(key);\n\t\tupdate(target.version);\n\t\treturn true;\n\t},\n\thas(target, key) {\n\t\tif (target.exclude.includes(key)) return false;\n\t\treturn key in target.props;\n\t},\n\townKeys(target) {\n\t\treturn Reflect.ownKeys(target.props).filter((key) => !target.exclude.includes(key));\n\t}\n};\n\n/**\n * @param {Record<string, unknown>} props\n * @param {string[]} exclude\n * @returns {Record<string, unknown>}\n */\nexport function legacy_rest_props(props, exclude) {\n\treturn new Proxy({ props, exclude, special: {}, version: source(0) }, legacy_rest_props_handler);\n}\n\n/**\n * The proxy handler for spread props. Handles the incoming array of props\n * that looks like `() => { dynamic: props }, { static: prop }, ..` and wraps\n * them so that the whole thing is passed to the component as the `$$props` argument.\n * @template {Record<string | symbol, unknown>} T\n * @type {ProxyHandler<{ props: Array<T | (() => T)> }>}}\n */\nconst spread_props_handler = {\n\tget(target, key) {\n\t\tlet i = target.props.length;\n\t\twhile (i--) {\n\t\t\tlet p = target.props[i];\n\t\t\tif (is_function(p)) p = p();\n\t\t\tif (typeof p === 'object' && p !== null && key in p) return p[key];\n\t\t}\n\t},\n\tset(target, key, value) {\n\t\tlet i = target.props.length;\n\t\twhile (i--) {\n\t\t\tlet p = target.props[i];\n\t\t\tif (is_function(p)) p = p();\n\t\t\tconst desc = get_descriptor(p, key);\n\t\t\tif (desc && desc.set) {\n\t\t\t\tdesc.set(value);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t},\n\tgetOwnPropertyDescriptor(target, key) {\n\t\tlet i = target.props.length;\n\t\twhile (i--) {\n\t\t\tlet p = target.props[i];\n\t\t\tif (is_function(p)) p = p();\n\t\t\tif (typeof p === 'object' && p !== null && key in p) {\n\t\t\t\tconst descriptor = get_descriptor(p, key);\n\t\t\t\tif (descriptor && !descriptor.configurable) {\n\t\t\t\t\t// Prevent a \"Non-configurability Report Error\": The target is an array, it does\n\t\t\t\t\t// not actually contain this property. If it is now described as non-configurable,\n\t\t\t\t\t// the proxy throws a validation error. Setting it to true avoids that.\n\t\t\t\t\tdescriptor.configurable = true;\n\t\t\t\t}\n\t\t\t\treturn descriptor;\n\t\t\t}\n\t\t}\n\t},\n\thas(target, key) {\n\t\tfor (let p of target.props) {\n\t\t\tif (is_function(p)) p = p();\n\t\t\tif (p != null && key in p) return true;\n\t\t}\n\n\t\treturn false;\n\t},\n\townKeys(target) {\n\t\t/** @type {Array<string | symbol>} */\n\t\tconst keys = [];\n\n\t\tfor (let p of target.props) {\n\t\t\tif (is_function(p)) p = p();\n\t\t\tfor (const key in p) {\n\t\t\t\tif (!keys.includes(key)) keys.push(key);\n\t\t\t}\n\t\t}\n\n\t\treturn keys;\n\t}\n};\n\n/**\n * @param {Array<Record<string, unknown> | (() => Record<string, unknown>)>} props\n * @returns {any}\n */\nexport function spread_props(...props) {\n\treturn new Proxy({ props }, spread_props_handler);\n}\n\n/**\n * @template T\n * @param {() => T} fn\n * @returns {T}\n */\nfunction with_parent_branch(fn) {\n\tvar effect = active_effect;\n\tvar previous_effect = active_effect;\n\n\twhile (effect !== null && (effect.f & (BRANCH_EFFECT | ROOT_EFFECT)) === 0) {\n\t\teffect = effect.parent;\n\t}\n\ttry {\n\t\tset_active_effect(effect);\n\t\treturn fn();\n\t} finally {\n\t\tset_active_effect(previous_effect);\n\t}\n}\n\n/**\n * This function is responsible for synchronizing a possibly bound prop with the inner component state.\n * It is used whenever the compiler sees that the component writes to the prop, or when it has a default prop_value.\n * @template V\n * @param {Record<string, unknown>} props\n * @param {string} key\n * @param {number} flags\n * @param {V | (() => V)} [fallback]\n * @returns {(() => V | ((arg: V) => V) | ((arg: V, mutation: boolean) => V))}\n */\nexport function prop(props, key, flags, fallback) {\n\tvar immutable = (flags & PROPS_IS_IMMUTABLE) !== 0;\n\tvar runes = (flags & PROPS_IS_RUNES) !== 0;\n\tvar bindable = (flags & PROPS_IS_BINDABLE) !== 0;\n\tvar lazy = (flags & PROPS_IS_LAZY_INITIAL) !== 0;\n\tvar is_store_sub = false;\n\tvar prop_value;\n\n\tif (bindable) {\n\t\t[prop_value, is_store_sub] = capture_store_binding(() => /** @type {V} */ (props[key]));\n\t} else {\n\t\tprop_value = /** @type {V} */ (props[key]);\n\t}\n\tvar setter = get_descriptor(props, key)?.set;\n\n\tvar fallback_value = /** @type {V} */ (fallback);\n\tvar fallback_dirty = true;\n\tvar fallback_used = false;\n\n\tvar get_fallback = () => {\n\t\tfallback_used = true;\n\t\tif (fallback_dirty) {\n\t\t\tfallback_dirty = false;\n\t\t\tif (lazy) {\n\t\t\t\tfallback_value = untrack(/** @type {() => V} */ (fallback));\n\t\t\t} else {\n\t\t\t\tfallback_value = /** @type {V} */ (fallback);\n\t\t\t}\n\t\t}\n\n\t\treturn fallback_value;\n\t};\n\n\tif (prop_value === undefined && fallback !== undefined) {\n\t\tif (setter && runes) {\n\t\t\te.props_invalid_value(key);\n\t\t}\n\n\t\tprop_value = get_fallback();\n\t\tif (setter) setter(prop_value);\n\t}\n\n\t/** @type {() => V} */\n\tvar getter;\n\tif (runes) {\n\t\tgetter = () => {\n\t\t\tvar value = /** @type {V} */ (props[key]);\n\t\t\tif (value === undefined) return get_fallback();\n\t\t\tfallback_dirty = true;\n\t\t\tfallback_used = false;\n\t\t\treturn value;\n\t\t};\n\t} else {\n\t\t// Svelte 4 did not trigger updates when a primitive value was updated to the same value.\n\t\t// Replicate that behavior through using a derived\n\t\tvar derived_getter = with_parent_branch(() =>\n\t\t\t(immutable ? derived : derived_safe_equal)(() => /** @type {V} */ (props[key]))\n\t\t);\n\t\tderived_getter.f |= LEGACY_DERIVED_PROP;\n\t\tgetter = () => {\n\t\t\tvar value = get(derived_getter);\n\t\t\tif (value !== undefined) fallback_value = /** @type {V} */ (undefined);\n\t\t\treturn value === undefined ? fallback_value : value;\n\t\t};\n\t}\n\n\t// easy mode  prop is never written to\n\tif ((flags & PROPS_IS_UPDATED) === 0) {\n\t\treturn getter;\n\t}\n\n\t// intermediate mode  prop is written to, but the parent component had\n\t// `bind:foo` which means we can just call `$$props.foo = value` directly\n\tif (setter) {\n\t\tvar legacy_parent = props.$$legacy;\n\t\treturn function (/** @type {any} */ value, /** @type {boolean} */ mutation) {\n\t\t\tif (arguments.length > 0) {\n\t\t\t\t// We don't want to notify if the value was mutated and the parent is in runes mode.\n\t\t\t\t// In that case the state proxy (if it exists) should take care of the notification.\n\t\t\t\t// If the parent is not in runes mode, we need to notify on mutation, too, that the prop\n\t\t\t\t// has changed because the parent will not be able to detect the change otherwise.\n\t\t\t\tif (!runes || !mutation || legacy_parent || is_store_sub) {\n\t\t\t\t\t/** @type {Function} */ (setter)(mutation ? getter() : value);\n\t\t\t\t}\n\t\t\t\treturn value;\n\t\t\t} else {\n\t\t\t\treturn getter();\n\t\t\t}\n\t\t};\n\t}\n\n\t// hard mode. this is where it gets ugly  the value in the child should\n\t// synchronize with the parent, but it should also be possible to temporarily\n\t// set the value to something else locally.\n\tvar from_child = false;\n\tvar was_from_child = false;\n\n\t// The derived returns the current value. The underlying mutable\n\t// source is written to from various places to persist this value.\n\tvar inner_current_value = mutable_source(prop_value);\n\tvar current_value = with_parent_branch(() =>\n\t\tderived(() => {\n\t\t\tvar parent_value = getter();\n\t\t\tvar child_value = get(inner_current_value);\n\n\t\t\tif (from_child) {\n\t\t\t\tfrom_child = false;\n\t\t\t\twas_from_child = true;\n\t\t\t\treturn child_value;\n\t\t\t}\n\n\t\t\twas_from_child = false;\n\t\t\treturn (inner_current_value.v = parent_value);\n\t\t})\n\t);\n\n\tif (!immutable) current_value.equals = safe_equals;\n\n\treturn function (/** @type {any} */ value, /** @type {boolean} */ mutation) {\n\t\t// legacy nonsense  need to ensure the source is invalidated when necessary\n\t\t// also needed for when handling inspect logic so we can inspect the correct source signal\n\t\tif (is_signals_recorded) {\n\t\t\t// set this so that we don't reset to the parent value if `d`\n\t\t\t// is invalidated because of `invalidate_inner_signals` (rather\n\t\t\t// than because the parent or child value changed)\n\t\t\tfrom_child = was_from_child;\n\t\t\t// invoke getters so that signals are picked up by `invalidate_inner_signals`\n\t\t\tgetter();\n\t\t\tget(inner_current_value);\n\t\t}\n\n\t\tif (arguments.length > 0) {\n\t\t\tconst new_value = mutation ? get(current_value) : runes && bindable ? proxy(value) : value;\n\n\t\t\tif (!current_value.equals(new_value)) {\n\t\t\t\tfrom_child = true;\n\t\t\t\tset(inner_current_value, new_value);\n\t\t\t\t// To ensure the fallback value is consistent when used with proxies, we\n\t\t\t\t// update the local fallback_value, but only if the fallback is actively used\n\t\t\t\tif (fallback_used && fallback_value !== undefined) {\n\t\t\t\t\tfallback_value = new_value;\n\t\t\t\t}\n\t\t\t\tuntrack(() => get(current_value)); // force a synchronisation immediately\n\t\t\t}\n\n\t\t\treturn value;\n\t\t}\n\t\treturn get(current_value);\n\t};\n}\n","export function isFunction(value) {\n    return typeof value === \"function\";\n}\nexport function isObject(value) {\n    return value !== null && typeof value === \"object\";\n}\n","import { isFunction, isObject } from \"../utils/is.js\";\nconst BoxSymbol = Symbol(\"box\");\nconst isWritableSymbol = Symbol(\"is-writable\");\n/**\n * @returns Whether the value is a Box\n *\n * @see {@link https://runed.dev/docs/functions/box}\n */\nfunction isBox(value) {\n    return isObject(value) && BoxSymbol in value;\n}\n/**\n * @returns Whether the value is a WritableBox\n *\n * @see {@link https://runed.dev/docs/functions/box}\n */\nfunction isWritableBox(value) {\n    return box.isBox(value) && isWritableSymbol in value;\n}\nexport function box(initialValue) {\n    let current = $state(initialValue);\n    return {\n        [BoxSymbol]: true,\n        [isWritableSymbol]: true,\n        get current() {\n            return current;\n        },\n        set current(v) {\n            current = v;\n        }\n    };\n}\nfunction boxWith(getter, setter) {\n    const derived = $derived.by(getter);\n    if (setter) {\n        return {\n            [BoxSymbol]: true,\n            [isWritableSymbol]: true,\n            get current() {\n                return derived;\n            },\n            set current(v) {\n                setter(v);\n            }\n        };\n    }\n    return {\n        [BoxSymbol]: true,\n        get current() {\n            return getter();\n        }\n    };\n}\nfunction boxFrom(value) {\n    if (box.isBox(value))\n        return value;\n    if (isFunction(value))\n        return box.with(value);\n    return box(value);\n}\n/**\n * Function that gets an object of boxes, and returns an object of reactive values\n *\n * @example\n * const count = box(0)\n * const flat = box.flatten({ count, double: box.with(() => count.current) })\n * // type of flat is { count: number, readonly double: number }\n *\n * @see {@link https://runed.dev/docs/functions/box}\n */\nfunction boxFlatten(boxes) {\n    return Object.entries(boxes).reduce((acc, [key, b]) => {\n        if (!box.isBox(b)) {\n            return Object.assign(acc, { [key]: b });\n        }\n        if (box.isWritableBox(b)) {\n            Object.defineProperty(acc, key, {\n                get() {\n                    return b.current;\n                },\n                // eslint-disable-next-line ts/no-explicit-any\n                set(v) {\n                    b.current = v;\n                }\n            });\n        }\n        else {\n            Object.defineProperty(acc, key, {\n                get() {\n                    return b.current;\n                }\n            });\n        }\n        return acc;\n    }, {});\n}\n/**\n * Function that converts a box to a readonly box.\n *\n * @example\n * const count = box(0) // WritableBox<number>\n * const countReadonly = box.readonly(count) // ReadableBox<number>\n *\n * @see {@link https://runed.dev/docs/functions/box}\n */\nfunction toReadonlyBox(b) {\n    if (!box.isWritableBox(b))\n        return b;\n    return {\n        [BoxSymbol]: true,\n        get current() {\n            return b.current;\n        }\n    };\n}\nbox.from = boxFrom;\nbox.with = boxWith;\nbox.flatten = boxFlatten;\nbox.readonly = toReadonlyBox;\nbox.isBox = isBox;\nbox.isWritableBox = isWritableBox;\n","/**\n * Composes event handlers into a single function that can be called with an event.\n * If the previous handler cancels the event using `event.preventDefault()`, the handlers\n * that follow will not be called.\n */\nexport function composeHandlers(...handlers) {\n    return function (e) {\n        for (const handler of handlers) {\n            if (!handler)\n                continue;\n            if (e.defaultPrevented)\n                return;\n            if (typeof handler === \"function\") {\n                handler.call(this, e);\n            }\n            else {\n                handler.current?.call(this, e);\n            }\n        }\n    };\n}\n","// http://www.w3.org/TR/CSS21/grammar.html\n// https://github.com/visionmedia/css-parse/pull/49#issuecomment-30088027\nvar COMMENT_REGEX = /\\/\\*[^*]*\\*+([^/*][^*]*\\*+)*\\//g;\n\nvar NEWLINE_REGEX = /\\n/g;\nvar WHITESPACE_REGEX = /^\\s*/;\n\n// declaration\nvar PROPERTY_REGEX = /^(\\*?[-#/*\\\\\\w]+(\\[[0-9a-z_-]+\\])?)\\s*/;\nvar COLON_REGEX = /^:\\s*/;\nvar VALUE_REGEX = /^((?:'(?:\\\\'|.)*?'|\"(?:\\\\\"|.)*?\"|\\([^)]*?\\)|[^};])+)/;\nvar SEMICOLON_REGEX = /^[;\\s]*/;\n\n// https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/String/Trim#Polyfill\nvar TRIM_REGEX = /^\\s+|\\s+$/g;\n\n// strings\nvar NEWLINE = '\\n';\nvar FORWARD_SLASH = '/';\nvar ASTERISK = '*';\nvar EMPTY_STRING = '';\n\n// types\nvar TYPE_COMMENT = 'comment';\nvar TYPE_DECLARATION = 'declaration';\n\n/**\n * @param {String} style\n * @param {Object} [options]\n * @return {Object[]}\n * @throws {TypeError}\n * @throws {Error}\n */\nmodule.exports = function (style, options) {\n  if (typeof style !== 'string') {\n    throw new TypeError('First argument must be a string');\n  }\n\n  if (!style) return [];\n\n  options = options || {};\n\n  /**\n   * Positional.\n   */\n  var lineno = 1;\n  var column = 1;\n\n  /**\n   * Update lineno and column based on `str`.\n   *\n   * @param {String} str\n   */\n  function updatePosition(str) {\n    var lines = str.match(NEWLINE_REGEX);\n    if (lines) lineno += lines.length;\n    var i = str.lastIndexOf(NEWLINE);\n    column = ~i ? str.length - i : column + str.length;\n  }\n\n  /**\n   * Mark position and patch `node.position`.\n   *\n   * @return {Function}\n   */\n  function position() {\n    var start = { line: lineno, column: column };\n    return function (node) {\n      node.position = new Position(start);\n      whitespace();\n      return node;\n    };\n  }\n\n  /**\n   * Store position information for a node.\n   *\n   * @constructor\n   * @property {Object} start\n   * @property {Object} end\n   * @property {undefined|String} source\n   */\n  function Position(start) {\n    this.start = start;\n    this.end = { line: lineno, column: column };\n    this.source = options.source;\n  }\n\n  /**\n   * Non-enumerable source string.\n   */\n  Position.prototype.content = style;\n\n  var errorsList = [];\n\n  /**\n   * Error `msg`.\n   *\n   * @param {String} msg\n   * @throws {Error}\n   */\n  function error(msg) {\n    var err = new Error(\n      options.source + ':' + lineno + ':' + column + ': ' + msg\n    );\n    err.reason = msg;\n    err.filename = options.source;\n    err.line = lineno;\n    err.column = column;\n    err.source = style;\n\n    if (options.silent) {\n      errorsList.push(err);\n    } else {\n      throw err;\n    }\n  }\n\n  /**\n   * Match `re` and return captures.\n   *\n   * @param {RegExp} re\n   * @return {undefined|Array}\n   */\n  function match(re) {\n    var m = re.exec(style);\n    if (!m) return;\n    var str = m[0];\n    updatePosition(str);\n    style = style.slice(str.length);\n    return m;\n  }\n\n  /**\n   * Parse whitespace.\n   */\n  function whitespace() {\n    match(WHITESPACE_REGEX);\n  }\n\n  /**\n   * Parse comments.\n   *\n   * @param {Object[]} [rules]\n   * @return {Object[]}\n   */\n  function comments(rules) {\n    var c;\n    rules = rules || [];\n    while ((c = comment())) {\n      if (c !== false) {\n        rules.push(c);\n      }\n    }\n    return rules;\n  }\n\n  /**\n   * Parse comment.\n   *\n   * @return {Object}\n   * @throws {Error}\n   */\n  function comment() {\n    var pos = position();\n    if (FORWARD_SLASH != style.charAt(0) || ASTERISK != style.charAt(1)) return;\n\n    var i = 2;\n    while (\n      EMPTY_STRING != style.charAt(i) &&\n      (ASTERISK != style.charAt(i) || FORWARD_SLASH != style.charAt(i + 1))\n    ) {\n      ++i;\n    }\n    i += 2;\n\n    if (EMPTY_STRING === style.charAt(i - 1)) {\n      return error('End of comment missing');\n    }\n\n    var str = style.slice(2, i - 2);\n    column += 2;\n    updatePosition(str);\n    style = style.slice(i);\n    column += 2;\n\n    return pos({\n      type: TYPE_COMMENT,\n      comment: str\n    });\n  }\n\n  /**\n   * Parse declaration.\n   *\n   * @return {Object}\n   * @throws {Error}\n   */\n  function declaration() {\n    var pos = position();\n\n    // prop\n    var prop = match(PROPERTY_REGEX);\n    if (!prop) return;\n    comment();\n\n    // :\n    if (!match(COLON_REGEX)) return error(\"property missing ':'\");\n\n    // val\n    var val = match(VALUE_REGEX);\n\n    var ret = pos({\n      type: TYPE_DECLARATION,\n      property: trim(prop[0].replace(COMMENT_REGEX, EMPTY_STRING)),\n      value: val\n        ? trim(val[0].replace(COMMENT_REGEX, EMPTY_STRING))\n        : EMPTY_STRING\n    });\n\n    // ;\n    match(SEMICOLON_REGEX);\n\n    return ret;\n  }\n\n  /**\n   * Parse declarations.\n   *\n   * @return {Object[]}\n   */\n  function declarations() {\n    var decls = [];\n\n    comments(decls);\n\n    // declarations\n    var decl;\n    while ((decl = declaration())) {\n      if (decl !== false) {\n        decls.push(decl);\n        comments(decls);\n      }\n    }\n\n    return decls;\n  }\n\n  whitespace();\n  return declarations();\n};\n\n/**\n * Trim `str`.\n *\n * @param {String} str\n * @return {String}\n */\nfunction trim(str) {\n  return str ? str.replace(TRIM_REGEX, EMPTY_STRING) : EMPTY_STRING;\n}\n","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = StyleToObject;\nvar inline_style_parser_1 = __importDefault(require(\"inline-style-parser\"));\n/**\n * Parses inline style to object.\n *\n * @param style - Inline style.\n * @param iterator - Iterator.\n * @returns - Style object or null.\n *\n * @example Parsing inline style to object:\n *\n * ```js\n * import parse from 'style-to-object';\n * parse('line-height: 42;'); // { 'line-height': '42' }\n * ```\n */\nfunction StyleToObject(style, iterator) {\n    var styleObject = null;\n    if (!style || typeof style !== 'string') {\n        return styleObject;\n    }\n    var declarations = (0, inline_style_parser_1.default)(style);\n    var hasIterator = typeof iterator === 'function';\n    declarations.forEach(function (declaration) {\n        if (declaration.type !== 'declaration') {\n            return;\n        }\n        var property = declaration.property, value = declaration.value;\n        if (hasIterator) {\n            iterator(property, value, declaration);\n        }\n        else if (value) {\n            styleObject = styleObject || {};\n            styleObject[property] = value;\n        }\n    });\n    return styleObject;\n}\n//# sourceMappingURL=index.js.map","import StyleToObject from '../cjs/index.js';\n\n// ensure compatibility with rollup umd build\nexport default StyleToObject.default || StyleToObject;\n","const NUMBER_CHAR_RE = /\\d/;\nconst STR_SPLITTERS = [\"-\", \"_\", \"/\", \".\"];\nfunction isUppercase(char = \"\") {\n    if (NUMBER_CHAR_RE.test(char))\n        return undefined;\n    return char !== char.toLowerCase();\n}\nfunction splitByCase(str) {\n    const parts = [];\n    let buff = \"\";\n    let previousUpper;\n    let previousSplitter;\n    for (const char of str) {\n        // Splitter\n        const isSplitter = STR_SPLITTERS.includes(char);\n        if (isSplitter === true) {\n            parts.push(buff);\n            buff = \"\";\n            previousUpper = undefined;\n            continue;\n        }\n        const isUpper = isUppercase(char);\n        if (previousSplitter === false) {\n            // Case rising edge\n            if (previousUpper === false && isUpper === true) {\n                parts.push(buff);\n                buff = char;\n                previousUpper = isUpper;\n                continue;\n            }\n            // Case falling edge\n            if (previousUpper === true && isUpper === false && buff.length > 1) {\n                const lastChar = buff.at(-1);\n                parts.push(buff.slice(0, Math.max(0, buff.length - 1)));\n                buff = lastChar + char;\n                previousUpper = isUpper;\n                continue;\n            }\n        }\n        // Normal char\n        buff += char;\n        previousUpper = isUpper;\n        previousSplitter = isSplitter;\n    }\n    parts.push(buff);\n    return parts;\n}\nexport function pascalCase(str) {\n    if (!str)\n        return \"\";\n    return splitByCase(str)\n        .map((p) => upperFirst(p))\n        .join(\"\");\n}\nexport function camelCase(str) {\n    return lowerFirst(pascalCase(str || \"\"));\n}\nexport function kebabCase(str) {\n    return str\n        ? splitByCase(str)\n            .map((p) => p.toLowerCase())\n            .join(\"-\")\n        : \"\";\n}\nfunction upperFirst(str) {\n    return str ? str[0].toUpperCase() + str.slice(1) : \"\";\n}\nfunction lowerFirst(str) {\n    return str ? str[0].toLowerCase() + str.slice(1) : \"\";\n}\n","import parse from \"style-to-object\";\nimport { camelCase, pascalCase } from \"./strings.js\";\nexport function cssToStyleObj(css) {\n    if (!css)\n        return {};\n    const styleObj = {};\n    function iterator(name, value) {\n        if (name.startsWith(\"-moz-\") ||\n            name.startsWith(\"-webkit-\") ||\n            name.startsWith(\"-ms-\") ||\n            name.startsWith(\"-o-\")) {\n            styleObj[pascalCase(name)] = value;\n            return;\n        }\n        if (name.startsWith(\"--\")) {\n            styleObj[name] = value;\n            return;\n        }\n        styleObj[camelCase(name)] = value;\n    }\n    parse(css, iterator);\n    return styleObj;\n}\n","/**\n * Executes an array of callback functions with the same arguments.\n * @template T The types of the arguments that the callback functions take.\n * @param callbacks array of callback functions to execute.\n * @returns A new function that executes all of the original callback functions with the same arguments.\n */\nexport function executeCallbacks(...callbacks) {\n    return (...args) => {\n        for (const callback of callbacks) {\n            if (typeof callback === \"function\") {\n                callback(...args);\n            }\n        }\n    };\n}\n","function r(e){var t,f,n=\"\";if(\"string\"==typeof e||\"number\"==typeof e)n+=e;else if(\"object\"==typeof e)if(Array.isArray(e)){var o=e.length;for(t=0;t<o;t++)e[t]&&(f=r(e[t]))&&(n&&(n+=\" \"),n+=f)}else for(f in e)e[f]&&(n&&(n+=\" \"),n+=f);return n}export function clsx(){for(var e,t,f=0,n=\"\",o=arguments.length;f<o;f++)(e=arguments[f])&&(t=r(e))&&(n&&(n+=\" \"),n+=t);return n}export default clsx;","function createParser(matcher, replacer) {\n    const regex = RegExp(matcher, \"g\");\n    return (str) => {\n        // throw an error if not a string\n        if (typeof str !== \"string\") {\n            throw new TypeError(`expected an argument of type string, but got ${typeof str}`);\n        }\n        // if no match between string and matcher\n        if (!str.match(regex))\n            return str;\n        // executes the replacer function for each match\n        return str.replace(regex, replacer);\n    };\n}\nconst camelToKebab = createParser(/[A-Z]/, (match) => `-${match.toLowerCase()}`);\nexport function styleToCSS(styleObj) {\n    if (!styleObj || typeof styleObj !== \"object\" || Array.isArray(styleObj)) {\n        throw new TypeError(`expected an argument of type object, but got ${typeof styleObj}`);\n    }\n    return Object.keys(styleObj)\n        .map((property) => `${camelToKebab(property)}: ${styleObj[property]};`)\n        .join(\"\\n\");\n}\n","import { styleToCSS } from \"./style-to-css.js\";\nexport function styleToString(style = {}) {\n    return styleToCSS(style).replace(\"\\n\", \" \");\n}\nexport const srOnlyStyles = {\n    position: \"absolute\",\n    width: \"1px\",\n    height: \"1px\",\n    padding: \"0\",\n    margin: \"-1px\",\n    overflow: \"hidden\",\n    clip: \"rect(0, 0, 0, 0)\",\n    whiteSpace: \"nowrap\",\n    borderWidth: \"0\",\n    transform: \"translateX(-100%)\"\n};\nexport const srOnlyStylesString = styleToString(srOnlyStyles);\n","/**\n * Modified from https://github.com/adobe/react-spectrum/blob/main/packages/%40react-aria/utils/src/mergeProps.ts (see NOTICE.txt for source)\n */\nimport { clsx } from \"clsx\";\nimport { composeHandlers } from \"./compose-handlers.js\";\nimport { cssToStyleObj } from \"./css-to-style-obj.js\";\nimport { executeCallbacks } from \"./execute-callbacks.js\";\nimport { styleToString } from \"./style.js\";\nfunction isEventHandler(key) {\n    // we check if the 3rd character is uppercase to avoid merging our own\n    // custom callbacks like `onValueChange` and strictly merge native event handlers\n    return key.length > 2 && key.startsWith(\"on\") && key[2] === key[2]?.toLowerCase();\n}\n/**\n * Given a list of prop objects, merges them into a single object.\n * - Automatically composes event handlers (e.g. `onclick`, `oninput`, etc.)\n * - Chains regular functions with the same name so they are called in order\n * - Merges class strings with `clsx`\n * - Merges style objects and converts them to strings\n * - Handles a bug with Svelte where setting the `hidden` attribute to `false` doesn't remove it\n * - Overrides other values with the last one\n */\nexport function mergeProps(...args) {\n    const result = { ...args[0] };\n    for (let i = 1; i < args.length; i++) {\n        const props = args[i];\n        for (const key in props) {\n            const a = result[key];\n            const b = props[key];\n            const aIsFunction = typeof a === \"function\";\n            const bIsFunction = typeof b === \"function\";\n            // compose event handlers\n            if (aIsFunction && typeof bIsFunction && isEventHandler(key)) {\n                // handle merging of event handlers\n                const aHandler = a;\n                const bHandler = b;\n                result[key] = composeHandlers(aHandler, bHandler);\n            }\n            else if (aIsFunction && bIsFunction) {\n                // chain non-event handler functions\n                result[key] = executeCallbacks(a, b);\n            }\n            else if (key === \"class\" && typeof a === \"string\" && typeof b === \"string\") {\n                // handle merging class strings\n                result[key] = clsx(a, b);\n            }\n            else if (key === \"style\") {\n                const aIsObject = typeof a === \"object\";\n                const bIsObject = typeof b === \"object\";\n                const aIsString = typeof a === \"string\";\n                const bIsString = typeof b === \"string\";\n                if (aIsObject && bIsObject) {\n                    // both are style objects, merge them\n                    result[key] = { ...a, ...b };\n                }\n                else if (aIsObject && bIsString) {\n                    // a is style object, b is string, convert b to style object and merge\n                    const parsedStyle = cssToStyleObj(b);\n                    result[key] = { ...a, ...parsedStyle };\n                }\n                else if (aIsString && bIsObject) {\n                    // a is string, b is style object, convert a to style object and merge\n                    const parsedStyle = cssToStyleObj(a);\n                    result[key] = { ...parsedStyle, ...b };\n                }\n                else if (aIsString && bIsString) {\n                    // both are strings, convert both to objects and merge\n                    const parsedStyleA = cssToStyleObj(a);\n                    const parsedStyleB = cssToStyleObj(b);\n                    result[key] = { ...parsedStyleA, ...parsedStyleB };\n                }\n                else if (aIsObject) {\n                    result[key] = a;\n                }\n                else if (bIsObject) {\n                    result[key] = b;\n                }\n            }\n            else {\n                // override other values\n                result[key] = b !== undefined ? b : a;\n            }\n        }\n    }\n    // convert style object to string\n    if (typeof result.style === \"object\") {\n        result.style = styleToString(result.style).replaceAll(\"\\n\", \" \");\n    }\n    // handle weird svelte bug where `hidden` is not removed when set to `false`\n    if (result.hidden !== true) {\n        result.hidden = undefined;\n    }\n    // handle weird svelte bug where `disabled` is not removed when set to `false`\n    if (result.disabled !== true) {\n        result.disabled = undefined;\n    }\n    return result;\n}\n","import { untrack } from \"svelte\";\n/**\n * Finds the node with that ID and sets it to the boxed node.\n * Reactive using `$effect` to ensure when the ID or condition changes,\n * an update is triggered and new node is found.\n */\nexport function useRefById({ id, ref, deps = () => true, onRefChange = () => { }, getRootNode = () => (typeof document !== \"undefined\" ? document : undefined) }) {\n    const dependencies = $derived.by(() => deps());\n    const rootNode = $derived.by(() => getRootNode());\n    $effect(() => {\n        // re-run when the ID changes.\n        id.current;\n        // re-run when the deps changes.\n        dependencies;\n        rootNode;\n        return untrack(() => {\n            const node = rootNode?.getElementById(id.current);\n            if (node) {\n                ref.current = node;\n            }\n            else {\n                ref.current = null;\n            }\n            onRefChange(ref.current);\n        });\n    });\n    $effect(() => {\n        return () => {\n            ref.current = null;\n            onRefChange(null);\n        };\n    });\n}\n","export function onDestroyEffect(fn) {\n    $effect(() => {\n        return () => {\n            fn();\n        };\n    });\n}\n","/**\n * A utility function that executes a callback after a specified number of milliseconds.\n */\nexport function afterSleep(ms, cb) {\n    setTimeout(cb, ms);\n}\n","import { tick } from \"svelte\";\nexport function afterTick(fn) {\n    tick().then(fn);\n}\n","export function getDataOpenClosed(condition) {\n    return condition ? \"open\" : \"closed\";\n}\nexport function getDataChecked(condition) {\n    return condition ? \"checked\" : \"unchecked\";\n}\nexport function getAriaDisabled(condition) {\n    return condition ? \"true\" : \"false\";\n}\nexport function getAriaReadonly(condition) {\n    return condition ? \"true\" : \"false\";\n}\nexport function getAriaExpanded(condition) {\n    return condition ? \"true\" : \"false\";\n}\nexport function getDataDisabled(condition) {\n    return condition ? \"\" : undefined;\n}\nexport function getAriaRequired(condition) {\n    return condition ? \"true\" : \"false\";\n}\nexport function getAriaSelected(condition) {\n    return condition ? \"true\" : \"false\";\n}\nexport function getAriaChecked(condition) {\n    if (condition === \"indeterminate\") {\n        return \"mixed\";\n    }\n    return condition ? \"true\" : \"false\";\n}\nexport function getAriaOrientation(orientation) {\n    return orientation;\n}\nexport function getAriaHidden(condition) {\n    return condition ? \"true\" : undefined;\n}\nexport function getAriaInvalid(condition) {\n    return condition ? \"true\" : undefined;\n}\nexport function getDataOrientation(orientation) {\n    return orientation;\n}\nexport function getDataInvalid(condition) {\n    return condition ? \"\" : undefined;\n}\nexport function getDataRequired(condition) {\n    return condition ? \"\" : undefined;\n}\nexport function getDataReadonly(condition) {\n    return condition ? \"\" : undefined;\n}\nexport function getDataSelected(condition) {\n    return condition ? \"\" : undefined;\n}\nexport function getDataUnavailable(condition) {\n    return condition ? \"\" : undefined;\n}\nexport function getHidden(condition) {\n    return condition ? true : undefined;\n}\nexport function getDisabled(condition) {\n    return condition ? true : undefined;\n}\nexport function getAriaPressed(condition) {\n    return condition ? \"true\" : \"false\";\n}\nexport function getRequired(condition) {\n    return condition ? true : undefined;\n}\n","export const ALT = \"Alt\";\nexport const ARROW_DOWN = \"ArrowDown\";\nexport const ARROW_LEFT = \"ArrowLeft\";\nexport const ARROW_RIGHT = \"ArrowRight\";\nexport const ARROW_UP = \"ArrowUp\";\nexport const BACKSPACE = \"Backspace\";\nexport const CAPS_LOCK = \"CapsLock\";\nexport const CONTROL = \"Control\";\nexport const DELETE = \"Delete\";\nexport const END = \"End\";\nexport const ENTER = \"Enter\";\nexport const ESCAPE = \"Escape\";\nexport const F1 = \"F1\";\nexport const F10 = \"F10\";\nexport const F11 = \"F11\";\nexport const F12 = \"F12\";\nexport const F2 = \"F2\";\nexport const F3 = \"F3\";\nexport const F4 = \"F4\";\nexport const F5 = \"F5\";\nexport const F6 = \"F6\";\nexport const F7 = \"F7\";\nexport const F8 = \"F8\";\nexport const F9 = \"F9\";\nexport const HOME = \"Home\";\nexport const META = \"Meta\";\nexport const PAGE_DOWN = \"PageDown\";\nexport const PAGE_UP = \"PageUp\";\nexport const SHIFT = \"Shift\";\nexport const SPACE = \" \";\nexport const TAB = \"Tab\";\nexport const CTRL = \"Control\";\nexport const ASTERISK = \"*\";\nexport const a = \"a\";\nexport const P = \"P\";\nexport const A = \"A\";\nexport const p = \"p\";\nexport const n = \"n\";\nexport const j = \"j\";\nexport const k = \"k\";\n","/**\n * Detects the text direction in the element.\n * @returns {Direction} The text direction ('ltr' for left-to-right or 'rtl' for right-to-left).\n */\nexport function getElemDirection(elem) {\n    const style = window.getComputedStyle(elem);\n    const direction = style.getPropertyValue(\"direction\");\n    return direction;\n}\n","import { kbd } from \"./kbd.js\";\nexport const FIRST_KEYS = [kbd.ARROW_DOWN, kbd.PAGE_UP, kbd.HOME];\nexport const LAST_KEYS = [kbd.ARROW_UP, kbd.PAGE_DOWN, kbd.END];\nexport const FIRST_LAST_KEYS = [...FIRST_KEYS, ...LAST_KEYS];\nexport const SELECTION_KEYS = [kbd.SPACE, kbd.ENTER];\n/**\n * A utility function that returns the next key based on the direction and orientation.\n */\nexport function getNextKey(dir = \"ltr\", orientation = \"horizontal\") {\n    return {\n        horizontal: dir === \"rtl\" ? kbd.ARROW_LEFT : kbd.ARROW_RIGHT,\n        vertical: kbd.ARROW_DOWN,\n    }[orientation];\n}\n/**\n * A utility function that returns the previous key based on the direction and orientation.\n */\nexport function getPrevKey(dir = \"ltr\", orientation = \"horizontal\") {\n    return {\n        horizontal: dir === \"rtl\" ? kbd.ARROW_RIGHT : kbd.ARROW_LEFT,\n        vertical: kbd.ARROW_UP,\n    }[orientation];\n}\n/**\n * A utility function that returns the next and previous keys based on the direction\n * and orientation.\n */\nexport function getDirectionalKeys(dir = \"ltr\", orientation = \"horizontal\") {\n    if (![\"ltr\", \"rtl\"].includes(dir))\n        dir = \"ltr\";\n    if (![\"horizontal\", \"vertical\"].includes(orientation))\n        orientation = \"horizontal\";\n    return {\n        nextKey: getNextKey(dir, orientation),\n        prevKey: getPrevKey(dir, orientation),\n    };\n}\n","export const isBrowser = typeof document !== \"undefined\";\nexport const isIOS = getIsIOS();\nfunction getIsIOS() {\n    return (isBrowser &&\n        window?.navigator?.userAgent &&\n        // eslint-disable-next-line regexp/no-unused-capturing-group\n        (/iP(ad|hone|od)/.test(window.navigator.userAgent) ||\n            // The new iPad Pro Gen3 does not identify itself as iPad, but as Macintosh.\n            (window?.navigator?.maxTouchPoints > 2 &&\n                /iPad|Macintosh/.test(window?.navigator.userAgent))));\n}\nexport function isFunction(value) {\n    return typeof value === \"function\";\n}\nexport function isHTMLElement(element) {\n    return element instanceof HTMLElement;\n}\nexport function isElement(element) {\n    return element instanceof Element;\n}\nexport function isElementOrSVGElement(element) {\n    return element instanceof Element || element instanceof SVGElement;\n}\nexport function isNumberString(value) {\n    return !Number.isNaN(Number(value)) && !Number.isNaN(Number.parseFloat(value));\n}\nexport function isNull(value) {\n    return value === null;\n}\nexport function isTouch(e) {\n    return e.pointerType === \"touch\";\n}\nexport function isFocusVisible(element) {\n    return element.matches(\":focus-visible\");\n}\nexport function isNotNull(value) {\n    return value !== null;\n}\n/**\n * Determines if the provided object is a valid `HTMLInputElement` with\n * a `select` method available.\n */\nexport function isSelectableInput(element) {\n    return element instanceof HTMLInputElement && \"select\" in element;\n}\n/**\n * Given a node, determine if it is hidden by walking up the\n * DOM tree until we hit the `stopAt` node (exclusive), if provided)\n * otherwise we stop at the document root.\n */\nexport function isElementHidden(node, stopAt) {\n    if (getComputedStyle(node).visibility === \"hidden\")\n        return true;\n    while (node) {\n        // we stop at `upTo` (excluding it)\n        if (stopAt !== undefined && node === stopAt)\n            return false;\n        if (getComputedStyle(node).display === \"none\")\n            return true;\n        node = node.parentElement;\n    }\n    return false;\n}\n","import { box } from \"svelte-toolbelt\";\nimport { getElemDirection } from \"./locale.js\";\nimport { getDirectionalKeys } from \"./get-directional-keys.js\";\nimport { kbd } from \"./kbd.js\";\nimport { isBrowser } from \"./is.js\";\nexport function useRovingFocus(props) {\n    const currentTabStopId = props.currentTabStopId\n        ? props.currentTabStopId\n        : box(null);\n    function getCandidateNodes() {\n        if (!isBrowser)\n            return [];\n        const node = document.getElementById(props.rootNodeId.current);\n        if (!node)\n            return [];\n        if (props.candidateSelector) {\n            const candidates = Array.from(node.querySelectorAll(props.candidateSelector));\n            return candidates;\n        }\n        else {\n            const candidates = Array.from(node.querySelectorAll(`[${props.candidateAttr}]:not([data-disabled])`));\n            return candidates;\n        }\n    }\n    function focusFirstCandidate() {\n        const items = getCandidateNodes();\n        if (!items.length)\n            return;\n        items[0]?.focus();\n    }\n    function handleKeydown(node, e, both = false) {\n        const rootNode = document.getElementById(props.rootNodeId.current);\n        if (!rootNode || !node)\n            return;\n        const items = getCandidateNodes();\n        if (!items.length)\n            return;\n        const currentIndex = items.indexOf(node);\n        const dir = getElemDirection(rootNode);\n        const { nextKey, prevKey } = getDirectionalKeys(dir, props.orientation.current);\n        const loop = props.loop.current;\n        const keyToIndex = {\n            [nextKey]: currentIndex + 1,\n            [prevKey]: currentIndex - 1,\n            [kbd.HOME]: 0,\n            [kbd.END]: items.length - 1,\n        };\n        if (both) {\n            const altNextKey = nextKey === kbd.ARROW_DOWN ? kbd.ARROW_RIGHT : kbd.ARROW_DOWN;\n            const altPrevKey = prevKey === kbd.ARROW_UP ? kbd.ARROW_LEFT : kbd.ARROW_UP;\n            keyToIndex[altNextKey] = currentIndex + 1;\n            keyToIndex[altPrevKey] = currentIndex - 1;\n        }\n        let itemIndex = keyToIndex[e.key];\n        if (itemIndex === undefined)\n            return;\n        e.preventDefault();\n        if (itemIndex < 0 && loop) {\n            itemIndex = items.length - 1;\n        }\n        else if (itemIndex === items.length && loop) {\n            itemIndex = 0;\n        }\n        const itemToFocus = items[itemIndex];\n        if (!itemToFocus)\n            return;\n        itemToFocus.focus();\n        currentTabStopId.current = itemToFocus.id;\n        props.onCandidateFocus?.(itemToFocus);\n        return itemToFocus;\n    }\n    function getTabIndex(node) {\n        const items = getCandidateNodes();\n        const anyActive = currentTabStopId.current !== null;\n        if (node && !anyActive && items[0] === node) {\n            currentTabStopId.current = node.id;\n            return 0;\n        }\n        else if (node?.id === currentTabStopId.current) {\n            return 0;\n        }\n        return -1;\n    }\n    return {\n        setCurrentTabStopId(id) {\n            currentTabStopId.current = id;\n        },\n        getTabIndex,\n        handleKeydown,\n        focusFirstCandidate,\n        currentTabStopId,\n    };\n}\n","import { getContext as getSvelteContext, hasContext, setContext as setSvelteContext } from \"svelte\";\nfunction setContext(key, value) {\n    return setSvelteContext(key, value);\n}\nfunction getContext(key, fallback) {\n    const trueKey = typeof key === \"symbol\" ? key : key;\n    const description = typeof key === \"symbol\" ? key.description : key;\n    if (!hasContext(trueKey)) {\n        if (fallback === undefined) {\n            throw new Error(`Missing context dependency: ${description} and no fallback was provided.`);\n        }\n        return fallback;\n    }\n    return getSvelteContext(key);\n}\nfunction getSymbolDescription(providerComponentName, contextName) {\n    if (contextName !== undefined)\n        return contextName;\n    if (typeof providerComponentName === \"string\" && contextName === undefined) {\n        return `${providerComponentName}Context`;\n    }\n    else if (Array.isArray(providerComponentName) && contextName === undefined) {\n        return `${providerComponentName[0]}Context`;\n    }\n    else {\n        if (contextName !== undefined)\n            return contextName;\n        return `${providerComponentName}Context`;\n    }\n}\nexport function createContext(providerComponentName, contextName, useSymbol = true) {\n    const symbolDescription = getSymbolDescription(providerComponentName, contextName);\n    const symbol = Symbol.for(`bits-ui.${symbolDescription}`);\n    const key = symbolDescription;\n    function getCtx(fallback) {\n        const context = getContext(useSymbol ? symbol : key, fallback);\n        if (context === undefined) {\n            throw new Error(`Context \\`${symbolDescription}\\` not found. Component must be used within ${Array.isArray(providerComponentName)\n                ? `one of the following components: ${providerComponentName.join(\", \")}`\n                : `\\`${providerComponentName}\\``}`);\n        }\n        // eslint-disable-next-line ts/no-explicit-any\n        if (context === null)\n            return context;\n        return context;\n    }\n    function setCtx(value) {\n        if (useSymbol) {\n            return setContext(symbol, value);\n        }\n        else {\n            return setContext(key, value);\n        }\n    }\n    return [setCtx, getCtx];\n}\n","let count = 0;\n/**\n * Generates a unique ID based on a global counter.\n */\nexport function useId(prefix = \"bits\") {\n    count++;\n    return `${prefix}-${count}`;\n}\n","/**\n * A no operation function (does nothing)\n */\nexport function noop() { }\n","import { box } from \"svelte-toolbelt\";\n/**\n * The `useStateMachine` function is a TypeScript function that creates a state machine and returns the\n * current state and a dispatch function to update the state based on events.\n * @param initialState - The `initialState` parameter is the initial state of the state machine. It\n * represents the starting point of the state machine's state.\n * @param machine - The `machine` parameter is an object that represents a state machine. It should\n * have keys that correspond to the possible states of the machine, and the values should be objects\n * that represent the possible events and their corresponding next states.\n * @returns The `useStateMachine` function returns an object with two properties: `state` and\n * `dispatch`.\n */\nexport function useStateMachine(initialState, machine) {\n    const state = box(initialState);\n    function reducer(event) {\n        // @ts-expect-error  state.value is keyof M\n        const nextState = machine[state.current][event];\n        return nextState ?? state.current;\n    }\n    const dispatch = (event) => {\n        state.current = reducer(event);\n    };\n    return {\n        state,\n        dispatch,\n    };\n}\n","import { untrack } from \"svelte\";\nexport function watch(box, callback, options = {}) {\n    let prev = $state(box.current);\n    let ranOnce = false;\n    const watchEffect = $effect.root(() => {\n        $effect.pre(() => {\n            if (prev === box.current || !options.immediate)\n                return;\n            if (options.once && ranOnce)\n                return;\n            callback(box.current, untrack(() => prev));\n            untrack(() => (prev = box.current));\n            ranOnce = true;\n        });\n        $effect(() => {\n            if (prev === box.current || options.immediate)\n                return;\n            if (options.once && ranOnce)\n                return;\n            callback(box.current, untrack(() => prev));\n            untrack(() => (prev = box.current));\n            ranOnce = true;\n        });\n    });\n    return watchEffect;\n}\n","import { afterTick } from \"svelte-toolbelt\";\nimport { useStateMachine } from \"../../../internal/use-state-machine.svelte.js\";\nimport { watch } from \"../../../internal/box.svelte.js\";\nexport function usePresence(present, id) {\n    let styles = $state({});\n    let prevAnimationNameState = $state(\"none\");\n    const initialState = present.current ? \"mounted\" : \"unmounted\";\n    let node = $state(null);\n    $effect(() => {\n        if (!id.current)\n            return;\n        if (!present.current)\n            return;\n        afterTick(() => {\n            node = document.getElementById(id.current);\n        });\n    });\n    const { state, dispatch } = useStateMachine(initialState, {\n        mounted: {\n            UNMOUNT: \"unmounted\",\n            ANIMATION_OUT: \"unmountSuspended\",\n        },\n        unmountSuspended: {\n            MOUNT: \"mounted\",\n            ANIMATION_END: \"unmounted\",\n        },\n        unmounted: {\n            MOUNT: \"mounted\",\n        },\n    });\n    watch(present, (currPresent, prevPresent) => {\n        if (!node) {\n            node = document.getElementById(id.current);\n        }\n        if (!node)\n            return;\n        const hasPresentChanged = currPresent !== prevPresent;\n        if (!hasPresentChanged)\n            return;\n        const prevAnimationName = prevAnimationNameState;\n        const currAnimationName = getAnimationName(node);\n        if (currPresent) {\n            dispatch(\"MOUNT\");\n        }\n        else if (currAnimationName === \"none\" || styles.display === \"none\") {\n            // If there is no exit animation or the element is hidden, animations won't run\n            // so we unmount instantly\n            dispatch(\"UNMOUNT\");\n        }\n        else {\n            /**\n             * When `present` changes to `false`, we check changes to animation-name to\n             * determine whether an animation has started. We chose this approach (reading\n             * computed styles) because there is no `animationrun` event and `animationstart`\n             * fires after `animation-delay` has expired which would be too late.\n             */\n            const isAnimating = prevAnimationName !== currAnimationName;\n            if (prevPresent && isAnimating) {\n                dispatch(\"ANIMATION_OUT\");\n            }\n            else {\n                dispatch(\"UNMOUNT\");\n            }\n        }\n    });\n    /**\n     * Triggering an ANIMATION_OUT during an ANIMATION_IN will fire an `animationcancel`\n     * event for ANIMATION_IN after we have entered `unmountSuspended` state. So, we\n     * make sure we only trigger ANIMATION_END for the currently active animation.\n     */\n    function handleAnimationEnd(event) {\n        if (!node) {\n            node = document.getElementById(id.current);\n        }\n        if (!node)\n            return;\n        const currAnimationName = getAnimationName(node);\n        const isCurrentAnimation = currAnimationName.includes(event.animationName) || currAnimationName === \"none\";\n        if (event.target === node && isCurrentAnimation) {\n            dispatch(\"ANIMATION_END\");\n        }\n    }\n    function handleAnimationStart(event) {\n        if (!node) {\n            node = document.getElementById(id.current);\n        }\n        if (!node)\n            return;\n        if (event.target === node) {\n            prevAnimationNameState = getAnimationName(node);\n        }\n    }\n    watch(state, () => {\n        if (!node) {\n            node = document.getElementById(id.current);\n        }\n        if (!node)\n            return;\n        const currAnimationName = getAnimationName(node);\n        prevAnimationNameState = state.current === \"mounted\" ? currAnimationName : \"none\";\n    });\n    $effect(() => {\n        if (!node)\n            return;\n        styles = getComputedStyle(node);\n        node.addEventListener(\"animationstart\", handleAnimationStart);\n        node.addEventListener(\"animationcancel\", handleAnimationEnd);\n        node.addEventListener(\"animationend\", handleAnimationEnd);\n        return () => {\n            node?.removeEventListener(\"animationstart\", handleAnimationStart);\n            node?.removeEventListener(\"animationcancel\", handleAnimationEnd);\n            node?.removeEventListener(\"animationend\", handleAnimationEnd);\n        };\n    });\n    const isPresentDerived = $derived([\"mounted\", \"unmountSuspended\"].includes(state.current));\n    return {\n        get current() {\n            return isPresentDerived;\n        },\n    };\n}\nfunction getAnimationName(node) {\n    return node ? getComputedStyle(node).animationName || \"none\" : \"none\";\n}\n","<script lang=\"ts\">\n\timport { box } from \"svelte-toolbelt\";\n\timport type { PresenceLayerImplProps } from \"./types.js\";\n\timport { usePresence } from \"./usePresence.svelte.js\";\n\n\tlet { present, forceMount, presence, id }: PresenceLayerImplProps = $props();\n\n\tconst isPresent = usePresence(\n\t\tbox.with(() => present),\n\t\tbox.with(() => id)\n\t);\n</script>\n\n{#if forceMount || present || isPresent.current}\n\t{@render presence?.({ present: isPresent })}\n{/if}\n","import { useRefById } from \"svelte-toolbelt\";\nimport { getAriaExpanded, getDataOpenClosed } from \"../../internal/attrs.js\";\nimport { createContext } from \"../../internal/create-context.js\";\nimport { kbd } from \"../../internal/kbd.js\";\nfunction createAttrs(variant) {\n    return {\n        content: `data-${variant}-content`,\n        trigger: `data-${variant}-trigger`,\n        overlay: `data-${variant}-overlay`,\n        title: `data-${variant}-title`,\n        description: `data-${variant}-description`,\n        close: `data-${variant}-close`,\n        cancel: `data-${variant}-cancel`,\n        action: `data-${variant}-action`,\n    };\n}\nclass DialogRootState {\n    open;\n    variant;\n    triggerNode = $state(null);\n    titleNode = $state(null);\n    contentNode = $state(null);\n    descriptionNode = $state(null);\n    contentId = $state(undefined);\n    titleId = $state(undefined);\n    triggerId = $state(undefined);\n    descriptionId = $state(undefined);\n    cancelNode = $state(null);\n    attrs = $derived.by(() => createAttrs(this.variant.current));\n    constructor(props) {\n        this.open = props.open;\n        this.variant = props.variant;\n    }\n    handleOpen = () => {\n        if (this.open.current)\n            return;\n        this.open.current = true;\n    };\n    handleClose = () => {\n        if (!this.open.current)\n            return;\n        this.open.current = false;\n    };\n    sharedProps = $derived.by(() => ({\n        \"data-state\": getDataOpenClosed(this.open.current),\n    }));\n}\nclass DialogTriggerState {\n    #id;\n    #ref;\n    #root;\n    #disabled;\n    constructor(props, root) {\n        this.#id = props.id;\n        this.#root = root;\n        this.#ref = props.ref;\n        this.#disabled = props.disabled;\n        useRefById({\n            id: this.#id,\n            ref: this.#ref,\n            onRefChange: (node) => {\n                this.#root.triggerNode = node;\n                this.#root.triggerId = node?.id;\n            },\n        });\n    }\n    #onpointerdown = (e) => {\n        if (this.#disabled.current)\n            return;\n        if (e.pointerType === \"touch\")\n            return e.preventDefault();\n        if (e.button > 0)\n            return;\n        // by default, it will attempt to focus this trigger on pointerdown\n        // since this also opens the dialog we want to prevent that behavior\n        e.preventDefault();\n        this.#root.handleOpen();\n    };\n    #onpointerup = (e) => {\n        if (this.#disabled.current)\n            return;\n        if (e.pointerType === \"touch\") {\n            e.preventDefault();\n            this.#root.handleOpen();\n        }\n    };\n    #onkeydown = (e) => {\n        if (this.#disabled.current)\n            return;\n        if (e.key === kbd.SPACE || e.key === kbd.ENTER) {\n            e.preventDefault();\n            this.#root.handleOpen();\n        }\n    };\n    props = $derived.by(() => ({\n        id: this.#id.current,\n        \"aria-haspopup\": \"dialog\",\n        \"aria-expanded\": getAriaExpanded(this.#root.open.current),\n        \"aria-controls\": this.#root.contentId,\n        [this.#root.attrs.trigger]: \"\",\n        onpointerdown: this.#onpointerdown,\n        onkeydown: this.#onkeydown,\n        onpointerup: this.#onpointerup,\n        ...this.#root.sharedProps,\n    }));\n}\nclass DialogCloseState {\n    #id;\n    #ref;\n    #root;\n    #variant;\n    #disabled;\n    #attr = $derived.by(() => this.#root.attrs[this.#variant.current]);\n    constructor(props, root) {\n        this.#root = root;\n        this.#ref = props.ref;\n        this.#id = props.id;\n        this.#variant = props.variant;\n        this.#disabled = props.disabled;\n        useRefById({\n            id: this.#id,\n            ref: this.#ref,\n            deps: () => this.#root.open.current,\n        });\n    }\n    #onpointerdown = (e) => {\n        if (this.#disabled.current)\n            return;\n        if (e.pointerType === \"touch\")\n            return e.preventDefault();\n        if (e.button > 0)\n            return;\n        this.#root.handleClose();\n    };\n    #onpointerup = (e) => {\n        if (this.#disabled.current)\n            return;\n        if (e.pointerType === \"touch\") {\n            e.preventDefault();\n            this.#root.handleClose();\n        }\n    };\n    #onkeydown = (e) => {\n        if (this.#disabled.current)\n            return;\n        if (e.key === kbd.SPACE || e.key === kbd.ENTER) {\n            e.preventDefault();\n            this.#root.handleClose();\n        }\n    };\n    props = $derived.by(() => ({\n        id: this.#id.current,\n        [this.#attr]: \"\",\n        onpointerdown: this.#onpointerdown,\n        onpointerup: this.#onpointerup,\n        onkeydown: this.#onkeydown,\n        ...this.#root.sharedProps,\n    }));\n}\nclass DialogActionState {\n    #id;\n    #ref;\n    #root;\n    #attr = $derived.by(() => this.#root.attrs.action);\n    constructor(props, root) {\n        this.#id = props.id;\n        this.#ref = props.ref;\n        this.#root = root;\n        useRefById({\n            id: this.#id,\n            ref: this.#ref,\n        });\n    }\n    props = $derived.by(() => ({\n        id: this.#id.current,\n        [this.#attr]: \"\",\n        ...this.#root.sharedProps,\n    }));\n}\nclass DialogTitleState {\n    #id;\n    #ref;\n    #root;\n    #level;\n    constructor(props, root) {\n        this.#id = props.id;\n        this.#root = root;\n        this.#ref = props.ref;\n        this.#level = props.level;\n        useRefById({\n            id: this.#id,\n            ref: this.#ref,\n            onRefChange: (node) => {\n                this.#root.titleNode = node;\n                this.#root.titleId = node?.id;\n            },\n            deps: () => this.#root.open.current,\n        });\n    }\n    props = $derived.by(() => ({\n        id: this.#id.current,\n        role: \"heading\",\n        \"aria-level\": this.#level.current,\n        [this.#root.attrs.title]: \"\",\n        ...this.#root.sharedProps,\n    }));\n}\nclass DialogDescriptionState {\n    #id;\n    #ref;\n    #root;\n    constructor(props, root) {\n        this.#id = props.id;\n        this.#root = root;\n        this.#ref = props.ref;\n        useRefById({\n            id: this.#id,\n            ref: this.#ref,\n            deps: () => this.#root.open.current,\n            onRefChange: (node) => {\n                this.#root.descriptionNode = node;\n                this.#root.descriptionId = node?.id;\n            },\n        });\n    }\n    props = $derived.by(() => ({\n        id: this.#id.current,\n        [this.#root.attrs.description]: \"\",\n        ...this.#root.sharedProps,\n    }));\n}\nclass DialogContentState {\n    #id;\n    #ref;\n    root;\n    constructor(props, root) {\n        this.#id = props.id;\n        this.root = root;\n        this.#ref = props.ref;\n        useRefById({\n            id: this.#id,\n            ref: this.#ref,\n            deps: () => this.root.open.current,\n            onRefChange: (node) => {\n                this.root.contentNode = node;\n                this.root.contentId = node?.id;\n            },\n        });\n    }\n    snippetProps = $derived.by(() => ({ open: this.root.open.current }));\n    props = $derived.by(() => ({\n        id: this.#id.current,\n        role: this.root.variant.current === \"alert-dialog\" ? \"alertdialog\" : \"dialog\",\n        \"aria-describedby\": this.root.descriptionId,\n        \"aria-labelledby\": this.root.titleId,\n        [this.root.attrs.content]: \"\",\n        style: {\n            pointerEvents: \"auto\",\n        },\n        ...this.root.sharedProps,\n    }));\n}\nclass DialogOverlayState {\n    #id;\n    #ref;\n    root;\n    constructor(props, root) {\n        this.#id = props.id;\n        this.#ref = props.ref;\n        this.root = root;\n        useRefById({\n            id: this.#id,\n            ref: this.#ref,\n            deps: () => this.root.open.current,\n        });\n    }\n    snippetProps = $derived.by(() => ({ open: this.root.open.current }));\n    props = $derived.by(() => ({\n        id: this.#id.current,\n        [this.root.attrs.overlay]: \"\",\n        style: {\n            pointerEvents: \"auto\",\n        },\n        ...this.root.sharedProps,\n    }));\n}\nclass AlertDialogCancelState {\n    #id;\n    #ref;\n    #root;\n    #disabled;\n    constructor(props, root) {\n        this.#id = props.id;\n        this.#ref = props.ref;\n        this.#root = root;\n        this.#disabled = props.disabled;\n        useRefById({\n            id: this.#id,\n            ref: this.#ref,\n            deps: () => this.#root.open.current,\n            onRefChange: (node) => {\n                this.#root.cancelNode = node;\n            },\n        });\n    }\n    #onpointerdown = (e) => {\n        if (this.#disabled.current)\n            return;\n        if (e.pointerType === \"touch\")\n            return e.preventDefault();\n        if (e.button > 0)\n            return;\n        this.#root.handleClose();\n    };\n    #onkeydown = (e) => {\n        if (this.#disabled.current)\n            return;\n        if (e.key === kbd.SPACE || e.key === kbd.ENTER) {\n            e.preventDefault();\n            this.#root.handleClose();\n        }\n    };\n    #onpointerup = (e) => {\n        if (this.#disabled.current)\n            return;\n        if (e.pointerType === \"touch\") {\n            e.preventDefault();\n            this.#root.handleClose();\n        }\n    };\n    props = $derived.by(() => ({\n        id: this.#id.current,\n        [this.#root.attrs.cancel]: \"\",\n        onpointerdown: this.#onpointerdown,\n        onpointerup: this.#onpointerup,\n        onkeydown: this.#onkeydown,\n        ...this.#root.sharedProps,\n    }));\n}\nconst [setDialogRootContext, getDialogRootContext] = createContext(\"Dialog.Root\");\nexport function useDialogRoot(props) {\n    return setDialogRootContext(new DialogRootState(props));\n}\nexport function useDialogTrigger(props) {\n    const root = getDialogRootContext();\n    return new DialogTriggerState(props, root);\n}\nexport function useDialogTitle(props) {\n    return new DialogTitleState(props, getDialogRootContext());\n}\nexport function useDialogContent(props) {\n    return new DialogContentState(props, getDialogRootContext());\n}\nexport function useDialogOverlay(props) {\n    return new DialogOverlayState(props, getDialogRootContext());\n}\nexport function useDialogDescription(props) {\n    return new DialogDescriptionState(props, getDialogRootContext());\n}\nexport function useDialogClose(props) {\n    return new DialogCloseState(props, getDialogRootContext());\n}\nexport function useAlertDialogCancel(props) {\n    return new AlertDialogCancelState(props, getDialogRootContext());\n}\nexport function useAlertDialogAction(props) {\n    return new DialogActionState(props, getDialogRootContext());\n}\n","<script lang=\"ts\">\n\timport { box, mergeProps } from \"svelte-toolbelt\";\n\timport { useDialogTitle } from \"../dialog.svelte.js\";\n\timport type { DialogTitleProps } from \"../types.js\";\n\timport { useId } from \"../../../internal/use-id.js\";\n\n\tlet {\n\t\tid = useId(),\n\t\tref = $bindable(null),\n\t\tchild,\n\t\tchildren,\n\t\tlevel = 2,\n\t\t...restProps\n\t}: DialogTitleProps = $props();\n\n\tconst titleState = useDialogTitle({\n\t\tid: box.with(() => id),\n\t\tlevel: box.with(() => level),\n\t\tref: box.with(\n\t\t\t() => ref,\n\t\t\t(v) => (ref = v)\n\t\t),\n\t});\n\n\tconst mergedProps = $derived(mergeProps(restProps, titleState.props));\n</script>\n\n{#if child}\n\t{@render child({ props: mergedProps })}\n{:else}\n\t<div {...mergedProps}>\n\t\t{@render children?.()}\n\t</div>\n{/if}\n","<script lang=\"ts\">\n\timport { getAllContexts, mount, unmount, untrack } from \"svelte\";\n\timport { DEV } from \"esm-env\";\n\timport PortalConsumer from \"./portal-consumer.svelte\";\n\timport type { PortalProps } from \"./types.js\";\n\timport { isBrowser } from \"../../../internal/is.js\";\n\n\tlet { to = \"body\", children, disabled }: PortalProps = $props();\n\n\tconst context = getAllContexts();\n\n\tlet target = $derived(getTarget());\n\n\tfunction getTarget() {\n\t\tif (!isBrowser || disabled) return null;\n\t\tlet localTarget: HTMLElement | null | DocumentFragment | Element = null;\n\t\tif (typeof to === \"string\") {\n\t\t\tlocalTarget = document.querySelector(to);\n\t\t\tif (localTarget === null) {\n\t\t\t\tif (DEV) {\n\t\t\t\t\tthrow new Error(`Target element \"${to}\" not found.`);\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (to instanceof HTMLElement || to instanceof DocumentFragment) {\n\t\t\tlocalTarget = to;\n\t\t} else {\n\t\t\tif (DEV) {\n\t\t\t\tthrow new TypeError(\n\t\t\t\t\t`Unknown portal target type: ${\n\t\t\t\t\t\tto === null ? \"null\" : typeof to\n\t\t\t\t\t}. Allowed types: string (query selector), HTMLElement, or DocumentFragment.`\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\treturn localTarget;\n\t}\n\n\tlet instance: any;\n\n\t$effect(() => {\n\t\tif (!target || disabled) {\n\t\t\tif (instance) {\n\t\t\t\tunmount(instance);\n\t\t\t\tinstance = null;\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tuntrack(\n\t\t\t() =>\n\t\t\t\t(instance = mount(PortalConsumer, {\n\t\t\t\t\ttarget: target as any,\n\t\t\t\t\tprops: { children },\n\t\t\t\t\tcontext,\n\t\t\t\t}))\n\t\t);\n\n\t\treturn () => {\n\t\t\tif (instance) {\n\t\t\t\tunmount(instance);\n\t\t\t\tinstance = null;\n\t\t\t}\n\t\t};\n\t});\n</script>\n\n{#if disabled}\n\t{@render children?.()}\n{/if}\n","/**\n * Adds an event listener to the specified target element(s) for the given event(s), and returns a function to remove it.\n * @param target The target element(s) to add the event listener to.\n * @param event The event(s) to listen for.\n * @param handler The function to be called when the event is triggered.\n * @param options An optional object that specifies characteristics about the event listener.\n * @returns A function that removes the event listener from the target element(s).\n */\nexport function addEventListener(target, event, handler, options) {\n    const events = Array.isArray(event) ? event : [event];\n    // Add the event listener to each specified event for the target element(s).\n    events.forEach((_event) => target.addEventListener(_event, handler, options));\n    // Return a function that removes the event listener from the target element(s).\n    return () => {\n        events.forEach((_event) => target.removeEventListener(_event, handler, options));\n    };\n}\n","// eslint-disable-next-line ts/no-explicit-any\nexport function debounce(fn, wait = 500) {\n    let timeout = null;\n    const debounced = (...args) => {\n        if (timeout !== null) {\n            clearTimeout(timeout);\n        }\n        timeout = setTimeout(() => {\n            fn(...args);\n        }, wait);\n    };\n    debounced.destroy = () => {\n        if (timeout !== null) {\n            clearTimeout(timeout);\n            timeout = null;\n        }\n    };\n    return debounced;\n}\n","export function isOrContainsTarget(node, target) {\n    return node === target || node.contains(target);\n}\nexport function getOwnerDocument(el) {\n    return el?.ownerDocument ?? document;\n}\n","import { untrack } from \"svelte\";\nimport { afterSleep, afterTick, box, executeCallbacks, onDestroyEffect, useRefById, } from \"svelte-toolbelt\";\nimport { addEventListener } from \"../../../internal/events.js\";\nimport { debounce } from \"../../../internal/debounce.js\";\nimport { noop } from \"../../../internal/noop.js\";\nimport { getOwnerDocument, isOrContainsTarget } from \"../../../internal/elements.js\";\nimport { isElement } from \"../../../internal/is.js\";\nconst layers = new Map();\nexport class DismissibleLayerState {\n    #interactOutsideProp;\n    #behaviorType;\n    #interceptedEvents = {\n        pointerdown: false,\n    };\n    #isResponsibleLayer = false;\n    node = box(null);\n    #documentObj = undefined;\n    #enabled;\n    #isFocusInsideDOMTree = $state(false);\n    #onFocusOutside;\n    currNode = $state(null);\n    #isValidEventProp;\n    #unsubClickListener = noop;\n    constructor(props) {\n        this.#enabled = props.enabled;\n        this.#isValidEventProp = props.isValidEvent;\n        useRefById({\n            id: props.id,\n            ref: this.node,\n            deps: () => this.#enabled.current,\n            onRefChange: (node) => {\n                this.currNode = node;\n            },\n        });\n        this.#behaviorType = props.interactOutsideBehavior;\n        this.#interactOutsideProp = props.onInteractOutside;\n        this.#onFocusOutside = props.onFocusOutside;\n        $effect(() => {\n            this.#documentObj = getOwnerDocument(this.currNode);\n        });\n        let unsubEvents = noop;\n        const cleanup = () => {\n            this.#resetState();\n            layers.delete(this);\n            this.#handleInteractOutside.destroy();\n            unsubEvents();\n        };\n        $effect(() => {\n            if (this.#enabled.current && this.currNode) {\n                afterSleep(1, () => {\n                    layers.set(this, untrack(() => this.#behaviorType));\n                    unsubEvents();\n                    unsubEvents = this.#addEventListeners();\n                });\n            }\n            return () => {\n                cleanup();\n            };\n        });\n        onDestroyEffect(() => {\n            this.#resetState.destroy();\n            layers.delete(this);\n            this.#handleInteractOutside.destroy();\n            this.#unsubClickListener();\n            unsubEvents();\n        });\n    }\n    #handleFocus = (event) => {\n        if (event.defaultPrevented)\n            return;\n        if (!this.currNode)\n            return;\n        afterTick(() => {\n            if (!this.currNode || this.#isTargetWithinLayer(event.target))\n                return;\n            if (event.target && !this.#isFocusInsideDOMTree) {\n                this.#onFocusOutside.current?.(event);\n            }\n        });\n    };\n    #addEventListeners() {\n        return executeCallbacks(\n        /**\n         * CAPTURE INTERACTION START\n         * mark interaction-start event as intercepted.\n         * mark responsible layer during interaction start\n         * to avoid checking if is responsible layer during interaction end\n         * when a new floating element may have been opened.\n         */\n        addEventListener(this.#documentObj, \"pointerdown\", executeCallbacks(this.#markInterceptedEvent, this.#markResponsibleLayer), true), \n        /**\n         * BUBBLE INTERACTION START\n         * Mark interaction-start event as non-intercepted. Debounce `onInteractOutsideStart`\n         * to avoid prematurely checking if other events were intercepted.\n         */\n        addEventListener(this.#documentObj, \"pointerdown\", executeCallbacks(this.#markNonInterceptedEvent, this.#handleInteractOutside)), \n        /**\n         * HANDLE FOCUS OUTSIDE\n         */\n        addEventListener(this.#documentObj, \"focusin\", this.#handleFocus));\n    }\n    #handleDismiss = (e) => {\n        let event = e;\n        if (event.defaultPrevented) {\n            event = createWrappedEvent(e);\n        }\n        this.#interactOutsideProp.current(e);\n    };\n    #handleInteractOutside = debounce((e) => {\n        if (!this.currNode) {\n            this.#unsubClickListener();\n            return;\n        }\n        const isEventValid = this.#isValidEventProp.current(e, this.currNode) || isValidEvent(e, this.currNode);\n        if (!this.#isResponsibleLayer || this.#isAnyEventIntercepted() || !isEventValid) {\n            this.#unsubClickListener();\n            return;\n        }\n        let event = e;\n        if (event.defaultPrevented) {\n            event = createWrappedEvent(event);\n        }\n        if (this.#behaviorType.current !== \"close\" &&\n            this.#behaviorType.current !== \"defer-otherwise-close\") {\n            this.#unsubClickListener();\n            return;\n        }\n        if (e.pointerType === \"touch\") {\n            this.#unsubClickListener();\n            // @ts-expect-error - later\n            this.#unsubClickListener = addEventListener(this.#documentObj, \"click\", this.#handleDismiss, { once: true });\n        }\n        else {\n            this.#interactOutsideProp.current(event);\n        }\n    }, 10);\n    #markInterceptedEvent = (e) => {\n        this.#interceptedEvents[e.type] = true;\n    };\n    #markNonInterceptedEvent = (e) => {\n        this.#interceptedEvents[e.type] = false;\n    };\n    #markResponsibleLayer = () => {\n        if (!this.node.current)\n            return;\n        this.#isResponsibleLayer = isResponsibleLayer(this.node.current);\n    };\n    #isTargetWithinLayer = (target) => {\n        if (!this.node.current)\n            return false;\n        return isOrContainsTarget(this.node.current, target);\n    };\n    #resetState = debounce(() => {\n        for (const eventType in this.#interceptedEvents) {\n            this.#interceptedEvents[eventType] = false;\n        }\n        this.#isResponsibleLayer = false;\n    }, 20);\n    #isAnyEventIntercepted() {\n        const i = Object.values(this.#interceptedEvents).some(Boolean);\n        return i;\n    }\n    #onfocuscapture = () => {\n        this.#isFocusInsideDOMTree = true;\n    };\n    #onblurcapture = () => {\n        this.#isFocusInsideDOMTree = false;\n    };\n    props = {\n        onfocuscapture: this.#onfocuscapture,\n        onblurcapture: this.#onblurcapture,\n    };\n}\nexport function useDismissibleLayer(props) {\n    return new DismissibleLayerState(props);\n}\nfunction getTopMostLayer(layersArr) {\n    return layersArr.findLast(([_, { current: behaviorType }]) => behaviorType === \"close\" || behaviorType === \"ignore\");\n}\nfunction isResponsibleLayer(node) {\n    const layersArr = [...layers];\n    /**\n     * We first check if we can find a top layer with `close` or `ignore`.\n     * If that top layer was found and matches the provided node, then the node is\n     * responsible for the outside interaction. Otherwise, we know that all layers defer so\n     * the first layer is the responsible one.\n     */\n    const topMostLayer = getTopMostLayer(layersArr);\n    if (topMostLayer)\n        return topMostLayer[0].node.current === node;\n    const [firstLayerNode] = layersArr[0];\n    return firstLayerNode.node.current === node;\n}\nfunction isValidEvent(e, node) {\n    if (\"button\" in e && e.button > 0)\n        return false;\n    const target = e.target;\n    if (!isElement(target))\n        return false;\n    const ownerDocument = getOwnerDocument(target);\n    const isValid = ownerDocument.documentElement.contains(target) && !isOrContainsTarget(node, target);\n    return isValid;\n}\nfunction createWrappedEvent(e) {\n    const capturedCurrentTarget = e.currentTarget;\n    const capturedTarget = e.target;\n    let newEvent;\n    if (e instanceof PointerEvent) {\n        newEvent = new PointerEvent(e.type, e);\n    }\n    else {\n        newEvent = new PointerEvent(\"pointerdown\", e);\n    }\n    // track the prevented state separately\n    let isPrevented = false;\n    // Create a proxy to intercept property access and method calls\n    const wrappedEvent = new Proxy(newEvent, {\n        get: (target, prop) => {\n            if (prop === \"currentTarget\") {\n                return capturedCurrentTarget;\n            }\n            if (prop === \"target\") {\n                return capturedTarget;\n            }\n            if (prop === \"preventDefault\") {\n                return () => {\n                    isPrevented = true;\n                    if (typeof target.preventDefault === \"function\") {\n                        target.preventDefault();\n                    }\n                };\n            }\n            if (prop === \"defaultPrevented\") {\n                return isPrevented;\n            }\n            if (prop in target) {\n                // eslint-disable-next-line ts/no-explicit-any\n                return target[prop];\n            }\n            // eslint-disable-next-line ts/no-explicit-any\n            return e[prop];\n        },\n    });\n    return wrappedEvent;\n}\n","<script lang=\"ts\">\n\timport { box } from \"svelte-toolbelt\";\n\timport type { DismissibleLayerImplProps } from \"./types.js\";\n\timport { useDismissibleLayer } from \"./useDismissibleLayer.svelte.js\";\n\timport { noop } from \"../../../internal/noop.js\";\n\n\tlet {\n\t\tinteractOutsideBehavior = \"close\",\n\t\tonInteractOutside = noop,\n\t\tonFocusOutside = noop,\n\t\tid,\n\t\tchildren,\n\t\tenabled,\n\t\tisValidEvent = () => false,\n\t}: DismissibleLayerImplProps = $props();\n\n\tconst dismissibleLayerState = useDismissibleLayer({\n\t\tid: box.with(() => id),\n\t\tinteractOutsideBehavior: box.with(() => interactOutsideBehavior),\n\t\tonInteractOutside: box.with(() => onInteractOutside),\n\t\tenabled: box.with(() => enabled),\n\t\tonFocusOutside: box.with(() => onFocusOutside),\n\t\tisValidEvent: box.with(() => isValidEvent),\n\t});\n</script>\n\n{@render children?.({ props: dismissibleLayerState.props })}\n","import { untrack } from \"svelte\";\nimport { addEventListener } from \"../../../internal/events.js\";\nimport { kbd } from \"../../../internal/kbd.js\";\nimport { noop } from \"../../../internal/noop.js\";\nconst layers = new Map();\nexport class EscapeLayerState {\n    #onEscapeProp;\n    #behaviorType;\n    #enabled;\n    constructor(props) {\n        this.#behaviorType = props.escapeKeydownBehavior;\n        this.#onEscapeProp = props.onEscapeKeydown;\n        this.#enabled = props.enabled;\n        let unsubEvents = noop;\n        $effect(() => {\n            if (this.#enabled.current) {\n                layers.set(this, untrack(() => this.#behaviorType));\n                unsubEvents = this.#addEventListener();\n            }\n            return () => {\n                unsubEvents();\n                layers.delete(this);\n            };\n        });\n    }\n    #addEventListener = () => {\n        return addEventListener(document, \"keydown\", this.#onkeydown, { passive: false });\n    };\n    #onkeydown = (e) => {\n        if (e.key !== kbd.ESCAPE || !isResponsibleEscapeLayer(this))\n            return;\n        const clonedEvent = new KeyboardEvent(e.type, e);\n        e.preventDefault();\n        const behaviorType = this.#behaviorType.current;\n        if (behaviorType !== \"close\" && behaviorType !== \"defer-otherwise-close\")\n            return;\n        this.#onEscapeProp.current(clonedEvent);\n    };\n}\nexport function useEscapeLayer(props) {\n    return new EscapeLayerState(props);\n}\nfunction isResponsibleEscapeLayer(instance) {\n    const layersArr = [...layers];\n    /**\n     * We first check if we can find a top layer with `close` or `ignore`.\n     * If that top layer was found and matches the provided node, then the node is\n     * responsible for the escape. Otherwise, we know that all layers defer so\n     * the first layer is the responsible one.\n     */\n    const topMostLayer = layersArr.findLast(([_, { current: behaviorType }]) => behaviorType === \"close\" || behaviorType === \"ignore\");\n    if (topMostLayer)\n        return topMostLayer[0] === instance;\n    const [firstLayerNode] = layersArr[0];\n    return firstLayerNode === instance;\n}\n","<script lang=\"ts\">\n\timport { box } from \"svelte-toolbelt\";\n\timport type { EscapeLayerImplProps } from \"./types.js\";\n\timport { useEscapeLayer } from \"./useEscapeLayer.svelte.js\";\n\timport { noop } from \"../../../internal/noop.js\";\n\n\tlet {\n\t\tescapeKeydownBehavior = \"close\",\n\t\tonEscapeKeydown = noop,\n\t\tchildren,\n\t\tenabled,\n\t}: EscapeLayerImplProps = $props();\n\n\tuseEscapeLayer({\n\t\tescapeKeydownBehavior: box.with(() => escapeKeydownBehavior),\n\t\tonEscapeKeydown: box.with(() => onEscapeKeydown),\n\t\tenabled: box.with(() => enabled),\n\t});\n</script>\n\n{@render children?.()}\n","import { box } from \"svelte-toolbelt\";\nimport { useId } from \"../../../internal/use-id.js\";\nconst focusStack = box([]);\nexport function createFocusScopeStack() {\n    const stack = focusStack;\n    return {\n        add(focusScope) {\n            // pause the currently active focus scope (top of the stack)\n            const activeFocusScope = stack.current[0];\n            if (focusScope.id !== activeFocusScope?.id) {\n                activeFocusScope?.pause();\n            }\n            // remove in case it already exists because it'll be added to the top\n            stack.current = removeFromFocusScopeArray(stack.current, focusScope);\n            stack.current.unshift(focusScope);\n        },\n        remove(focusScope) {\n            stack.current = removeFromFocusScopeArray(stack.current, focusScope);\n            stack.current[0]?.resume();\n        },\n    };\n}\nexport function createFocusScopeAPI() {\n    let paused = $state(false);\n    return {\n        id: useId(),\n        get paused() {\n            return paused;\n        },\n        pause() {\n            paused = true;\n        },\n        resume() {\n            paused = false;\n        },\n    };\n}\nfunction removeFromFocusScopeArray(arr, item) {\n    return [...arr].filter((i) => i.id !== item.id);\n}\nexport function removeLinks(items) {\n    return items.filter((item) => item.tagName !== \"A\");\n}\n","import { isBrowser, isElementHidden, isSelectableInput } from \"./is.js\";\n/**\n * Handles `initialFocus` prop behavior for the\n * Calendar & RangeCalendar components.\n */\nexport function handleCalendarInitialFocus(calendar) {\n    if (!isBrowser)\n        return;\n    const selectedDay = calendar.querySelector(\"[data-selected]\");\n    if (selectedDay)\n        return focusWithoutScroll(selectedDay);\n    const today = calendar.querySelector(\"[data-today]\");\n    if (today)\n        return focusWithoutScroll(today);\n    const firstDay = calendar.querySelector(\"[data-calendar-date]\");\n    if (firstDay)\n        return focusWithoutScroll(firstDay);\n}\n/**\n * A utility function that focuses an element without scrolling.\n */\nexport function focusWithoutScroll(element) {\n    const scrollPosition = {\n        x: window.pageXOffset || document.documentElement.scrollLeft,\n        y: window.pageYOffset || document.documentElement.scrollTop,\n    };\n    element.focus();\n    window.scrollTo(scrollPosition.x, scrollPosition.y);\n}\n/**\n * A utility function that focuses an element.\n */\nexport function focus(element, { select = false } = {}) {\n    if (!(element && element.focus))\n        return;\n    const previouslyFocusedElement = document.activeElement;\n    // prevent scroll on focus\n    element.focus({ preventScroll: true });\n    // only elect if its not the same element, it supports selection, and we need to select it\n    if (element !== previouslyFocusedElement && isSelectableInput(element) && select) {\n        element.select();\n    }\n}\n/**\n * Attempts to focus the first element in a list of candidates.\n * Stops when focus is successful.\n */\nexport function focusFirst(candidates, { select = false } = {}) {\n    const previouslyFocusedElement = document.activeElement;\n    for (const candidate of candidates) {\n        focus(candidate, { select });\n        if (document.activeElement !== previouslyFocusedElement) {\n            return true;\n        }\n    }\n}\n/**\n * Returns the first visible element in a list.\n * NOTE: Only checks visibility up to the `container`.\n */\nexport function findVisible(elements, container) {\n    for (const element of elements) {\n        // we stop checking if it's hidden at the `container` level (excluding)\n        if (!isElementHidden(element, container))\n            return element;\n    }\n}\n/**\n * Returns a list of potential tabbable candidates.\n *\n * NOTE: This is only a close approximation. For example it doesn't take into account cases like when\n * elements are not visible. This cannot be worked out easily by just reading a property, but rather\n * necessitate runtime knowledge (computed styles, etc). We deal with these cases separately.\n *\n * See: https://developer.mozilla.org/en-US/docs/Web/API/TreeWalker\n * Credit: https://github.com/discord/focus-layers/blob/master/src/util/wrapFocus.tsx#L1\n */\nexport function getTabbableCandidates(container) {\n    const nodes = [];\n    const walker = document.createTreeWalker(container, NodeFilter.SHOW_ELEMENT, {\n        // eslint-disable-next-line ts/no-explicit-any\n        acceptNode: (node) => {\n            const isHiddenInput = node.tagName === \"INPUT\" && node.type === \"hidden\";\n            if (node.disabled || node.hidden || isHiddenInput)\n                return NodeFilter.FILTER_SKIP;\n            // `.tabIndex` is not the same as the `tabindex` attribute. It works on the\n            // runtime's understanding of tabbability, so this automatically accounts\n            // for any kind of element that could be tabbed to.\n            return node.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;\n        },\n    });\n    while (walker.nextNode())\n        nodes.push(walker.currentNode);\n    // we do not take into account the order of nodes with positive `tabIndex` as it\n    // hinders accessibility to have tab order different from visual order.\n    return nodes;\n}\n/**\n * A utility function that returns the first and last elements within a container that are\n * visible and focusable.\n */\nexport function getTabbableEdges(container) {\n    const candidates = getTabbableCandidates(container);\n    const first = findVisible(candidates, container);\n    const last = findVisible(candidates.reverse(), container);\n    return [first, last];\n}\n","import { untrack } from \"svelte\";\nimport { afterTick, box, executeCallbacks, useRefById } from \"svelte-toolbelt\";\nimport { createFocusScopeAPI, createFocusScopeStack, removeLinks, } from \"./focus-scope-stack.svelte.js\";\nimport { focus, focusFirst, getTabbableCandidates, getTabbableEdges } from \"../../../internal/focus.js\";\nimport { addEventListener } from \"../../../internal/events.js\";\nimport { isHTMLElement } from \"../../../internal/is.js\";\nimport { kbd } from \"../../../internal/kbd.js\";\nconst AUTOFOCUS_ON_MOUNT = \"focusScope.autoFocusOnMount\";\nconst AUTOFOCUS_ON_DESTROY = \"focusScope.autoFocusOnDestroy\";\nconst EVENT_OPTIONS = { bubbles: false, cancelable: true };\nexport function useFocusScope({ id, loop, enabled, onOpenAutoFocus, onCloseAutoFocus, forceMount, }) {\n    const focusScopeStack = createFocusScopeStack();\n    const focusScope = createFocusScopeAPI();\n    const ref = box(null);\n    useRefById({\n        id,\n        ref,\n        deps: () => enabled.current,\n    });\n    let lastFocusedElement = $state(null);\n    $effect(() => {\n        const container = ref.current;\n        if (!container)\n            return;\n        if (!enabled.current)\n            return;\n        function handleFocusIn(event) {\n            if (focusScope.paused || !container)\n                return;\n            const target = event.target;\n            if (!isHTMLElement(target))\n                return;\n            if (container.contains(target)) {\n                lastFocusedElement = target;\n            }\n            else {\n                focus(lastFocusedElement, { select: true });\n            }\n        }\n        function handleFocusOut(event) {\n            if (focusScope.paused || !container)\n                return;\n            const relatedTarget = event.relatedTarget;\n            if (!isHTMLElement(relatedTarget))\n                return;\n            // A `focusout` event with a `null` `relatedTarget` will happen in at least two cases:\n            //\n            // 1. When the user switches app/tabs/windows/the browser itself loses focus.\n            // 2. In Google Chrome, when the focused element is removed from the DOM.\n            //\n            // We let the browser do its thing here because:\n            //\n            // 1. The browser already keeps a memory of what's focused for when the\n            // page gets refocused.\n            // 2. In Google Chrome, if we try to focus the deleted focused element it throws\n            // the CPU to 100%, so we avoid doing anything for this reason here too.\n            if (relatedTarget === null)\n                return;\n            // If the focus has moved to an actual legitimate element (`relatedTarget !== null`)\n            // that is outside the container, we move focus to the last valid focused element inside.\n            if (!container.contains(relatedTarget))\n                focus(lastFocusedElement, { select: true });\n        }\n        // When the focused element gets removed from the DOM, browsers move focus\n        // back to the document.body. In this case, we move focus to the container\n        // to keep focus trapped correctly.\n        // instead of leaning on document.activeElement, we use lastFocusedElement to check\n        // if the element still exists inside the container,\n        // if not then we focus to the container\n        function handleMutations(_) {\n            const lastFocusedElementExists = container?.contains(lastFocusedElement);\n            if (!lastFocusedElementExists) {\n                focus(container);\n            }\n        }\n        const unsubEvents = executeCallbacks(addEventListener(document, \"focusin\", handleFocusIn), addEventListener(document, \"focusout\", handleFocusOut));\n        const mutationObserver = new MutationObserver(handleMutations);\n        if (container) {\n            mutationObserver.observe(container, { childList: true, subtree: true });\n        }\n        return () => {\n            unsubEvents();\n            mutationObserver.disconnect();\n        };\n    });\n    $effect(() => {\n        if (forceMount.current)\n            return;\n        let container = ref.current;\n        const previouslyFocusedElement = document.activeElement;\n        untrack(() => {\n            handleMount(container, previouslyFocusedElement);\n        });\n        return () => {\n            if (!container)\n                return;\n            handleDestroy(previouslyFocusedElement);\n        };\n    });\n    $effect(() => {\n        if (!forceMount.current)\n            return;\n        let container = ref.current;\n        enabled.current;\n        const previouslyFocusedElement = document.activeElement;\n        untrack(() => {\n            handleMount(container, previouslyFocusedElement);\n        });\n        return () => {\n            if (!container)\n                return;\n            handleDestroy(previouslyFocusedElement);\n        };\n    });\n    function handleMount(container, prevFocusedElement) {\n        if (!container) {\n            container = document.getElementById(id.current);\n        }\n        if (!container)\n            return;\n        focusScopeStack.add(focusScope);\n        const hasFocusedCandidate = container.contains(prevFocusedElement);\n        if (!hasFocusedCandidate) {\n            const mountEvent = new CustomEvent(AUTOFOCUS_ON_MOUNT, EVENT_OPTIONS);\n            onOpenAutoFocus.current(mountEvent);\n            if (!mountEvent.defaultPrevented) {\n                afterTick(() => {\n                    if (!container)\n                        return;\n                    focusFirst(removeLinks(getTabbableCandidates(container)), { select: true });\n                    if (document.activeElement === prevFocusedElement) {\n                        focus(container);\n                    }\n                });\n            }\n        }\n    }\n    function handleDestroy(prevFocusedElement) {\n        const destroyEvent = new CustomEvent(AUTOFOCUS_ON_DESTROY, EVENT_OPTIONS);\n        onCloseAutoFocus.current(destroyEvent);\n        setTimeout(() => {\n            if (!destroyEvent.defaultPrevented && prevFocusedElement) {\n                focus(prevFocusedElement ?? document.body, { select: true });\n            }\n            focusScopeStack.remove(focusScope);\n        }, 0);\n    }\n    function handleKeydown(e) {\n        if (!enabled.current)\n            return;\n        if (!loop.current && !enabled.current)\n            return;\n        if (focusScope.paused)\n            return;\n        const isTabKey = e.key === kbd.TAB && !e.ctrlKey && !e.altKey && !e.metaKey;\n        const focusedElement = document.activeElement;\n        if (!(isTabKey && focusedElement))\n            return;\n        const container = ref.current;\n        if (!container)\n            return;\n        const [first, last] = getTabbableEdges(container);\n        const hasTabbableElementsInside = first && last;\n        if (!hasTabbableElementsInside) {\n            if (focusedElement === container) {\n                e.preventDefault();\n            }\n        }\n        else {\n            if (!e.shiftKey && focusedElement === last) {\n                e.preventDefault();\n                if (loop.current)\n                    focus(first, { select: true });\n            }\n            else if (e.shiftKey && focusedElement === first) {\n                e.preventDefault();\n                if (loop.current)\n                    focus(last, { select: true });\n            }\n        }\n    }\n    const props = $derived.by(() => ({\n        id: id.current,\n        tabindex: -1,\n        onkeydown: handleKeydown,\n    }));\n    return {\n        get props() {\n            return props;\n        },\n    };\n}\n","<script lang=\"ts\">\n\timport { box } from \"svelte-toolbelt\";\n\timport type { FocusScopeImplProps } from \"./types.js\";\n\timport { useFocusScope } from \"./useFocusScope.svelte.js\";\n\timport { noop } from \"../../../internal/noop.js\";\n\n\tlet {\n\t\tid,\n\t\ttrapFocus = false,\n\t\tloop = false,\n\t\tonCloseAutoFocus = noop,\n\t\tonOpenAutoFocus = noop,\n\t\tfocusScope,\n\t\tforceMount = false,\n\t}: FocusScopeImplProps = $props();\n\n\tconst focusScopeState = useFocusScope({\n\t\tenabled: box.with(() => trapFocus),\n\t\tloop: box.with(() => loop),\n\t\tonCloseAutoFocus: box.with(() => onCloseAutoFocus),\n\t\tonOpenAutoFocus: box.with(() => onOpenAutoFocus),\n\t\tid: box.with(() => id),\n\t\tforceMount: box.with(() => forceMount),\n\t});\n</script>\n\n{@render focusScope?.({ props: focusScopeState.props })}\n","import { untrack } from \"svelte\";\nimport { box, composeHandlers, executeCallbacks, useRefById, } from \"svelte-toolbelt\";\nimport { addEventListener } from \"../../../internal/events.js\";\nimport { noop } from \"../../../internal/noop.js\";\nimport { isHTMLElement } from \"../../../internal/is.js\";\nimport { isOrContainsTarget } from \"../../../internal/elements.js\";\nconst layers = new Map();\nexport class TextSelectionLayerState {\n    #id;\n    #onPointerDownProp;\n    #onPointerUpProp;\n    #enabled;\n    #unsubSelectionLock = noop;\n    #ref = box(null);\n    constructor(props) {\n        this.#id = props.id;\n        this.#enabled = props.preventOverflowTextSelection;\n        this.#onPointerDownProp = props.onPointerDown;\n        this.#onPointerUpProp = props.onPointerUp;\n        useRefById({\n            id: this.#id,\n            ref: this.#ref,\n            deps: () => this.#enabled.current,\n        });\n        let unsubEvents = noop;\n        $effect(() => {\n            if (this.#enabled.current) {\n                layers.set(this, untrack(() => this.#enabled));\n                unsubEvents = this.#addEventListeners();\n            }\n            return () => {\n                unsubEvents();\n                this.#resetSelectionLock();\n                layers.delete(this);\n            };\n        });\n    }\n    #addEventListeners() {\n        return executeCallbacks(addEventListener(document, \"pointerdown\", this.#pointerdown), addEventListener(document, \"pointerup\", composeHandlers(this.#resetSelectionLock, this.#onPointerUpProp)));\n    }\n    #pointerdown = (e) => {\n        const node = this.#ref.current;\n        const target = e.target;\n        if (!isHTMLElement(node) || !isHTMLElement(target) || !this.#enabled.current)\n            return;\n        /**\n         * We only lock user-selection overflow if layer is the top most layer and\n         * pointerdown occured inside the node. You are still allowed to select text\n         * outside the node provided pointerdown occurs outside the node.\n         */\n        if (!isHighestLayer(this) || !isOrContainsTarget(node, target))\n            return;\n        this.#onPointerDownProp.current(e);\n        if (e.defaultPrevented)\n            return;\n        this.#unsubSelectionLock = preventTextSelectionOverflow(node);\n    };\n    #resetSelectionLock = () => {\n        this.#unsubSelectionLock();\n        this.#unsubSelectionLock = noop;\n    };\n}\nexport function useTextSelectionLayer(props) {\n    return new TextSelectionLayerState(props);\n}\nconst getUserSelect = (node) => node.style.userSelect || node.style.webkitUserSelect;\nfunction preventTextSelectionOverflow(node) {\n    const body = document.body;\n    const originalBodyUserSelect = getUserSelect(body);\n    const originalNodeUserSelect = getUserSelect(node);\n    setUserSelect(body, \"none\");\n    setUserSelect(node, \"text\");\n    return () => {\n        setUserSelect(body, originalBodyUserSelect);\n        setUserSelect(node, originalNodeUserSelect);\n    };\n}\nfunction setUserSelect(node, value) {\n    node.style.userSelect = value;\n    node.style.webkitUserSelect = value;\n}\nfunction isHighestLayer(instance) {\n    const layersArr = [...layers];\n    if (!layersArr.length)\n        return false;\n    const highestLayer = layersArr.at(-1);\n    if (!highestLayer)\n        return false;\n    return highestLayer[0] === instance;\n}\n","<script lang=\"ts\">\n\timport { box } from \"svelte-toolbelt\";\n\timport type { TextSelectionLayerImplProps } from \"./types.js\";\n\timport { useTextSelectionLayer } from \"./useTextSelectionLayer.svelte.js\";\n\timport { noop } from \"../../../internal/noop.js\";\n\n\tlet {\n\t\tpreventOverflowTextSelection = true,\n\t\tonPointerDown = noop,\n\t\tonPointerUp = noop,\n\t\tid,\n\t\tchildren,\n\t\tenabled,\n\t}: TextSelectionLayerImplProps = $props();\n\n\tuseTextSelectionLayer({\n\t\tid: box.with(() => id),\n\t\tpreventOverflowTextSelection: box.with(() => preventOverflowTextSelection),\n\t\tonPointerDown: box.with(() => onPointerDown),\n\t\tonPointerUp: box.with(() => onPointerUp),\n\t\tenabled: box.with(() => enabled),\n\t});\n</script>\n\n{@render children?.()}\n","/** @import { Source } from '#client' */\nimport { set } from '../internal/client/reactivity/sources.js';\n\n/** @param {Source<number>} source */\nexport function increment(source) {\n\tset(source, source.v + 1);\n}\n","/** @import { Source } from '#client' */\nimport { DEV } from 'esm-env';\nimport { set, source } from '../internal/client/reactivity/sources.js';\nimport { get } from '../internal/client/runtime.js';\nimport { increment } from './utils.js';\n\n/**\n * @template K\n * @template V\n * @extends {Map<K, V>}\n */\nexport class SvelteMap extends Map {\n\t/** @type {Map<K, Source<number>>} */\n\t#sources = new Map();\n\t#version = source(0);\n\t#size = source(0);\n\n\t/**\n\t * @param {Iterable<readonly [K, V]> | null | undefined} [value]\n\t */\n\tconstructor(value) {\n\t\tsuper();\n\n\t\t// If the value is invalid then the native exception will fire here\n\t\tif (DEV) new Map(value);\n\n\t\tif (value) {\n\t\t\tfor (var [key, v] of value) {\n\t\t\t\tsuper.set(key, v);\n\t\t\t}\n\t\t\tthis.#size.v = super.size;\n\t\t}\n\t}\n\n\t/** @param {K} key */\n\thas(key) {\n\t\tvar sources = this.#sources;\n\t\tvar s = sources.get(key);\n\n\t\tif (s === undefined) {\n\t\t\tvar ret = super.get(key);\n\t\t\tif (ret !== undefined) {\n\t\t\t\ts = source(0);\n\t\t\t\tsources.set(key, s);\n\t\t\t} else {\n\t\t\t\t// We should always track the version in case\n\t\t\t\t// the Set ever gets this value in the future.\n\t\t\t\tget(this.#version);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\tget(s);\n\t\treturn true;\n\t}\n\n\t/**\n\t * @param {(value: V, key: K, map: Map<K, V>) => void} callbackfn\n\t * @param {any} [this_arg]\n\t */\n\tforEach(callbackfn, this_arg) {\n\t\tthis.#read_all();\n\t\tsuper.forEach(callbackfn, this_arg);\n\t}\n\n\t/** @param {K} key */\n\tget(key) {\n\t\tvar sources = this.#sources;\n\t\tvar s = sources.get(key);\n\n\t\tif (s === undefined) {\n\t\t\tvar ret = super.get(key);\n\t\t\tif (ret !== undefined) {\n\t\t\t\ts = source(0);\n\t\t\t\tsources.set(key, s);\n\t\t\t} else {\n\t\t\t\t// We should always track the version in case\n\t\t\t\t// the Set ever gets this value in the future.\n\t\t\t\tget(this.#version);\n\t\t\t\treturn undefined;\n\t\t\t}\n\t\t}\n\n\t\tget(s);\n\t\treturn super.get(key);\n\t}\n\n\t/**\n\t * @param {K} key\n\t * @param {V} value\n\t * */\n\tset(key, value) {\n\t\tvar sources = this.#sources;\n\t\tvar s = sources.get(key);\n\t\tvar prev_res = super.get(key);\n\t\tvar res = super.set(key, value);\n\t\tvar version = this.#version;\n\n\t\tif (s === undefined) {\n\t\t\tsources.set(key, source(0));\n\t\t\tset(this.#size, super.size);\n\t\t\tincrement(version);\n\t\t} else if (prev_res !== value) {\n\t\t\tincrement(s);\n\n\t\t\t// if not every reaction of s is a reaction of version we need to also include version\n\t\t\tvar v_reactions = version.reactions === null ? null : new Set(version.reactions);\n\t\t\tvar needs_version_increase =\n\t\t\t\tv_reactions === null ||\n\t\t\t\t!s.reactions?.every((r) =>\n\t\t\t\t\t/** @type {NonNullable<typeof v_reactions>} */ (v_reactions).has(r)\n\t\t\t\t);\n\t\t\tif (needs_version_increase) {\n\t\t\t\tincrement(version);\n\t\t\t}\n\t\t}\n\n\t\treturn res;\n\t}\n\n\t/** @param {K} key */\n\tdelete(key) {\n\t\tvar sources = this.#sources;\n\t\tvar s = sources.get(key);\n\t\tvar res = super.delete(key);\n\n\t\tif (s !== undefined) {\n\t\t\tsources.delete(key);\n\t\t\tset(this.#size, super.size);\n\t\t\tset(s, -1);\n\t\t\tincrement(this.#version);\n\t\t}\n\n\t\treturn res;\n\t}\n\n\tclear() {\n\t\tif (super.size === 0) {\n\t\t\treturn;\n\t\t}\n\t\t// Clear first, so we get nice console.log outputs with $inspect\n\t\tsuper.clear();\n\t\tvar sources = this.#sources;\n\t\tset(this.#size, 0);\n\t\tfor (var s of sources.values()) {\n\t\t\tset(s, -1);\n\t\t}\n\t\tincrement(this.#version);\n\t\tsources.clear();\n\t}\n\n\t#read_all() {\n\t\tget(this.#version);\n\n\t\tvar sources = this.#sources;\n\t\tif (this.#size.v !== sources.size) {\n\t\t\tfor (var key of super.keys()) {\n\t\t\t\tif (!sources.has(key)) {\n\t\t\t\t\tsources.set(key, source(0));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (var [, s] of this.#sources) {\n\t\t\tget(s);\n\t\t}\n\t}\n\n\tkeys() {\n\t\tget(this.#version);\n\t\treturn super.keys();\n\t}\n\n\tvalues() {\n\t\tthis.#read_all();\n\t\treturn super.values();\n\t}\n\n\tentries() {\n\t\tthis.#read_all();\n\t\treturn super.entries();\n\t}\n\n\t[Symbol.iterator]() {\n\t\treturn this.entries();\n\t}\n\n\tget size() {\n\t\tget(this.#size);\n\t\treturn super.size;\n\t}\n}\n","import { tick } from \"svelte\";\n/**\n * A class that contains a reactive `current` property\n *\n * Accepts an initial value, and an optional `start` function, which has a `set` function as its first argument,\n * which is used to update the value of the `current` property.\n *\n * @example\n * ```html\n * <script>\n * const now = new Readable(new Date(), (set) => {\n * \tconst interval = setInterval(() => set(new Date()), 1000);\n * \treturn () => clearInterval(interval);\n * });\n * </script>\n *\n * <p>{now.current.toLocaleTimeString()}</p>\n * ```\n *\n * @see {@link https://runed.dev/docs/utilities/readable}\n *\n */\nexport class Readable {\n    #current = $state();\n    #start;\n    constructor(initialValue, start) {\n        this.#current = initialValue;\n        this.#start = start;\n    }\n    #subscribers = 0;\n    #stop = null;\n    get current() {\n        if ($effect.tracking()) {\n            $effect(() => {\n                this.#subscribers++;\n                if (this.#subscribers === 1) {\n                    this.#subscribe(true);\n                }\n                return () => {\n                    tick().then(() => {\n                        this.#subscribers--;\n                        if (this.#subscribers === 0) {\n                            this.#unsubscribe();\n                        }\n                    });\n                };\n            });\n        }\n        else if (this.#subscribers === 0) {\n            this.#subscribe(false);\n            this.#unsubscribe();\n        }\n        return this.#current;\n    }\n    #subscribe(inEffect) {\n        this.#stop =\n            this.#start((value) => {\n                this.#current = value;\n            }, inEffect) ?? null;\n    }\n    #unsubscribe() {\n        if (this.#stop === null)\n            return;\n        this.#stop();\n        this.#stop = null;\n    }\n}\n","import { Readable } from \"../Readable/readable.svelte.js\";\nimport { browser } from \"../../internal/utils/browser.js\";\n/**\n * An object holding a reactive value that is equal to `document.activeElement`.\n * It automatically listens for changes, keeping the reference up to date.\n *\n * @see {@link https://runed.dev/docs/utilities/active-element}\n */\nexport const activeElement = new Readable(null, (set, insideEffect) => {\n    function update() {\n        if (!browser)\n            return;\n        set(document.activeElement);\n    }\n    update();\n    if (!insideEffect)\n        return;\n    document.addEventListener(\"focusin\", update);\n    document.addEventListener(\"focusout\", update);\n    return () => {\n        document.removeEventListener(\"focusin\", update);\n        document.removeEventListener(\"focusout\", update);\n    };\n});\n","export function isFunction(value) {\n    return typeof value === \"function\";\n}\nexport function isObject(value) {\n    return value !== null && typeof value === \"object\";\n}\n","import { isFunction } from \"./is.js\";\nexport function get(value) {\n    if (isFunction(value)) {\n        return value();\n    }\n    return value;\n}\n","import { get } from \"../../internal/utils/get.js\";\n/**\n * Returns a reactive value holding the size of `node`.\n *\n * Accepts an `options` object with the following properties:\n * - `initialSize`: The initial size of the element. Defaults to `{ width: 0, height: 0 }`.\n * - `box`: The box model to use. Can be either `\"content-box\"` or `\"border-box\"`. Defaults to `\"border-box\"`.\n *\n * @returns an object with `width` and `height` properties.\n *\n * @see {@link https://runed.dev/docs/utilities/element-size}\n */\nexport class ElementSize {\n    #size = $state({\n        width: 0,\n        height: 0,\n    });\n    constructor(node, options = { box: \"border-box\" }) {\n        this.#size = {\n            width: options.initialSize?.width ?? 0,\n            height: options.initialSize?.height ?? 0,\n        };\n        $effect(() => {\n            const node$ = get(node);\n            if (!node$)\n                return;\n            const observer = new ResizeObserver((entries) => {\n                for (const entry of entries) {\n                    const boxSize = options.box === \"content-box\" ? entry.contentBoxSize : entry.borderBoxSize;\n                    const boxSizeArr = Array.isArray(boxSize) ? boxSize : [boxSize];\n                    this.#size.width = boxSizeArr.reduce((acc, size) => Math.max(acc, size.inlineSize), 0);\n                    this.#size.height = boxSizeArr.reduce((acc, size) => Math.max(acc, size.blockSize), 0);\n                }\n            });\n            observer.observe(node$);\n            return () => {\n                observer.disconnect();\n            };\n        });\n    }\n    get width() {\n        return this.#size.width;\n    }\n    get height() {\n        return this.#size.height;\n    }\n}\n","import { isFunction } from \"../../internal/utils/is.js\";\n/**\n * Extracts the value from a getter or a value.\n * Optionally, a default value can be provided.\n */\nexport function extract(value, defaultValue) {\n    if (isFunction(value)) {\n        const getter = value;\n        return getter() ?? defaultValue ?? getter();\n    }\n    return value ?? defaultValue ?? value;\n}\n","/**\n * Holds the previous value of a getter.\n *\n * @see {@link https://runed.dev/docs/utilities/previous}\n */\nexport class Previous {\n    #previous = $state();\n    #curr;\n    constructor(getter) {\n        $effect(() => {\n            this.#previous = this.#curr;\n            this.#curr = getter();\n        });\n    }\n    get current() {\n        return this.#previous;\n    }\n}\n","import { extract } from \"../extract/extract.svelte.js\";\nimport { activeElement } from \"../activeElement/activeElement.svelte.js\";\n/**\n * Tracks whether the focus is within a target element.\n * @see {@link https://runed.dev/docs/utilities/is-focus-within}\n */\nexport class IsFocusWithin {\n    #node;\n    #target = $derived.by(() => extract(this.#node));\n    constructor(node) {\n        this.#node = node;\n    }\n    current = $derived.by(() => {\n        if (!this.#target || !activeElement.current)\n            return false;\n        return this.#target.contains(activeElement.current);\n    });\n}\n","export function createSharedHook(factory) {\n    let subscribers = 0;\n    let state = $state();\n    let scope;\n    function dispose() {\n        subscribers -= 1;\n        if (scope && subscribers <= 0) {\n            scope();\n            state = undefined;\n            scope = undefined;\n        }\n    }\n    return ((...args) => {\n        subscribers += 1;\n        if (state === undefined) {\n            scope = $effect.root(() => {\n                state = factory(...args);\n            });\n        }\n        $effect(() => {\n            return () => {\n                dispose();\n            };\n        });\n        return state;\n    });\n}\n","import { SvelteMap } from \"svelte/reactivity\";\nimport { afterSleep, afterTick, box } from \"svelte-toolbelt\";\nimport { Previous } from \"runed\";\nimport { untrack } from \"svelte\";\nimport { isBrowser, isIOS } from \"./is.js\";\nimport { addEventListener } from \"./events.js\";\nimport { useId } from \"./use-id.js\";\nimport { createSharedHook } from \"./create-shared-hook.svelte.js\";\nconst useBodyLockStackCount = createSharedHook(() => {\n    const map = new SvelteMap();\n    const locked = $derived.by(() => {\n        for (const value of map.values()) {\n            if (value) {\n                return true;\n            }\n        }\n        return false;\n    });\n    const prevLocked = new Previous(() => locked);\n    let initialBodyStyle = $state({});\n    let stopTouchMoveListener = null;\n    function resetBodyStyle() {\n        if (!isBrowser)\n            return;\n        document.body.style.paddingRight = initialBodyStyle.paddingRight ?? \"\";\n        document.body.style.marginRight = initialBodyStyle.marginRight ?? \"\";\n        document.body.style.pointerEvents = initialBodyStyle.pointerEvents ?? \"\";\n        document.body.style.removeProperty(\"--scrollbar-width\");\n        document.body.style.overflow = initialBodyStyle.overflow ?? \"\";\n        isIOS && stopTouchMoveListener?.();\n    }\n    $effect(() => {\n        const curr = locked;\n        return untrack(() => {\n            if (!curr) {\n                return;\n            }\n            const bodyStyle = getComputedStyle(document.body);\n            initialBodyStyle.overflow = bodyStyle.overflow;\n            initialBodyStyle.paddingRight = bodyStyle.paddingRight;\n            initialBodyStyle.marginRight = bodyStyle.marginRight;\n            initialBodyStyle.pointerEvents = bodyStyle.pointerEvents;\n            // TODO: account for RTL direction, etc.\n            const verticalScrollbarWidth = window.innerWidth - document.documentElement.clientWidth;\n            const paddingRight = Number.parseInt(initialBodyStyle.paddingRight ?? \"0\", 10);\n            const config = {\n                padding: paddingRight + verticalScrollbarWidth,\n                margin: Number.parseInt(initialBodyStyle.marginRight ?? \"0\", 10),\n            };\n            if (verticalScrollbarWidth > 0) {\n                document.body.style.paddingRight = `${config.padding}px`;\n                document.body.style.marginRight = `${config.margin}px`;\n                document.body.style.setProperty(\"--scrollbar-width\", `${verticalScrollbarWidth}px`);\n                document.body.style.overflow = \"hidden\";\n            }\n            if (isIOS) {\n                stopTouchMoveListener = addEventListener(document, \"touchmove\", (e) => {\n                    if (e.target !== document.documentElement)\n                        return;\n                    if (e.touches.length > 1)\n                        return;\n                    e.preventDefault();\n                }, { passive: false });\n            }\n            afterTick(() => {\n                document.body.style.pointerEvents = \"none\";\n                document.body.style.overflow = \"hidden\";\n            });\n        });\n    });\n    $effect(() => {\n        return () => {\n            stopTouchMoveListener?.();\n        };\n    });\n    return {\n        get map() {\n            return map;\n        },\n        resetBodyStyle,\n    };\n});\nexport function useBodyScrollLock(initialState, restoreScrollDelay = () => null) {\n    const id = useId();\n    const countState = useBodyLockStackCount();\n    const _restoreScrollDelay = $derived(restoreScrollDelay());\n    countState.map.set(id, initialState ?? false);\n    const locked = box.with(() => countState.map.get(id) ?? false, (v) => countState.map.set(id, v));\n    $effect(() => {\n        return () => {\n            countState.map.delete(id);\n            const length = Array.from(countState.map.values()).length;\n            if (length === 0) {\n                if (_restoreScrollDelay === null) {\n                    countState.resetBodyStyle();\n                }\n                else {\n                    afterSleep(_restoreScrollDelay, () => countState.resetBodyStyle());\n                }\n            }\n        };\n    });\n    return locked;\n}\n","<script lang=\"ts\">\n\timport type { ScrollLockProps } from \"./index.js\";\n\timport { useBodyScrollLock } from \"../../../internal/use-body-scroll-lock.svelte.js\";\n\n\tlet { preventScroll = true, restoreScrollDelay = null }: ScrollLockProps = $props();\n\n\tuseBodyScrollLock(preventScroll, () => restoreScrollDelay);\n</script>\n","export function shouldTrapFocus({ forceMount, present, trapFocus, open, }) {\n    if (forceMount) {\n        return open && trapFocus;\n    }\n    return present && trapFocus;\n}\n","<script lang=\"ts\">\n\timport { box, mergeProps } from \"svelte-toolbelt\";\n\timport { useDialogOverlay } from \"../dialog.svelte.js\";\n\timport type { DialogOverlayProps } from \"../types.js\";\n\timport { useId } from \"../../../internal/use-id.js\";\n\timport PresenceLayer from \"../../utilities/presence-layer/presence-layer.svelte\";\n\n\tlet {\n\t\tid = useId(),\n\t\tforceMount = false,\n\t\tchild,\n\t\tchildren,\n\t\tref = $bindable(null),\n\t\t...restProps\n\t}: DialogOverlayProps = $props();\n\n\tconst overlayState = useDialogOverlay({\n\t\tid: box.with(() => id),\n\t\tref: box.with(\n\t\t\t() => ref,\n\t\t\t(v) => (ref = v)\n\t\t),\n\t});\n\n\tconst mergedProps = $derived(mergeProps(restProps, overlayState.props));\n</script>\n\n<PresenceLayer {id} present={overlayState.root.open.current || forceMount}>\n\t{#snippet presence()}\n\t\t{#if child}\n\t\t\t{@render child({ props: mergeProps(mergedProps), ...overlayState.snippetProps })}\n\t\t{:else}\n\t\t\t<div {...mergeProps(mergedProps)}>\n\t\t\t\t{@render children?.(overlayState.snippetProps)}\n\t\t\t</div>\n\t\t{/if}\n\t{/snippet}\n</PresenceLayer>\n","/**\n * Checks if two arrays are equal by comparing their values.\n */\nexport function arraysAreEqual(arr1, arr2) {\n    if (arr1.length !== arr2.length) {\n        return false;\n    }\n    return arr1.every((value, index) => isEqual(value, arr2[index]));\n}\n/**\n * A utility function that compares two values for equality.\n */\nfunction isEqual(a, b) {\n    if (Number.isNaN(a) && Number.isNaN(b)) {\n        return true;\n    }\n    if (Array.isArray(a) && Array.isArray(b)) {\n        return arraysAreEqual(a, b);\n    }\n    if (typeof a === \"object\" && typeof b === \"object\") {\n        return isDeepEqual(a, b);\n    }\n    return Object.is(a, b);\n}\n/**\n * A utility function that compares two values for deep equality.\n */\nfunction isDeepEqual(a, b) {\n    if (typeof a !== \"object\" || typeof b !== \"object\" || a === null || b === null) {\n        return false;\n    }\n    const aKeys = Object.keys(a);\n    const bKeys = Object.keys(b);\n    if (aKeys.length !== bKeys.length) {\n        return false;\n    }\n    for (const key of aKeys) {\n        if (!bKeys.includes(key)) {\n            return false;\n        }\n        if (!isEqual(a[key], b[key])) {\n            return false;\n        }\n    }\n    return true;\n}\n/**\n * Splits an array into chunks of a given size.\n * @param arr The array to split.\n * @param size The size of each chunk.\n * @returns An array of arrays, where each sub-array has `size` elements from the original array.\n * @example ```ts\n * const arr = [1, 2, 3, 4, 5, 6, 7, 8];\n * const chunks = chunk(arr, 3);\n * // chunks = [[1, 2, 3], [4, 5, 6], [7, 8]]\n * ```\n */\nexport function chunk(arr, size) {\n    if (size <= 0) {\n        return [];\n    }\n    const result = [];\n    for (let i = 0; i < arr.length; i += size) {\n        result.push(arr.slice(i, i + size));\n    }\n    return result;\n}\n/**\n * Checks if the given index is valid for the given array.\n *\n * @param index - The index to check\n * @param arr - The array to check\n */\nexport function isValidIndex(index, arr) {\n    return index >= 0 && index < arr.length;\n}\n/**\n * Returns the array element after the given index, or undefined for out-of-bounds or empty arrays.\n * @param array the array.\n * @param index the index of the current element.\n * @param loop loop to the beginning of the array if the next index is out of bounds?\n */\n/**\n * Returns the array element after the given index, or undefined for out-of-bounds or empty arrays.\n * For single-element arrays, returns the element if the index is 0.\n * @param array the array.\n * @param index the index of the current element.\n * @param loop loop to the beginning of the array if the next index is out of bounds?\n */\nexport function next(array, index, loop = true) {\n    if (array.length === 0 || index < 0 || index >= array.length) {\n        return undefined;\n    }\n    if (array.length === 1 && index === 0) {\n        return array[0];\n    }\n    if (index === array.length - 1) {\n        return loop ? array[0] : undefined;\n    }\n    return array[index + 1];\n}\n/**\n * Returns the array element prior to the given index, or undefined for out-of-bounds or empty arrays.\n * For single-element arrays, returns the element if the index is 0.\n * @param array the array.\n * @param index the index of the current element.\n * @param loop loop to the end of the array if the previous index is out of bounds?\n */\nexport function prev(array, index, loop = true) {\n    if (array.length === 0 || index < 0 || index >= array.length) {\n        return undefined;\n    }\n    if (array.length === 1 && index === 0) {\n        return array[0];\n    }\n    if (index === 0) {\n        return loop ? array[array.length - 1] : undefined;\n    }\n    return array[index - 1];\n}\n/**\n * Returns the element some number after the given index. If the target index is out of bounds:\n *   - If looping is disabled, the first or last element will be returned.\n *   - If looping is enabled, it will wrap around the array.\n * Returns undefined for empty arrays or out-of-bounds initial indices.\n * @param array the array.\n * @param index the index of the current element.\n * @param increment the number of elements to move forward (can be negative).\n * @param loop loop around the array if the target index is out of bounds?\n */\nexport function forward(array, index, increment, loop = true) {\n    if (array.length === 0 || index < 0 || index >= array.length) {\n        return undefined;\n    }\n    let targetIndex = index + increment;\n    if (loop) {\n        // Ensure positive modulus\n        targetIndex = ((targetIndex % array.length) + array.length) % array.length;\n    }\n    else {\n        // Clamp to array bounds when not looping\n        targetIndex = Math.max(0, Math.min(targetIndex, array.length - 1));\n    }\n    return array[targetIndex];\n}\n/**\n * Returns the element some number before the given index. If the target index is out of bounds:\n *   - If looping is disabled, the first or last element will be returned.\n *   - If looping is enabled, it will wrap around the array.\n * Returns undefined for empty arrays or out-of-bounds initial indices.\n * @param array the array.\n * @param index the index of the current element.\n * @param decrement the number of elements to move backward (can be negative).\n * @param loop loop around the array if the target index is out of bounds?\n */\nexport function backward(array, index, decrement, loop = true) {\n    if (array.length === 0 || index < 0 || index >= array.length) {\n        return undefined;\n    }\n    let targetIndex = index - decrement;\n    if (loop) {\n        // Ensure positive modulus\n        targetIndex = ((targetIndex % array.length) + array.length) % array.length;\n    }\n    else {\n        // Clamp to array bounds when not looping\n        targetIndex = Math.max(0, Math.min(targetIndex, array.length - 1));\n    }\n    return array[targetIndex];\n}\n/**\n * This is the \"meat\" of the typeahead matching logic. It takes in all the values,\n * the search and the current match, and returns the next match (or `undefined`).\n *\n * We normalize the search because if a user has repeatedly pressed a character,\n * we want the exact same behavior as if we only had that one character\n * (ie. cycle through options starting with that character)\n *\n * We also reorder the values by wrapping the array around the current match.\n * This is so we always look forward from the current match, and picking the first\n * match will always be the correct one.\n *\n * Finally, if the normalized search is exactly one character, we exclude the\n * current match from the values because otherwise it would be the first to match always\n * and focus would never move. This is as opposed to the regular case, where we\n * don't want focus to move if the current match still matches.\n */\nexport function getNextMatch(values, search, currentMatch) {\n    const isRepeated = search.length > 1 && Array.from(search).every((char) => char === search[0]);\n    const normalizedSearch = isRepeated ? search[0] : search;\n    const currentMatchIndex = currentMatch ? values.indexOf(currentMatch) : -1;\n    let wrappedValues = wrapArray(values, Math.max(currentMatchIndex, 0));\n    const excludeCurrentMatch = normalizedSearch.length === 1;\n    if (excludeCurrentMatch)\n        wrappedValues = wrappedValues.filter((v) => v !== currentMatch);\n    const nextMatch = wrappedValues.find((value) => value?.toLowerCase().startsWith(normalizedSearch.toLowerCase()));\n    return nextMatch !== currentMatch ? nextMatch : undefined;\n}\n/**\n * Wraps an array around itself at a given start index\n * Example: `wrapArray(['a', 'b', 'c', 'd'], 2) === ['c', 'd', 'a', 'b']`\n */\nexport function wrapArray(array, startIndex) {\n    return array.map((_, index) => array[(startIndex + index) % array.length]);\n}\n","/**\n * Custom positioning reference element.\n * @see https://floating-ui.com/docs/virtual-elements\n */\n\nconst sides = ['top', 'right', 'bottom', 'left'];\nconst alignments = ['start', 'end'];\nconst placements = /*#__PURE__*/sides.reduce((acc, side) => acc.concat(side, side + \"-\" + alignments[0], side + \"-\" + alignments[1]), []);\nconst min = Math.min;\nconst max = Math.max;\nconst round = Math.round;\nconst floor = Math.floor;\nconst createCoords = v => ({\n  x: v,\n  y: v\n});\nconst oppositeSideMap = {\n  left: 'right',\n  right: 'left',\n  bottom: 'top',\n  top: 'bottom'\n};\nconst oppositeAlignmentMap = {\n  start: 'end',\n  end: 'start'\n};\nfunction clamp(start, value, end) {\n  return max(start, min(value, end));\n}\nfunction evaluate(value, param) {\n  return typeof value === 'function' ? value(param) : value;\n}\nfunction getSide(placement) {\n  return placement.split('-')[0];\n}\nfunction getAlignment(placement) {\n  return placement.split('-')[1];\n}\nfunction getOppositeAxis(axis) {\n  return axis === 'x' ? 'y' : 'x';\n}\nfunction getAxisLength(axis) {\n  return axis === 'y' ? 'height' : 'width';\n}\nfunction getSideAxis(placement) {\n  return ['top', 'bottom'].includes(getSide(placement)) ? 'y' : 'x';\n}\nfunction getAlignmentAxis(placement) {\n  return getOppositeAxis(getSideAxis(placement));\n}\nfunction getAlignmentSides(placement, rects, rtl) {\n  if (rtl === void 0) {\n    rtl = false;\n  }\n  const alignment = getAlignment(placement);\n  const alignmentAxis = getAlignmentAxis(placement);\n  const length = getAxisLength(alignmentAxis);\n  let mainAlignmentSide = alignmentAxis === 'x' ? alignment === (rtl ? 'end' : 'start') ? 'right' : 'left' : alignment === 'start' ? 'bottom' : 'top';\n  if (rects.reference[length] > rects.floating[length]) {\n    mainAlignmentSide = getOppositePlacement(mainAlignmentSide);\n  }\n  return [mainAlignmentSide, getOppositePlacement(mainAlignmentSide)];\n}\nfunction getExpandedPlacements(placement) {\n  const oppositePlacement = getOppositePlacement(placement);\n  return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];\n}\nfunction getOppositeAlignmentPlacement(placement) {\n  return placement.replace(/start|end/g, alignment => oppositeAlignmentMap[alignment]);\n}\nfunction getSideList(side, isStart, rtl) {\n  const lr = ['left', 'right'];\n  const rl = ['right', 'left'];\n  const tb = ['top', 'bottom'];\n  const bt = ['bottom', 'top'];\n  switch (side) {\n    case 'top':\n    case 'bottom':\n      if (rtl) return isStart ? rl : lr;\n      return isStart ? lr : rl;\n    case 'left':\n    case 'right':\n      return isStart ? tb : bt;\n    default:\n      return [];\n  }\n}\nfunction getOppositeAxisPlacements(placement, flipAlignment, direction, rtl) {\n  const alignment = getAlignment(placement);\n  let list = getSideList(getSide(placement), direction === 'start', rtl);\n  if (alignment) {\n    list = list.map(side => side + \"-\" + alignment);\n    if (flipAlignment) {\n      list = list.concat(list.map(getOppositeAlignmentPlacement));\n    }\n  }\n  return list;\n}\nfunction getOppositePlacement(placement) {\n  return placement.replace(/left|right|bottom|top/g, side => oppositeSideMap[side]);\n}\nfunction expandPaddingObject(padding) {\n  return {\n    top: 0,\n    right: 0,\n    bottom: 0,\n    left: 0,\n    ...padding\n  };\n}\nfunction getPaddingObject(padding) {\n  return typeof padding !== 'number' ? expandPaddingObject(padding) : {\n    top: padding,\n    right: padding,\n    bottom: padding,\n    left: padding\n  };\n}\nfunction rectToClientRect(rect) {\n  const {\n    x,\n    y,\n    width,\n    height\n  } = rect;\n  return {\n    width,\n    height,\n    top: y,\n    left: x,\n    right: x + width,\n    bottom: y + height,\n    x,\n    y\n  };\n}\n\nexport { alignments, clamp, createCoords, evaluate, expandPaddingObject, floor, getAlignment, getAlignmentAxis, getAlignmentSides, getAxisLength, getExpandedPlacements, getOppositeAlignmentPlacement, getOppositeAxis, getOppositeAxisPlacements, getOppositePlacement, getPaddingObject, getSide, getSideAxis, max, min, placements, rectToClientRect, round, sides };\n","import { getSideAxis, getAlignmentAxis, getAxisLength, getSide, getAlignment, evaluate, getPaddingObject, rectToClientRect, min, clamp, placements, getAlignmentSides, getOppositeAlignmentPlacement, getOppositePlacement, getExpandedPlacements, getOppositeAxisPlacements, sides, max, getOppositeAxis } from '@floating-ui/utils';\nexport { rectToClientRect } from '@floating-ui/utils';\n\nfunction computeCoordsFromPlacement(_ref, placement, rtl) {\n  let {\n    reference,\n    floating\n  } = _ref;\n  const sideAxis = getSideAxis(placement);\n  const alignmentAxis = getAlignmentAxis(placement);\n  const alignLength = getAxisLength(alignmentAxis);\n  const side = getSide(placement);\n  const isVertical = sideAxis === 'y';\n  const commonX = reference.x + reference.width / 2 - floating.width / 2;\n  const commonY = reference.y + reference.height / 2 - floating.height / 2;\n  const commonAlign = reference[alignLength] / 2 - floating[alignLength] / 2;\n  let coords;\n  switch (side) {\n    case 'top':\n      coords = {\n        x: commonX,\n        y: reference.y - floating.height\n      };\n      break;\n    case 'bottom':\n      coords = {\n        x: commonX,\n        y: reference.y + reference.height\n      };\n      break;\n    case 'right':\n      coords = {\n        x: reference.x + reference.width,\n        y: commonY\n      };\n      break;\n    case 'left':\n      coords = {\n        x: reference.x - floating.width,\n        y: commonY\n      };\n      break;\n    default:\n      coords = {\n        x: reference.x,\n        y: reference.y\n      };\n  }\n  switch (getAlignment(placement)) {\n    case 'start':\n      coords[alignmentAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);\n      break;\n    case 'end':\n      coords[alignmentAxis] += commonAlign * (rtl && isVertical ? -1 : 1);\n      break;\n  }\n  return coords;\n}\n\n/**\n * Computes the `x` and `y` coordinates that will place the floating element\n * next to a given reference element.\n *\n * This export does not have any `platform` interface logic. You will need to\n * write one for the platform you are using Floating UI with.\n */\nconst computePosition = async (reference, floating, config) => {\n  const {\n    placement = 'bottom',\n    strategy = 'absolute',\n    middleware = [],\n    platform\n  } = config;\n  const validMiddleware = middleware.filter(Boolean);\n  const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(floating));\n  let rects = await platform.getElementRects({\n    reference,\n    floating,\n    strategy\n  });\n  let {\n    x,\n    y\n  } = computeCoordsFromPlacement(rects, placement, rtl);\n  let statefulPlacement = placement;\n  let middlewareData = {};\n  let resetCount = 0;\n  for (let i = 0; i < validMiddleware.length; i++) {\n    const {\n      name,\n      fn\n    } = validMiddleware[i];\n    const {\n      x: nextX,\n      y: nextY,\n      data,\n      reset\n    } = await fn({\n      x,\n      y,\n      initialPlacement: placement,\n      placement: statefulPlacement,\n      strategy,\n      middlewareData,\n      rects,\n      platform,\n      elements: {\n        reference,\n        floating\n      }\n    });\n    x = nextX != null ? nextX : x;\n    y = nextY != null ? nextY : y;\n    middlewareData = {\n      ...middlewareData,\n      [name]: {\n        ...middlewareData[name],\n        ...data\n      }\n    };\n    if (reset && resetCount <= 50) {\n      resetCount++;\n      if (typeof reset === 'object') {\n        if (reset.placement) {\n          statefulPlacement = reset.placement;\n        }\n        if (reset.rects) {\n          rects = reset.rects === true ? await platform.getElementRects({\n            reference,\n            floating,\n            strategy\n          }) : reset.rects;\n        }\n        ({\n          x,\n          y\n        } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));\n      }\n      i = -1;\n    }\n  }\n  return {\n    x,\n    y,\n    placement: statefulPlacement,\n    strategy,\n    middlewareData\n  };\n};\n\n/**\n * Resolves with an object of overflow side offsets that determine how much the\n * element is overflowing a given clipping boundary on each side.\n * - positive = overflowing the boundary by that number of pixels\n * - negative = how many pixels left before it will overflow\n * - 0 = lies flush with the boundary\n * @see https://floating-ui.com/docs/detectOverflow\n */\nasync function detectOverflow(state, options) {\n  var _await$platform$isEle;\n  if (options === void 0) {\n    options = {};\n  }\n  const {\n    x,\n    y,\n    platform,\n    rects,\n    elements,\n    strategy\n  } = state;\n  const {\n    boundary = 'clippingAncestors',\n    rootBoundary = 'viewport',\n    elementContext = 'floating',\n    altBoundary = false,\n    padding = 0\n  } = evaluate(options, state);\n  const paddingObject = getPaddingObject(padding);\n  const altContext = elementContext === 'floating' ? 'reference' : 'floating';\n  const element = elements[altBoundary ? altContext : elementContext];\n  const clippingClientRect = rectToClientRect(await platform.getClippingRect({\n    element: ((_await$platform$isEle = await (platform.isElement == null ? void 0 : platform.isElement(element))) != null ? _await$platform$isEle : true) ? element : element.contextElement || (await (platform.getDocumentElement == null ? void 0 : platform.getDocumentElement(elements.floating))),\n    boundary,\n    rootBoundary,\n    strategy\n  }));\n  const rect = elementContext === 'floating' ? {\n    x,\n    y,\n    width: rects.floating.width,\n    height: rects.floating.height\n  } : rects.reference;\n  const offsetParent = await (platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(elements.floating));\n  const offsetScale = (await (platform.isElement == null ? void 0 : platform.isElement(offsetParent))) ? (await (platform.getScale == null ? void 0 : platform.getScale(offsetParent))) || {\n    x: 1,\n    y: 1\n  } : {\n    x: 1,\n    y: 1\n  };\n  const elementClientRect = rectToClientRect(platform.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform.convertOffsetParentRelativeRectToViewportRelativeRect({\n    elements,\n    rect,\n    offsetParent,\n    strategy\n  }) : rect);\n  return {\n    top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,\n    bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,\n    left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,\n    right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x\n  };\n}\n\n/**\n * Provides data to position an inner element of the floating element so that it\n * appears centered to the reference element.\n * @see https://floating-ui.com/docs/arrow\n */\nconst arrow = options => ({\n  name: 'arrow',\n  options,\n  async fn(state) {\n    const {\n      x,\n      y,\n      placement,\n      rects,\n      platform,\n      elements,\n      middlewareData\n    } = state;\n    // Since `element` is required, we don't Partial<> the type.\n    const {\n      element,\n      padding = 0\n    } = evaluate(options, state) || {};\n    if (element == null) {\n      return {};\n    }\n    const paddingObject = getPaddingObject(padding);\n    const coords = {\n      x,\n      y\n    };\n    const axis = getAlignmentAxis(placement);\n    const length = getAxisLength(axis);\n    const arrowDimensions = await platform.getDimensions(element);\n    const isYAxis = axis === 'y';\n    const minProp = isYAxis ? 'top' : 'left';\n    const maxProp = isYAxis ? 'bottom' : 'right';\n    const clientProp = isYAxis ? 'clientHeight' : 'clientWidth';\n    const endDiff = rects.reference[length] + rects.reference[axis] - coords[axis] - rects.floating[length];\n    const startDiff = coords[axis] - rects.reference[axis];\n    const arrowOffsetParent = await (platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(element));\n    let clientSize = arrowOffsetParent ? arrowOffsetParent[clientProp] : 0;\n\n    // DOM platform can return `window` as the `offsetParent`.\n    if (!clientSize || !(await (platform.isElement == null ? void 0 : platform.isElement(arrowOffsetParent)))) {\n      clientSize = elements.floating[clientProp] || rects.floating[length];\n    }\n    const centerToReference = endDiff / 2 - startDiff / 2;\n\n    // If the padding is large enough that it causes the arrow to no longer be\n    // centered, modify the padding so that it is centered.\n    const largestPossiblePadding = clientSize / 2 - arrowDimensions[length] / 2 - 1;\n    const minPadding = min(paddingObject[minProp], largestPossiblePadding);\n    const maxPadding = min(paddingObject[maxProp], largestPossiblePadding);\n\n    // Make sure the arrow doesn't overflow the floating element if the center\n    // point is outside the floating element's bounds.\n    const min$1 = minPadding;\n    const max = clientSize - arrowDimensions[length] - maxPadding;\n    const center = clientSize / 2 - arrowDimensions[length] / 2 + centerToReference;\n    const offset = clamp(min$1, center, max);\n\n    // If the reference is small enough that the arrow's padding causes it to\n    // to point to nothing for an aligned placement, adjust the offset of the\n    // floating element itself. To ensure `shift()` continues to take action,\n    // a single reset is performed when this is true.\n    const shouldAddOffset = !middlewareData.arrow && getAlignment(placement) != null && center !== offset && rects.reference[length] / 2 - (center < min$1 ? minPadding : maxPadding) - arrowDimensions[length] / 2 < 0;\n    const alignmentOffset = shouldAddOffset ? center < min$1 ? center - min$1 : center - max : 0;\n    return {\n      [axis]: coords[axis] + alignmentOffset,\n      data: {\n        [axis]: offset,\n        centerOffset: center - offset - alignmentOffset,\n        ...(shouldAddOffset && {\n          alignmentOffset\n        })\n      },\n      reset: shouldAddOffset\n    };\n  }\n});\n\nfunction getPlacementList(alignment, autoAlignment, allowedPlacements) {\n  const allowedPlacementsSortedByAlignment = alignment ? [...allowedPlacements.filter(placement => getAlignment(placement) === alignment), ...allowedPlacements.filter(placement => getAlignment(placement) !== alignment)] : allowedPlacements.filter(placement => getSide(placement) === placement);\n  return allowedPlacementsSortedByAlignment.filter(placement => {\n    if (alignment) {\n      return getAlignment(placement) === alignment || (autoAlignment ? getOppositeAlignmentPlacement(placement) !== placement : false);\n    }\n    return true;\n  });\n}\n/**\n * Optimizes the visibility of the floating element by choosing the placement\n * that has the most space available automatically, without needing to specify a\n * preferred placement. Alternative to `flip`.\n * @see https://floating-ui.com/docs/autoPlacement\n */\nconst autoPlacement = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'autoPlacement',\n    options,\n    async fn(state) {\n      var _middlewareData$autoP, _middlewareData$autoP2, _placementsThatFitOnE;\n      const {\n        rects,\n        middlewareData,\n        placement,\n        platform,\n        elements\n      } = state;\n      const {\n        crossAxis = false,\n        alignment,\n        allowedPlacements = placements,\n        autoAlignment = true,\n        ...detectOverflowOptions\n      } = evaluate(options, state);\n      const placements$1 = alignment !== undefined || allowedPlacements === placements ? getPlacementList(alignment || null, autoAlignment, allowedPlacements) : allowedPlacements;\n      const overflow = await detectOverflow(state, detectOverflowOptions);\n      const currentIndex = ((_middlewareData$autoP = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP.index) || 0;\n      const currentPlacement = placements$1[currentIndex];\n      if (currentPlacement == null) {\n        return {};\n      }\n      const alignmentSides = getAlignmentSides(currentPlacement, rects, await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating)));\n\n      // Make `computeCoords` start from the right place.\n      if (placement !== currentPlacement) {\n        return {\n          reset: {\n            placement: placements$1[0]\n          }\n        };\n      }\n      const currentOverflows = [overflow[getSide(currentPlacement)], overflow[alignmentSides[0]], overflow[alignmentSides[1]]];\n      const allOverflows = [...(((_middlewareData$autoP2 = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP2.overflows) || []), {\n        placement: currentPlacement,\n        overflows: currentOverflows\n      }];\n      const nextPlacement = placements$1[currentIndex + 1];\n\n      // There are more placements to check.\n      if (nextPlacement) {\n        return {\n          data: {\n            index: currentIndex + 1,\n            overflows: allOverflows\n          },\n          reset: {\n            placement: nextPlacement\n          }\n        };\n      }\n      const placementsSortedByMostSpace = allOverflows.map(d => {\n        const alignment = getAlignment(d.placement);\n        return [d.placement, alignment && crossAxis ?\n        // Check along the mainAxis and main crossAxis side.\n        d.overflows.slice(0, 2).reduce((acc, v) => acc + v, 0) :\n        // Check only the mainAxis.\n        d.overflows[0], d.overflows];\n      }).sort((a, b) => a[1] - b[1]);\n      const placementsThatFitOnEachSide = placementsSortedByMostSpace.filter(d => d[2].slice(0,\n      // Aligned placements should not check their opposite crossAxis\n      // side.\n      getAlignment(d[0]) ? 2 : 3).every(v => v <= 0));\n      const resetPlacement = ((_placementsThatFitOnE = placementsThatFitOnEachSide[0]) == null ? void 0 : _placementsThatFitOnE[0]) || placementsSortedByMostSpace[0][0];\n      if (resetPlacement !== placement) {\n        return {\n          data: {\n            index: currentIndex + 1,\n            overflows: allOverflows\n          },\n          reset: {\n            placement: resetPlacement\n          }\n        };\n      }\n      return {};\n    }\n  };\n};\n\n/**\n * Optimizes the visibility of the floating element by flipping the `placement`\n * in order to keep it in view when the preferred placement(s) will overflow the\n * clipping boundary. Alternative to `autoPlacement`.\n * @see https://floating-ui.com/docs/flip\n */\nconst flip = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'flip',\n    options,\n    async fn(state) {\n      var _middlewareData$arrow, _middlewareData$flip;\n      const {\n        placement,\n        middlewareData,\n        rects,\n        initialPlacement,\n        platform,\n        elements\n      } = state;\n      const {\n        mainAxis: checkMainAxis = true,\n        crossAxis: checkCrossAxis = true,\n        fallbackPlacements: specifiedFallbackPlacements,\n        fallbackStrategy = 'bestFit',\n        fallbackAxisSideDirection = 'none',\n        flipAlignment = true,\n        ...detectOverflowOptions\n      } = evaluate(options, state);\n\n      // If a reset by the arrow was caused due to an alignment offset being\n      // added, we should skip any logic now since `flip()` has already done its\n      // work.\n      // https://github.com/floating-ui/floating-ui/issues/2549#issuecomment-1719601643\n      if ((_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {\n        return {};\n      }\n      const side = getSide(placement);\n      const initialSideAxis = getSideAxis(initialPlacement);\n      const isBasePlacement = getSide(initialPlacement) === initialPlacement;\n      const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating));\n      const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement));\n      const hasFallbackAxisSideDirection = fallbackAxisSideDirection !== 'none';\n      if (!specifiedFallbackPlacements && hasFallbackAxisSideDirection) {\n        fallbackPlacements.push(...getOppositeAxisPlacements(initialPlacement, flipAlignment, fallbackAxisSideDirection, rtl));\n      }\n      const placements = [initialPlacement, ...fallbackPlacements];\n      const overflow = await detectOverflow(state, detectOverflowOptions);\n      const overflows = [];\n      let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];\n      if (checkMainAxis) {\n        overflows.push(overflow[side]);\n      }\n      if (checkCrossAxis) {\n        const sides = getAlignmentSides(placement, rects, rtl);\n        overflows.push(overflow[sides[0]], overflow[sides[1]]);\n      }\n      overflowsData = [...overflowsData, {\n        placement,\n        overflows\n      }];\n\n      // One or more sides is overflowing.\n      if (!overflows.every(side => side <= 0)) {\n        var _middlewareData$flip2, _overflowsData$filter;\n        const nextIndex = (((_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) || 0) + 1;\n        const nextPlacement = placements[nextIndex];\n        if (nextPlacement) {\n          // Try next placement and re-run the lifecycle.\n          return {\n            data: {\n              index: nextIndex,\n              overflows: overflowsData\n            },\n            reset: {\n              placement: nextPlacement\n            }\n          };\n        }\n\n        // First, find the candidates that fit on the mainAxis side of overflow,\n        // then find the placement that fits the best on the main crossAxis side.\n        let resetPlacement = (_overflowsData$filter = overflowsData.filter(d => d.overflows[0] <= 0).sort((a, b) => a.overflows[1] - b.overflows[1])[0]) == null ? void 0 : _overflowsData$filter.placement;\n\n        // Otherwise fallback.\n        if (!resetPlacement) {\n          switch (fallbackStrategy) {\n            case 'bestFit':\n              {\n                var _overflowsData$filter2;\n                const placement = (_overflowsData$filter2 = overflowsData.filter(d => {\n                  if (hasFallbackAxisSideDirection) {\n                    const currentSideAxis = getSideAxis(d.placement);\n                    return currentSideAxis === initialSideAxis ||\n                    // Create a bias to the `y` side axis due to horizontal\n                    // reading directions favoring greater width.\n                    currentSideAxis === 'y';\n                  }\n                  return true;\n                }).map(d => [d.placement, d.overflows.filter(overflow => overflow > 0).reduce((acc, overflow) => acc + overflow, 0)]).sort((a, b) => a[1] - b[1])[0]) == null ? void 0 : _overflowsData$filter2[0];\n                if (placement) {\n                  resetPlacement = placement;\n                }\n                break;\n              }\n            case 'initialPlacement':\n              resetPlacement = initialPlacement;\n              break;\n          }\n        }\n        if (placement !== resetPlacement) {\n          return {\n            reset: {\n              placement: resetPlacement\n            }\n          };\n        }\n      }\n      return {};\n    }\n  };\n};\n\nfunction getSideOffsets(overflow, rect) {\n  return {\n    top: overflow.top - rect.height,\n    right: overflow.right - rect.width,\n    bottom: overflow.bottom - rect.height,\n    left: overflow.left - rect.width\n  };\n}\nfunction isAnySideFullyClipped(overflow) {\n  return sides.some(side => overflow[side] >= 0);\n}\n/**\n * Provides data to hide the floating element in applicable situations, such as\n * when it is not in the same clipping context as the reference element.\n * @see https://floating-ui.com/docs/hide\n */\nconst hide = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'hide',\n    options,\n    async fn(state) {\n      const {\n        rects\n      } = state;\n      const {\n        strategy = 'referenceHidden',\n        ...detectOverflowOptions\n      } = evaluate(options, state);\n      switch (strategy) {\n        case 'referenceHidden':\n          {\n            const overflow = await detectOverflow(state, {\n              ...detectOverflowOptions,\n              elementContext: 'reference'\n            });\n            const offsets = getSideOffsets(overflow, rects.reference);\n            return {\n              data: {\n                referenceHiddenOffsets: offsets,\n                referenceHidden: isAnySideFullyClipped(offsets)\n              }\n            };\n          }\n        case 'escaped':\n          {\n            const overflow = await detectOverflow(state, {\n              ...detectOverflowOptions,\n              altBoundary: true\n            });\n            const offsets = getSideOffsets(overflow, rects.floating);\n            return {\n              data: {\n                escapedOffsets: offsets,\n                escaped: isAnySideFullyClipped(offsets)\n              }\n            };\n          }\n        default:\n          {\n            return {};\n          }\n      }\n    }\n  };\n};\n\nfunction getBoundingRect(rects) {\n  const minX = min(...rects.map(rect => rect.left));\n  const minY = min(...rects.map(rect => rect.top));\n  const maxX = max(...rects.map(rect => rect.right));\n  const maxY = max(...rects.map(rect => rect.bottom));\n  return {\n    x: minX,\n    y: minY,\n    width: maxX - minX,\n    height: maxY - minY\n  };\n}\nfunction getRectsByLine(rects) {\n  const sortedRects = rects.slice().sort((a, b) => a.y - b.y);\n  const groups = [];\n  let prevRect = null;\n  for (let i = 0; i < sortedRects.length; i++) {\n    const rect = sortedRects[i];\n    if (!prevRect || rect.y - prevRect.y > prevRect.height / 2) {\n      groups.push([rect]);\n    } else {\n      groups[groups.length - 1].push(rect);\n    }\n    prevRect = rect;\n  }\n  return groups.map(rect => rectToClientRect(getBoundingRect(rect)));\n}\n/**\n * Provides improved positioning for inline reference elements that can span\n * over multiple lines, such as hyperlinks or range selections.\n * @see https://floating-ui.com/docs/inline\n */\nconst inline = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'inline',\n    options,\n    async fn(state) {\n      const {\n        placement,\n        elements,\n        rects,\n        platform,\n        strategy\n      } = state;\n      // A MouseEvent's client{X,Y} coords can be up to 2 pixels off a\n      // ClientRect's bounds, despite the event listener being triggered. A\n      // padding of 2 seems to handle this issue.\n      const {\n        padding = 2,\n        x,\n        y\n      } = evaluate(options, state);\n      const nativeClientRects = Array.from((await (platform.getClientRects == null ? void 0 : platform.getClientRects(elements.reference))) || []);\n      const clientRects = getRectsByLine(nativeClientRects);\n      const fallback = rectToClientRect(getBoundingRect(nativeClientRects));\n      const paddingObject = getPaddingObject(padding);\n      function getBoundingClientRect() {\n        // There are two rects and they are disjoined.\n        if (clientRects.length === 2 && clientRects[0].left > clientRects[1].right && x != null && y != null) {\n          // Find the first rect in which the point is fully inside.\n          return clientRects.find(rect => x > rect.left - paddingObject.left && x < rect.right + paddingObject.right && y > rect.top - paddingObject.top && y < rect.bottom + paddingObject.bottom) || fallback;\n        }\n\n        // There are 2 or more connected rects.\n        if (clientRects.length >= 2) {\n          if (getSideAxis(placement) === 'y') {\n            const firstRect = clientRects[0];\n            const lastRect = clientRects[clientRects.length - 1];\n            const isTop = getSide(placement) === 'top';\n            const top = firstRect.top;\n            const bottom = lastRect.bottom;\n            const left = isTop ? firstRect.left : lastRect.left;\n            const right = isTop ? firstRect.right : lastRect.right;\n            const width = right - left;\n            const height = bottom - top;\n            return {\n              top,\n              bottom,\n              left,\n              right,\n              width,\n              height,\n              x: left,\n              y: top\n            };\n          }\n          const isLeftSide = getSide(placement) === 'left';\n          const maxRight = max(...clientRects.map(rect => rect.right));\n          const minLeft = min(...clientRects.map(rect => rect.left));\n          const measureRects = clientRects.filter(rect => isLeftSide ? rect.left === minLeft : rect.right === maxRight);\n          const top = measureRects[0].top;\n          const bottom = measureRects[measureRects.length - 1].bottom;\n          const left = minLeft;\n          const right = maxRight;\n          const width = right - left;\n          const height = bottom - top;\n          return {\n            top,\n            bottom,\n            left,\n            right,\n            width,\n            height,\n            x: left,\n            y: top\n          };\n        }\n        return fallback;\n      }\n      const resetRects = await platform.getElementRects({\n        reference: {\n          getBoundingClientRect\n        },\n        floating: elements.floating,\n        strategy\n      });\n      if (rects.reference.x !== resetRects.reference.x || rects.reference.y !== resetRects.reference.y || rects.reference.width !== resetRects.reference.width || rects.reference.height !== resetRects.reference.height) {\n        return {\n          reset: {\n            rects: resetRects\n          }\n        };\n      }\n      return {};\n    }\n  };\n};\n\n// For type backwards-compatibility, the `OffsetOptions` type was also\n// Derivable.\n\nasync function convertValueToCoords(state, options) {\n  const {\n    placement,\n    platform,\n    elements\n  } = state;\n  const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating));\n  const side = getSide(placement);\n  const alignment = getAlignment(placement);\n  const isVertical = getSideAxis(placement) === 'y';\n  const mainAxisMulti = ['left', 'top'].includes(side) ? -1 : 1;\n  const crossAxisMulti = rtl && isVertical ? -1 : 1;\n  const rawValue = evaluate(options, state);\n\n  // eslint-disable-next-line prefer-const\n  let {\n    mainAxis,\n    crossAxis,\n    alignmentAxis\n  } = typeof rawValue === 'number' ? {\n    mainAxis: rawValue,\n    crossAxis: 0,\n    alignmentAxis: null\n  } : {\n    mainAxis: rawValue.mainAxis || 0,\n    crossAxis: rawValue.crossAxis || 0,\n    alignmentAxis: rawValue.alignmentAxis\n  };\n  if (alignment && typeof alignmentAxis === 'number') {\n    crossAxis = alignment === 'end' ? alignmentAxis * -1 : alignmentAxis;\n  }\n  return isVertical ? {\n    x: crossAxis * crossAxisMulti,\n    y: mainAxis * mainAxisMulti\n  } : {\n    x: mainAxis * mainAxisMulti,\n    y: crossAxis * crossAxisMulti\n  };\n}\n\n/**\n * Modifies the placement by translating the floating element along the\n * specified axes.\n * A number (shorthand for `mainAxis` or distance), or an axes configuration\n * object may be passed.\n * @see https://floating-ui.com/docs/offset\n */\nconst offset = function (options) {\n  if (options === void 0) {\n    options = 0;\n  }\n  return {\n    name: 'offset',\n    options,\n    async fn(state) {\n      var _middlewareData$offse, _middlewareData$arrow;\n      const {\n        x,\n        y,\n        placement,\n        middlewareData\n      } = state;\n      const diffCoords = await convertValueToCoords(state, options);\n\n      // If the placement is the same and the arrow caused an alignment offset\n      // then we don't need to change the positioning coordinates.\n      if (placement === ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse.placement) && (_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {\n        return {};\n      }\n      return {\n        x: x + diffCoords.x,\n        y: y + diffCoords.y,\n        data: {\n          ...diffCoords,\n          placement\n        }\n      };\n    }\n  };\n};\n\n/**\n * Optimizes the visibility of the floating element by shifting it in order to\n * keep it in view when it will overflow the clipping boundary.\n * @see https://floating-ui.com/docs/shift\n */\nconst shift = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'shift',\n    options,\n    async fn(state) {\n      const {\n        x,\n        y,\n        placement\n      } = state;\n      const {\n        mainAxis: checkMainAxis = true,\n        crossAxis: checkCrossAxis = false,\n        limiter = {\n          fn: _ref => {\n            let {\n              x,\n              y\n            } = _ref;\n            return {\n              x,\n              y\n            };\n          }\n        },\n        ...detectOverflowOptions\n      } = evaluate(options, state);\n      const coords = {\n        x,\n        y\n      };\n      const overflow = await detectOverflow(state, detectOverflowOptions);\n      const crossAxis = getSideAxis(getSide(placement));\n      const mainAxis = getOppositeAxis(crossAxis);\n      let mainAxisCoord = coords[mainAxis];\n      let crossAxisCoord = coords[crossAxis];\n      if (checkMainAxis) {\n        const minSide = mainAxis === 'y' ? 'top' : 'left';\n        const maxSide = mainAxis === 'y' ? 'bottom' : 'right';\n        const min = mainAxisCoord + overflow[minSide];\n        const max = mainAxisCoord - overflow[maxSide];\n        mainAxisCoord = clamp(min, mainAxisCoord, max);\n      }\n      if (checkCrossAxis) {\n        const minSide = crossAxis === 'y' ? 'top' : 'left';\n        const maxSide = crossAxis === 'y' ? 'bottom' : 'right';\n        const min = crossAxisCoord + overflow[minSide];\n        const max = crossAxisCoord - overflow[maxSide];\n        crossAxisCoord = clamp(min, crossAxisCoord, max);\n      }\n      const limitedCoords = limiter.fn({\n        ...state,\n        [mainAxis]: mainAxisCoord,\n        [crossAxis]: crossAxisCoord\n      });\n      return {\n        ...limitedCoords,\n        data: {\n          x: limitedCoords.x - x,\n          y: limitedCoords.y - y,\n          enabled: {\n            [mainAxis]: checkMainAxis,\n            [crossAxis]: checkCrossAxis\n          }\n        }\n      };\n    }\n  };\n};\n/**\n * Built-in `limiter` that will stop `shift()` at a certain point.\n */\nconst limitShift = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    options,\n    fn(state) {\n      const {\n        x,\n        y,\n        placement,\n        rects,\n        middlewareData\n      } = state;\n      const {\n        offset = 0,\n        mainAxis: checkMainAxis = true,\n        crossAxis: checkCrossAxis = true\n      } = evaluate(options, state);\n      const coords = {\n        x,\n        y\n      };\n      const crossAxis = getSideAxis(placement);\n      const mainAxis = getOppositeAxis(crossAxis);\n      let mainAxisCoord = coords[mainAxis];\n      let crossAxisCoord = coords[crossAxis];\n      const rawOffset = evaluate(offset, state);\n      const computedOffset = typeof rawOffset === 'number' ? {\n        mainAxis: rawOffset,\n        crossAxis: 0\n      } : {\n        mainAxis: 0,\n        crossAxis: 0,\n        ...rawOffset\n      };\n      if (checkMainAxis) {\n        const len = mainAxis === 'y' ? 'height' : 'width';\n        const limitMin = rects.reference[mainAxis] - rects.floating[len] + computedOffset.mainAxis;\n        const limitMax = rects.reference[mainAxis] + rects.reference[len] - computedOffset.mainAxis;\n        if (mainAxisCoord < limitMin) {\n          mainAxisCoord = limitMin;\n        } else if (mainAxisCoord > limitMax) {\n          mainAxisCoord = limitMax;\n        }\n      }\n      if (checkCrossAxis) {\n        var _middlewareData$offse, _middlewareData$offse2;\n        const len = mainAxis === 'y' ? 'width' : 'height';\n        const isOriginSide = ['top', 'left'].includes(getSide(placement));\n        const limitMin = rects.reference[crossAxis] - rects.floating[len] + (isOriginSide ? ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse[crossAxis]) || 0 : 0) + (isOriginSide ? 0 : computedOffset.crossAxis);\n        const limitMax = rects.reference[crossAxis] + rects.reference[len] + (isOriginSide ? 0 : ((_middlewareData$offse2 = middlewareData.offset) == null ? void 0 : _middlewareData$offse2[crossAxis]) || 0) - (isOriginSide ? computedOffset.crossAxis : 0);\n        if (crossAxisCoord < limitMin) {\n          crossAxisCoord = limitMin;\n        } else if (crossAxisCoord > limitMax) {\n          crossAxisCoord = limitMax;\n        }\n      }\n      return {\n        [mainAxis]: mainAxisCoord,\n        [crossAxis]: crossAxisCoord\n      };\n    }\n  };\n};\n\n/**\n * Provides data that allows you to change the size of the floating element \n * for instance, prevent it from overflowing the clipping boundary or match the\n * width of the reference element.\n * @see https://floating-ui.com/docs/size\n */\nconst size = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'size',\n    options,\n    async fn(state) {\n      var _state$middlewareData, _state$middlewareData2;\n      const {\n        placement,\n        rects,\n        platform,\n        elements\n      } = state;\n      const {\n        apply = () => {},\n        ...detectOverflowOptions\n      } = evaluate(options, state);\n      const overflow = await detectOverflow(state, detectOverflowOptions);\n      const side = getSide(placement);\n      const alignment = getAlignment(placement);\n      const isYAxis = getSideAxis(placement) === 'y';\n      const {\n        width,\n        height\n      } = rects.floating;\n      let heightSide;\n      let widthSide;\n      if (side === 'top' || side === 'bottom') {\n        heightSide = side;\n        widthSide = alignment === ((await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating))) ? 'start' : 'end') ? 'left' : 'right';\n      } else {\n        widthSide = side;\n        heightSide = alignment === 'end' ? 'top' : 'bottom';\n      }\n      const maximumClippingHeight = height - overflow.top - overflow.bottom;\n      const maximumClippingWidth = width - overflow.left - overflow.right;\n      const overflowAvailableHeight = min(height - overflow[heightSide], maximumClippingHeight);\n      const overflowAvailableWidth = min(width - overflow[widthSide], maximumClippingWidth);\n      const noShift = !state.middlewareData.shift;\n      let availableHeight = overflowAvailableHeight;\n      let availableWidth = overflowAvailableWidth;\n      if ((_state$middlewareData = state.middlewareData.shift) != null && _state$middlewareData.enabled.x) {\n        availableWidth = maximumClippingWidth;\n      }\n      if ((_state$middlewareData2 = state.middlewareData.shift) != null && _state$middlewareData2.enabled.y) {\n        availableHeight = maximumClippingHeight;\n      }\n      if (noShift && !alignment) {\n        const xMin = max(overflow.left, 0);\n        const xMax = max(overflow.right, 0);\n        const yMin = max(overflow.top, 0);\n        const yMax = max(overflow.bottom, 0);\n        if (isYAxis) {\n          availableWidth = width - 2 * (xMin !== 0 || xMax !== 0 ? xMin + xMax : max(overflow.left, overflow.right));\n        } else {\n          availableHeight = height - 2 * (yMin !== 0 || yMax !== 0 ? yMin + yMax : max(overflow.top, overflow.bottom));\n        }\n      }\n      await apply({\n        ...state,\n        availableWidth,\n        availableHeight\n      });\n      const nextDimensions = await platform.getDimensions(elements.floating);\n      if (width !== nextDimensions.width || height !== nextDimensions.height) {\n        return {\n          reset: {\n            rects: true\n          }\n        };\n      }\n      return {};\n    }\n  };\n};\n\nexport { arrow, autoPlacement, computePosition, detectOverflow, flip, hide, inline, limitShift, offset, shift, size };\n","function hasWindow() {\n  return typeof window !== 'undefined';\n}\nfunction getNodeName(node) {\n  if (isNode(node)) {\n    return (node.nodeName || '').toLowerCase();\n  }\n  // Mocked nodes in testing environments may not be instances of Node. By\n  // returning `#document` an infinite loop won't occur.\n  // https://github.com/floating-ui/floating-ui/issues/2317\n  return '#document';\n}\nfunction getWindow(node) {\n  var _node$ownerDocument;\n  return (node == null || (_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;\n}\nfunction getDocumentElement(node) {\n  var _ref;\n  return (_ref = (isNode(node) ? node.ownerDocument : node.document) || window.document) == null ? void 0 : _ref.documentElement;\n}\nfunction isNode(value) {\n  if (!hasWindow()) {\n    return false;\n  }\n  return value instanceof Node || value instanceof getWindow(value).Node;\n}\nfunction isElement(value) {\n  if (!hasWindow()) {\n    return false;\n  }\n  return value instanceof Element || value instanceof getWindow(value).Element;\n}\nfunction isHTMLElement(value) {\n  if (!hasWindow()) {\n    return false;\n  }\n  return value instanceof HTMLElement || value instanceof getWindow(value).HTMLElement;\n}\nfunction isShadowRoot(value) {\n  if (!hasWindow() || typeof ShadowRoot === 'undefined') {\n    return false;\n  }\n  return value instanceof ShadowRoot || value instanceof getWindow(value).ShadowRoot;\n}\nfunction isOverflowElement(element) {\n  const {\n    overflow,\n    overflowX,\n    overflowY,\n    display\n  } = getComputedStyle(element);\n  return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && !['inline', 'contents'].includes(display);\n}\nfunction isTableElement(element) {\n  return ['table', 'td', 'th'].includes(getNodeName(element));\n}\nfunction isTopLayer(element) {\n  return [':popover-open', ':modal'].some(selector => {\n    try {\n      return element.matches(selector);\n    } catch (e) {\n      return false;\n    }\n  });\n}\nfunction isContainingBlock(elementOrCss) {\n  const webkit = isWebKit();\n  const css = isElement(elementOrCss) ? getComputedStyle(elementOrCss) : elementOrCss;\n\n  // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block\n  return css.transform !== 'none' || css.perspective !== 'none' || (css.containerType ? css.containerType !== 'normal' : false) || !webkit && (css.backdropFilter ? css.backdropFilter !== 'none' : false) || !webkit && (css.filter ? css.filter !== 'none' : false) || ['transform', 'perspective', 'filter'].some(value => (css.willChange || '').includes(value)) || ['paint', 'layout', 'strict', 'content'].some(value => (css.contain || '').includes(value));\n}\nfunction getContainingBlock(element) {\n  let currentNode = getParentNode(element);\n  while (isHTMLElement(currentNode) && !isLastTraversableNode(currentNode)) {\n    if (isContainingBlock(currentNode)) {\n      return currentNode;\n    } else if (isTopLayer(currentNode)) {\n      return null;\n    }\n    currentNode = getParentNode(currentNode);\n  }\n  return null;\n}\nfunction isWebKit() {\n  if (typeof CSS === 'undefined' || !CSS.supports) return false;\n  return CSS.supports('-webkit-backdrop-filter', 'none');\n}\nfunction isLastTraversableNode(node) {\n  return ['html', 'body', '#document'].includes(getNodeName(node));\n}\nfunction getComputedStyle(element) {\n  return getWindow(element).getComputedStyle(element);\n}\nfunction getNodeScroll(element) {\n  if (isElement(element)) {\n    return {\n      scrollLeft: element.scrollLeft,\n      scrollTop: element.scrollTop\n    };\n  }\n  return {\n    scrollLeft: element.scrollX,\n    scrollTop: element.scrollY\n  };\n}\nfunction getParentNode(node) {\n  if (getNodeName(node) === 'html') {\n    return node;\n  }\n  const result =\n  // Step into the shadow DOM of the parent of a slotted node.\n  node.assignedSlot ||\n  // DOM Element detected.\n  node.parentNode ||\n  // ShadowRoot detected.\n  isShadowRoot(node) && node.host ||\n  // Fallback.\n  getDocumentElement(node);\n  return isShadowRoot(result) ? result.host : result;\n}\nfunction getNearestOverflowAncestor(node) {\n  const parentNode = getParentNode(node);\n  if (isLastTraversableNode(parentNode)) {\n    return node.ownerDocument ? node.ownerDocument.body : node.body;\n  }\n  if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) {\n    return parentNode;\n  }\n  return getNearestOverflowAncestor(parentNode);\n}\nfunction getOverflowAncestors(node, list, traverseIframes) {\n  var _node$ownerDocument2;\n  if (list === void 0) {\n    list = [];\n  }\n  if (traverseIframes === void 0) {\n    traverseIframes = true;\n  }\n  const scrollableAncestor = getNearestOverflowAncestor(node);\n  const isBody = scrollableAncestor === ((_node$ownerDocument2 = node.ownerDocument) == null ? void 0 : _node$ownerDocument2.body);\n  const win = getWindow(scrollableAncestor);\n  if (isBody) {\n    const frameElement = getFrameElement(win);\n    return list.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : [], frameElement && traverseIframes ? getOverflowAncestors(frameElement) : []);\n  }\n  return list.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor, [], traverseIframes));\n}\nfunction getFrameElement(win) {\n  return win.parent && Object.getPrototypeOf(win.parent) ? win.frameElement : null;\n}\n\nexport { getComputedStyle, getContainingBlock, getDocumentElement, getFrameElement, getNearestOverflowAncestor, getNodeName, getNodeScroll, getOverflowAncestors, getParentNode, getWindow, isContainingBlock, isElement, isHTMLElement, isLastTraversableNode, isNode, isOverflowElement, isShadowRoot, isTableElement, isTopLayer, isWebKit };\n","import { rectToClientRect, detectOverflow as detectOverflow$1, offset as offset$1, autoPlacement as autoPlacement$1, shift as shift$1, flip as flip$1, size as size$1, hide as hide$1, arrow as arrow$1, inline as inline$1, limitShift as limitShift$1, computePosition as computePosition$1 } from '@floating-ui/core';\nimport { round, createCoords, max, min, floor } from '@floating-ui/utils';\nimport { getComputedStyle, isHTMLElement, isElement, getWindow, isWebKit, getFrameElement, getNodeScroll, getDocumentElement, isTopLayer, getNodeName, isOverflowElement, getOverflowAncestors, getParentNode, isLastTraversableNode, isContainingBlock, isTableElement, getContainingBlock } from '@floating-ui/utils/dom';\nexport { getOverflowAncestors } from '@floating-ui/utils/dom';\n\nfunction getCssDimensions(element) {\n  const css = getComputedStyle(element);\n  // In testing environments, the `width` and `height` properties are empty\n  // strings for SVG elements, returning NaN. Fallback to `0` in this case.\n  let width = parseFloat(css.width) || 0;\n  let height = parseFloat(css.height) || 0;\n  const hasOffset = isHTMLElement(element);\n  const offsetWidth = hasOffset ? element.offsetWidth : width;\n  const offsetHeight = hasOffset ? element.offsetHeight : height;\n  const shouldFallback = round(width) !== offsetWidth || round(height) !== offsetHeight;\n  if (shouldFallback) {\n    width = offsetWidth;\n    height = offsetHeight;\n  }\n  return {\n    width,\n    height,\n    $: shouldFallback\n  };\n}\n\nfunction unwrapElement(element) {\n  return !isElement(element) ? element.contextElement : element;\n}\n\nfunction getScale(element) {\n  const domElement = unwrapElement(element);\n  if (!isHTMLElement(domElement)) {\n    return createCoords(1);\n  }\n  const rect = domElement.getBoundingClientRect();\n  const {\n    width,\n    height,\n    $\n  } = getCssDimensions(domElement);\n  let x = ($ ? round(rect.width) : rect.width) / width;\n  let y = ($ ? round(rect.height) : rect.height) / height;\n\n  // 0, NaN, or Infinity should always fallback to 1.\n\n  if (!x || !Number.isFinite(x)) {\n    x = 1;\n  }\n  if (!y || !Number.isFinite(y)) {\n    y = 1;\n  }\n  return {\n    x,\n    y\n  };\n}\n\nconst noOffsets = /*#__PURE__*/createCoords(0);\nfunction getVisualOffsets(element) {\n  const win = getWindow(element);\n  if (!isWebKit() || !win.visualViewport) {\n    return noOffsets;\n  }\n  return {\n    x: win.visualViewport.offsetLeft,\n    y: win.visualViewport.offsetTop\n  };\n}\nfunction shouldAddVisualOffsets(element, isFixed, floatingOffsetParent) {\n  if (isFixed === void 0) {\n    isFixed = false;\n  }\n  if (!floatingOffsetParent || isFixed && floatingOffsetParent !== getWindow(element)) {\n    return false;\n  }\n  return isFixed;\n}\n\nfunction getBoundingClientRect(element, includeScale, isFixedStrategy, offsetParent) {\n  if (includeScale === void 0) {\n    includeScale = false;\n  }\n  if (isFixedStrategy === void 0) {\n    isFixedStrategy = false;\n  }\n  const clientRect = element.getBoundingClientRect();\n  const domElement = unwrapElement(element);\n  let scale = createCoords(1);\n  if (includeScale) {\n    if (offsetParent) {\n      if (isElement(offsetParent)) {\n        scale = getScale(offsetParent);\n      }\n    } else {\n      scale = getScale(element);\n    }\n  }\n  const visualOffsets = shouldAddVisualOffsets(domElement, isFixedStrategy, offsetParent) ? getVisualOffsets(domElement) : createCoords(0);\n  let x = (clientRect.left + visualOffsets.x) / scale.x;\n  let y = (clientRect.top + visualOffsets.y) / scale.y;\n  let width = clientRect.width / scale.x;\n  let height = clientRect.height / scale.y;\n  if (domElement) {\n    const win = getWindow(domElement);\n    const offsetWin = offsetParent && isElement(offsetParent) ? getWindow(offsetParent) : offsetParent;\n    let currentWin = win;\n    let currentIFrame = getFrameElement(currentWin);\n    while (currentIFrame && offsetParent && offsetWin !== currentWin) {\n      const iframeScale = getScale(currentIFrame);\n      const iframeRect = currentIFrame.getBoundingClientRect();\n      const css = getComputedStyle(currentIFrame);\n      const left = iframeRect.left + (currentIFrame.clientLeft + parseFloat(css.paddingLeft)) * iframeScale.x;\n      const top = iframeRect.top + (currentIFrame.clientTop + parseFloat(css.paddingTop)) * iframeScale.y;\n      x *= iframeScale.x;\n      y *= iframeScale.y;\n      width *= iframeScale.x;\n      height *= iframeScale.y;\n      x += left;\n      y += top;\n      currentWin = getWindow(currentIFrame);\n      currentIFrame = getFrameElement(currentWin);\n    }\n  }\n  return rectToClientRect({\n    width,\n    height,\n    x,\n    y\n  });\n}\n\n// If <html> has a CSS width greater than the viewport, then this will be\n// incorrect for RTL.\nfunction getWindowScrollBarX(element, rect) {\n  const leftScroll = getNodeScroll(element).scrollLeft;\n  if (!rect) {\n    return getBoundingClientRect(getDocumentElement(element)).left + leftScroll;\n  }\n  return rect.left + leftScroll;\n}\n\nfunction getHTMLOffset(documentElement, scroll, ignoreScrollbarX) {\n  if (ignoreScrollbarX === void 0) {\n    ignoreScrollbarX = false;\n  }\n  const htmlRect = documentElement.getBoundingClientRect();\n  const x = htmlRect.left + scroll.scrollLeft - (ignoreScrollbarX ? 0 :\n  // RTL <body> scrollbar.\n  getWindowScrollBarX(documentElement, htmlRect));\n  const y = htmlRect.top + scroll.scrollTop;\n  return {\n    x,\n    y\n  };\n}\n\nfunction convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {\n  let {\n    elements,\n    rect,\n    offsetParent,\n    strategy\n  } = _ref;\n  const isFixed = strategy === 'fixed';\n  const documentElement = getDocumentElement(offsetParent);\n  const topLayer = elements ? isTopLayer(elements.floating) : false;\n  if (offsetParent === documentElement || topLayer && isFixed) {\n    return rect;\n  }\n  let scroll = {\n    scrollLeft: 0,\n    scrollTop: 0\n  };\n  let scale = createCoords(1);\n  const offsets = createCoords(0);\n  const isOffsetParentAnElement = isHTMLElement(offsetParent);\n  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {\n    if (getNodeName(offsetParent) !== 'body' || isOverflowElement(documentElement)) {\n      scroll = getNodeScroll(offsetParent);\n    }\n    if (isHTMLElement(offsetParent)) {\n      const offsetRect = getBoundingClientRect(offsetParent);\n      scale = getScale(offsetParent);\n      offsets.x = offsetRect.x + offsetParent.clientLeft;\n      offsets.y = offsetRect.y + offsetParent.clientTop;\n    }\n  }\n  const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll, true) : createCoords(0);\n  return {\n    width: rect.width * scale.x,\n    height: rect.height * scale.y,\n    x: rect.x * scale.x - scroll.scrollLeft * scale.x + offsets.x + htmlOffset.x,\n    y: rect.y * scale.y - scroll.scrollTop * scale.y + offsets.y + htmlOffset.y\n  };\n}\n\nfunction getClientRects(element) {\n  return Array.from(element.getClientRects());\n}\n\n// Gets the entire size of the scrollable document area, even extending outside\n// of the `<html>` and `<body>` rect bounds if horizontally scrollable.\nfunction getDocumentRect(element) {\n  const html = getDocumentElement(element);\n  const scroll = getNodeScroll(element);\n  const body = element.ownerDocument.body;\n  const width = max(html.scrollWidth, html.clientWidth, body.scrollWidth, body.clientWidth);\n  const height = max(html.scrollHeight, html.clientHeight, body.scrollHeight, body.clientHeight);\n  let x = -scroll.scrollLeft + getWindowScrollBarX(element);\n  const y = -scroll.scrollTop;\n  if (getComputedStyle(body).direction === 'rtl') {\n    x += max(html.clientWidth, body.clientWidth) - width;\n  }\n  return {\n    width,\n    height,\n    x,\n    y\n  };\n}\n\nfunction getViewportRect(element, strategy) {\n  const win = getWindow(element);\n  const html = getDocumentElement(element);\n  const visualViewport = win.visualViewport;\n  let width = html.clientWidth;\n  let height = html.clientHeight;\n  let x = 0;\n  let y = 0;\n  if (visualViewport) {\n    width = visualViewport.width;\n    height = visualViewport.height;\n    const visualViewportBased = isWebKit();\n    if (!visualViewportBased || visualViewportBased && strategy === 'fixed') {\n      x = visualViewport.offsetLeft;\n      y = visualViewport.offsetTop;\n    }\n  }\n  return {\n    width,\n    height,\n    x,\n    y\n  };\n}\n\n// Returns the inner client rect, subtracting scrollbars if present.\nfunction getInnerBoundingClientRect(element, strategy) {\n  const clientRect = getBoundingClientRect(element, true, strategy === 'fixed');\n  const top = clientRect.top + element.clientTop;\n  const left = clientRect.left + element.clientLeft;\n  const scale = isHTMLElement(element) ? getScale(element) : createCoords(1);\n  const width = element.clientWidth * scale.x;\n  const height = element.clientHeight * scale.y;\n  const x = left * scale.x;\n  const y = top * scale.y;\n  return {\n    width,\n    height,\n    x,\n    y\n  };\n}\nfunction getClientRectFromClippingAncestor(element, clippingAncestor, strategy) {\n  let rect;\n  if (clippingAncestor === 'viewport') {\n    rect = getViewportRect(element, strategy);\n  } else if (clippingAncestor === 'document') {\n    rect = getDocumentRect(getDocumentElement(element));\n  } else if (isElement(clippingAncestor)) {\n    rect = getInnerBoundingClientRect(clippingAncestor, strategy);\n  } else {\n    const visualOffsets = getVisualOffsets(element);\n    rect = {\n      x: clippingAncestor.x - visualOffsets.x,\n      y: clippingAncestor.y - visualOffsets.y,\n      width: clippingAncestor.width,\n      height: clippingAncestor.height\n    };\n  }\n  return rectToClientRect(rect);\n}\nfunction hasFixedPositionAncestor(element, stopNode) {\n  const parentNode = getParentNode(element);\n  if (parentNode === stopNode || !isElement(parentNode) || isLastTraversableNode(parentNode)) {\n    return false;\n  }\n  return getComputedStyle(parentNode).position === 'fixed' || hasFixedPositionAncestor(parentNode, stopNode);\n}\n\n// A \"clipping ancestor\" is an `overflow` element with the characteristic of\n// clipping (or hiding) child elements. This returns all clipping ancestors\n// of the given element up the tree.\nfunction getClippingElementAncestors(element, cache) {\n  const cachedResult = cache.get(element);\n  if (cachedResult) {\n    return cachedResult;\n  }\n  let result = getOverflowAncestors(element, [], false).filter(el => isElement(el) && getNodeName(el) !== 'body');\n  let currentContainingBlockComputedStyle = null;\n  const elementIsFixed = getComputedStyle(element).position === 'fixed';\n  let currentNode = elementIsFixed ? getParentNode(element) : element;\n\n  // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block\n  while (isElement(currentNode) && !isLastTraversableNode(currentNode)) {\n    const computedStyle = getComputedStyle(currentNode);\n    const currentNodeIsContaining = isContainingBlock(currentNode);\n    if (!currentNodeIsContaining && computedStyle.position === 'fixed') {\n      currentContainingBlockComputedStyle = null;\n    }\n    const shouldDropCurrentNode = elementIsFixed ? !currentNodeIsContaining && !currentContainingBlockComputedStyle : !currentNodeIsContaining && computedStyle.position === 'static' && !!currentContainingBlockComputedStyle && ['absolute', 'fixed'].includes(currentContainingBlockComputedStyle.position) || isOverflowElement(currentNode) && !currentNodeIsContaining && hasFixedPositionAncestor(element, currentNode);\n    if (shouldDropCurrentNode) {\n      // Drop non-containing blocks.\n      result = result.filter(ancestor => ancestor !== currentNode);\n    } else {\n      // Record last containing block for next iteration.\n      currentContainingBlockComputedStyle = computedStyle;\n    }\n    currentNode = getParentNode(currentNode);\n  }\n  cache.set(element, result);\n  return result;\n}\n\n// Gets the maximum area that the element is visible in due to any number of\n// clipping ancestors.\nfunction getClippingRect(_ref) {\n  let {\n    element,\n    boundary,\n    rootBoundary,\n    strategy\n  } = _ref;\n  const elementClippingAncestors = boundary === 'clippingAncestors' ? isTopLayer(element) ? [] : getClippingElementAncestors(element, this._c) : [].concat(boundary);\n  const clippingAncestors = [...elementClippingAncestors, rootBoundary];\n  const firstClippingAncestor = clippingAncestors[0];\n  const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {\n    const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);\n    accRect.top = max(rect.top, accRect.top);\n    accRect.right = min(rect.right, accRect.right);\n    accRect.bottom = min(rect.bottom, accRect.bottom);\n    accRect.left = max(rect.left, accRect.left);\n    return accRect;\n  }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));\n  return {\n    width: clippingRect.right - clippingRect.left,\n    height: clippingRect.bottom - clippingRect.top,\n    x: clippingRect.left,\n    y: clippingRect.top\n  };\n}\n\nfunction getDimensions(element) {\n  const {\n    width,\n    height\n  } = getCssDimensions(element);\n  return {\n    width,\n    height\n  };\n}\n\nfunction getRectRelativeToOffsetParent(element, offsetParent, strategy) {\n  const isOffsetParentAnElement = isHTMLElement(offsetParent);\n  const documentElement = getDocumentElement(offsetParent);\n  const isFixed = strategy === 'fixed';\n  const rect = getBoundingClientRect(element, true, isFixed, offsetParent);\n  let scroll = {\n    scrollLeft: 0,\n    scrollTop: 0\n  };\n  const offsets = createCoords(0);\n  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {\n    if (getNodeName(offsetParent) !== 'body' || isOverflowElement(documentElement)) {\n      scroll = getNodeScroll(offsetParent);\n    }\n    if (isOffsetParentAnElement) {\n      const offsetRect = getBoundingClientRect(offsetParent, true, isFixed, offsetParent);\n      offsets.x = offsetRect.x + offsetParent.clientLeft;\n      offsets.y = offsetRect.y + offsetParent.clientTop;\n    } else if (documentElement) {\n      // If the <body> scrollbar appears on the left (e.g. RTL systems). Use\n      // Firefox with layout.scrollbar.side = 3 in about:config to test this.\n      offsets.x = getWindowScrollBarX(documentElement);\n    }\n  }\n  const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll) : createCoords(0);\n  const x = rect.left + scroll.scrollLeft - offsets.x - htmlOffset.x;\n  const y = rect.top + scroll.scrollTop - offsets.y - htmlOffset.y;\n  return {\n    x,\n    y,\n    width: rect.width,\n    height: rect.height\n  };\n}\n\nfunction isStaticPositioned(element) {\n  return getComputedStyle(element).position === 'static';\n}\n\nfunction getTrueOffsetParent(element, polyfill) {\n  if (!isHTMLElement(element) || getComputedStyle(element).position === 'fixed') {\n    return null;\n  }\n  if (polyfill) {\n    return polyfill(element);\n  }\n  let rawOffsetParent = element.offsetParent;\n\n  // Firefox returns the <html> element as the offsetParent if it's non-static,\n  // while Chrome and Safari return the <body> element. The <body> element must\n  // be used to perform the correct calculations even if the <html> element is\n  // non-static.\n  if (getDocumentElement(element) === rawOffsetParent) {\n    rawOffsetParent = rawOffsetParent.ownerDocument.body;\n  }\n  return rawOffsetParent;\n}\n\n// Gets the closest ancestor positioned element. Handles some edge cases,\n// such as table ancestors and cross browser bugs.\nfunction getOffsetParent(element, polyfill) {\n  const win = getWindow(element);\n  if (isTopLayer(element)) {\n    return win;\n  }\n  if (!isHTMLElement(element)) {\n    let svgOffsetParent = getParentNode(element);\n    while (svgOffsetParent && !isLastTraversableNode(svgOffsetParent)) {\n      if (isElement(svgOffsetParent) && !isStaticPositioned(svgOffsetParent)) {\n        return svgOffsetParent;\n      }\n      svgOffsetParent = getParentNode(svgOffsetParent);\n    }\n    return win;\n  }\n  let offsetParent = getTrueOffsetParent(element, polyfill);\n  while (offsetParent && isTableElement(offsetParent) && isStaticPositioned(offsetParent)) {\n    offsetParent = getTrueOffsetParent(offsetParent, polyfill);\n  }\n  if (offsetParent && isLastTraversableNode(offsetParent) && isStaticPositioned(offsetParent) && !isContainingBlock(offsetParent)) {\n    return win;\n  }\n  return offsetParent || getContainingBlock(element) || win;\n}\n\nconst getElementRects = async function (data) {\n  const getOffsetParentFn = this.getOffsetParent || getOffsetParent;\n  const getDimensionsFn = this.getDimensions;\n  const floatingDimensions = await getDimensionsFn(data.floating);\n  return {\n    reference: getRectRelativeToOffsetParent(data.reference, await getOffsetParentFn(data.floating), data.strategy),\n    floating: {\n      x: 0,\n      y: 0,\n      width: floatingDimensions.width,\n      height: floatingDimensions.height\n    }\n  };\n};\n\nfunction isRTL(element) {\n  return getComputedStyle(element).direction === 'rtl';\n}\n\nconst platform = {\n  convertOffsetParentRelativeRectToViewportRelativeRect,\n  getDocumentElement,\n  getClippingRect,\n  getOffsetParent,\n  getElementRects,\n  getClientRects,\n  getDimensions,\n  getScale,\n  isElement,\n  isRTL\n};\n\n// https://samthor.au/2021/observing-dom/\nfunction observeMove(element, onMove) {\n  let io = null;\n  let timeoutId;\n  const root = getDocumentElement(element);\n  function cleanup() {\n    var _io;\n    clearTimeout(timeoutId);\n    (_io = io) == null || _io.disconnect();\n    io = null;\n  }\n  function refresh(skip, threshold) {\n    if (skip === void 0) {\n      skip = false;\n    }\n    if (threshold === void 0) {\n      threshold = 1;\n    }\n    cleanup();\n    const {\n      left,\n      top,\n      width,\n      height\n    } = element.getBoundingClientRect();\n    if (!skip) {\n      onMove();\n    }\n    if (!width || !height) {\n      return;\n    }\n    const insetTop = floor(top);\n    const insetRight = floor(root.clientWidth - (left + width));\n    const insetBottom = floor(root.clientHeight - (top + height));\n    const insetLeft = floor(left);\n    const rootMargin = -insetTop + \"px \" + -insetRight + \"px \" + -insetBottom + \"px \" + -insetLeft + \"px\";\n    const options = {\n      rootMargin,\n      threshold: max(0, min(1, threshold)) || 1\n    };\n    let isFirstUpdate = true;\n    function handleObserve(entries) {\n      const ratio = entries[0].intersectionRatio;\n      if (ratio !== threshold) {\n        if (!isFirstUpdate) {\n          return refresh();\n        }\n        if (!ratio) {\n          // If the reference is clipped, the ratio is 0. Throttle the refresh\n          // to prevent an infinite loop of updates.\n          timeoutId = setTimeout(() => {\n            refresh(false, 1e-7);\n          }, 1000);\n        } else {\n          refresh(false, ratio);\n        }\n      }\n      isFirstUpdate = false;\n    }\n\n    // Older browsers don't support a `document` as the root and will throw an\n    // error.\n    try {\n      io = new IntersectionObserver(handleObserve, {\n        ...options,\n        // Handle <iframe>s\n        root: root.ownerDocument\n      });\n    } catch (e) {\n      io = new IntersectionObserver(handleObserve, options);\n    }\n    io.observe(element);\n  }\n  refresh(true);\n  return cleanup;\n}\n\n/**\n * Automatically updates the position of the floating element when necessary.\n * Should only be called when the floating element is mounted on the DOM or\n * visible on the screen.\n * @returns cleanup function that should be invoked when the floating element is\n * removed from the DOM or hidden from the screen.\n * @see https://floating-ui.com/docs/autoUpdate\n */\nfunction autoUpdate(reference, floating, update, options) {\n  if (options === void 0) {\n    options = {};\n  }\n  const {\n    ancestorScroll = true,\n    ancestorResize = true,\n    elementResize = typeof ResizeObserver === 'function',\n    layoutShift = typeof IntersectionObserver === 'function',\n    animationFrame = false\n  } = options;\n  const referenceEl = unwrapElement(reference);\n  const ancestors = ancestorScroll || ancestorResize ? [...(referenceEl ? getOverflowAncestors(referenceEl) : []), ...getOverflowAncestors(floating)] : [];\n  ancestors.forEach(ancestor => {\n    ancestorScroll && ancestor.addEventListener('scroll', update, {\n      passive: true\n    });\n    ancestorResize && ancestor.addEventListener('resize', update);\n  });\n  const cleanupIo = referenceEl && layoutShift ? observeMove(referenceEl, update) : null;\n  let reobserveFrame = -1;\n  let resizeObserver = null;\n  if (elementResize) {\n    resizeObserver = new ResizeObserver(_ref => {\n      let [firstEntry] = _ref;\n      if (firstEntry && firstEntry.target === referenceEl && resizeObserver) {\n        // Prevent update loops when using the `size` middleware.\n        // https://github.com/floating-ui/floating-ui/issues/1740\n        resizeObserver.unobserve(floating);\n        cancelAnimationFrame(reobserveFrame);\n        reobserveFrame = requestAnimationFrame(() => {\n          var _resizeObserver;\n          (_resizeObserver = resizeObserver) == null || _resizeObserver.observe(floating);\n        });\n      }\n      update();\n    });\n    if (referenceEl && !animationFrame) {\n      resizeObserver.observe(referenceEl);\n    }\n    resizeObserver.observe(floating);\n  }\n  let frameId;\n  let prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;\n  if (animationFrame) {\n    frameLoop();\n  }\n  function frameLoop() {\n    const nextRefRect = getBoundingClientRect(reference);\n    if (prevRefRect && (nextRefRect.x !== prevRefRect.x || nextRefRect.y !== prevRefRect.y || nextRefRect.width !== prevRefRect.width || nextRefRect.height !== prevRefRect.height)) {\n      update();\n    }\n    prevRefRect = nextRefRect;\n    frameId = requestAnimationFrame(frameLoop);\n  }\n  update();\n  return () => {\n    var _resizeObserver2;\n    ancestors.forEach(ancestor => {\n      ancestorScroll && ancestor.removeEventListener('scroll', update);\n      ancestorResize && ancestor.removeEventListener('resize', update);\n    });\n    cleanupIo == null || cleanupIo();\n    (_resizeObserver2 = resizeObserver) == null || _resizeObserver2.disconnect();\n    resizeObserver = null;\n    if (animationFrame) {\n      cancelAnimationFrame(frameId);\n    }\n  };\n}\n\n/**\n * Resolves with an object of overflow side offsets that determine how much the\n * element is overflowing a given clipping boundary on each side.\n * - positive = overflowing the boundary by that number of pixels\n * - negative = how many pixels left before it will overflow\n * - 0 = lies flush with the boundary\n * @see https://floating-ui.com/docs/detectOverflow\n */\nconst detectOverflow = detectOverflow$1;\n\n/**\n * Modifies the placement by translating the floating element along the\n * specified axes.\n * A number (shorthand for `mainAxis` or distance), or an axes configuration\n * object may be passed.\n * @see https://floating-ui.com/docs/offset\n */\nconst offset = offset$1;\n\n/**\n * Optimizes the visibility of the floating element by choosing the placement\n * that has the most space available automatically, without needing to specify a\n * preferred placement. Alternative to `flip`.\n * @see https://floating-ui.com/docs/autoPlacement\n */\nconst autoPlacement = autoPlacement$1;\n\n/**\n * Optimizes the visibility of the floating element by shifting it in order to\n * keep it in view when it will overflow the clipping boundary.\n * @see https://floating-ui.com/docs/shift\n */\nconst shift = shift$1;\n\n/**\n * Optimizes the visibility of the floating element by flipping the `placement`\n * in order to keep it in view when the preferred placement(s) will overflow the\n * clipping boundary. Alternative to `autoPlacement`.\n * @see https://floating-ui.com/docs/flip\n */\nconst flip = flip$1;\n\n/**\n * Provides data that allows you to change the size of the floating element \n * for instance, prevent it from overflowing the clipping boundary or match the\n * width of the reference element.\n * @see https://floating-ui.com/docs/size\n */\nconst size = size$1;\n\n/**\n * Provides data to hide the floating element in applicable situations, such as\n * when it is not in the same clipping context as the reference element.\n * @see https://floating-ui.com/docs/hide\n */\nconst hide = hide$1;\n\n/**\n * Provides data to position an inner element of the floating element so that it\n * appears centered to the reference element.\n * @see https://floating-ui.com/docs/arrow\n */\nconst arrow = arrow$1;\n\n/**\n * Provides improved positioning for inline reference elements that can span\n * over multiple lines, such as hyperlinks or range selections.\n * @see https://floating-ui.com/docs/inline\n */\nconst inline = inline$1;\n\n/**\n * Built-in `limiter` that will stop `shift()` at a certain point.\n */\nconst limitShift = limitShift$1;\n\n/**\n * Computes the `x` and `y` coordinates that will place the floating element\n * next to a given reference element.\n */\nconst computePosition = (reference, floating, options) => {\n  // This caches the expensive `getClippingElementAncestors` function so that\n  // multiple lifecycle resets re-use the same result. It only lives for a\n  // single call. If other functions become expensive, we can add them as well.\n  const cache = new Map();\n  const mergedOptions = {\n    platform,\n    ...options\n  };\n  const platformWithCache = {\n    ...mergedOptions.platform,\n    _c: cache\n  };\n  return computePosition$1(reference, floating, {\n    ...mergedOptions,\n    platform: platformWithCache\n  });\n};\n\nexport { arrow, autoPlacement, autoUpdate, computePosition, detectOverflow, flip, hide, inline, limitShift, offset, platform, shift, size };\n","export function get(valueOrGetValue) {\n    return typeof valueOrGetValue === \"function\"\n        ? valueOrGetValue()\n        : valueOrGetValue;\n}\nexport function getDPR(element) {\n    if (typeof window === \"undefined\")\n        return 1;\n    const win = element.ownerDocument.defaultView || window;\n    return win.devicePixelRatio || 1;\n}\nexport function roundByDPR(element, value) {\n    const dpr = getDPR(element);\n    return Math.round(value * dpr) / dpr;\n}\nexport function getFloatingContentCSSVars(name) {\n    return {\n        [`--bits-${name}-content-transform-origin`]: `var(--bits-floating-transform-origin)`,\n        [`--bits-${name}-content-available-width`]: `var(--bits-floating-available-width)`,\n        [`--bits-${name}-content-available-height`]: `var(--bits-floating-available-height)`,\n        [`--bits-${name}-anchor-width`]: `var(--bits-floating-anchor-width)`,\n        [`--bits-${name}-anchor-height`]: `var(--bits-floating-anchor-height)`,\n    };\n}\n","import { computePosition } from \"@floating-ui/dom\";\nimport { box } from \"svelte-toolbelt\";\nimport { get, getDPR, roundByDPR } from \"./floating-utils.svelte.js\";\nexport function useFloating(options) {\n    /** Options */\n    const whileElementsMountedOption = options.whileElementsMounted;\n    const openOption = $derived(get(options.open) ?? true);\n    const middlewareOption = $derived(get(options.middleware));\n    const transformOption = $derived(get(options.transform) ?? true);\n    const placementOption = $derived(get(options.placement) ?? \"bottom\");\n    const strategyOption = $derived(get(options.strategy) ?? \"absolute\");\n    const reference = options.reference;\n    /** State */\n    let x = $state(0);\n    let y = $state(0);\n    const floating = box(null);\n    let strategy = $state(strategyOption);\n    let placement = $state(placementOption);\n    let middlewareData = $state({});\n    let isPositioned = $state(false);\n    const floatingStyles = $derived.by(() => {\n        const initialStyles = {\n            position: strategy,\n            left: \"0\",\n            top: \"0\",\n        };\n        if (!floating.current) {\n            return initialStyles;\n        }\n        const xVal = roundByDPR(floating.current, x);\n        const yVal = roundByDPR(floating.current, y);\n        if (transformOption) {\n            return {\n                ...initialStyles,\n                transform: `translate(${xVal}px, ${yVal}px)`,\n                ...(getDPR(floating.current) >= 1.5 && {\n                    willChange: \"transform\",\n                }),\n            };\n        }\n        return {\n            position: strategy,\n            left: `${xVal}px`,\n            top: `${yVal}px`,\n        };\n    });\n    /** Effects */\n    let whileElementsMountedCleanup;\n    function update() {\n        if (reference.current === null || floating.current === null)\n            return;\n        computePosition(reference.current, floating.current, {\n            middleware: middlewareOption,\n            placement: placementOption,\n            strategy: strategyOption,\n        }).then((position) => {\n            x = position.x;\n            y = position.y;\n            strategy = position.strategy;\n            placement = position.placement;\n            middlewareData = position.middlewareData;\n            isPositioned = true;\n        });\n    }\n    function cleanup() {\n        if (typeof whileElementsMountedCleanup === \"function\") {\n            whileElementsMountedCleanup();\n            whileElementsMountedCleanup = undefined;\n        }\n    }\n    function attach() {\n        cleanup();\n        if (whileElementsMountedOption === undefined) {\n            update();\n            return;\n        }\n        if (reference.current === null || floating.current === null)\n            return;\n        whileElementsMountedCleanup = whileElementsMountedOption(reference.current, floating.current, update);\n    }\n    function reset() {\n        if (!openOption) {\n            isPositioned = false;\n        }\n    }\n    $effect(update);\n    $effect(attach);\n    $effect(reset);\n    $effect(() => cleanup);\n    return {\n        floating,\n        reference,\n        get strategy() {\n            return strategy;\n        },\n        get placement() {\n            return placement;\n        },\n        get middlewareData() {\n            return middlewareData;\n        },\n        get isPositioned() {\n            return isPositioned;\n        },\n        get floatingStyles() {\n            return floatingStyles;\n        },\n        get update() {\n            return update;\n        },\n    };\n}\n","import { untrack } from \"svelte\";\nimport { arrow, autoUpdate, flip, hide, limitShift, offset, shift, size, } from \"@floating-ui/dom\";\nimport { box, cssToStyleObj, styleToString, useRefById } from \"svelte-toolbelt\";\nimport { ElementSize } from \"runed\";\nimport { isNotNull } from \"../../../internal/is.js\";\nimport { useId } from \"../../../internal/use-id.js\";\nimport { useFloating } from \"../../../internal/floating-svelte/use-floating.svelte.js\";\nimport { createContext } from \"../../../internal/create-context.js\";\nexport const SIDE_OPTIONS = [\"top\", \"right\", \"bottom\", \"left\"];\nexport const ALIGN_OPTIONS = [\"start\", \"center\", \"end\"];\nconst OPPOSITE_SIDE = {\n    top: \"bottom\",\n    right: \"left\",\n    bottom: \"top\",\n    left: \"right\",\n};\nclass FloatingRootState {\n    anchorNode = box(null);\n    customAnchorNode = box(null);\n    triggerNode = box(null);\n    constructor() {\n        $effect(() => {\n            if (this.customAnchorNode.current) {\n                if (typeof this.customAnchorNode.current === \"string\") {\n                    this.anchorNode.current = document.querySelector(this.customAnchorNode.current);\n                }\n                else {\n                    this.anchorNode.current = this.customAnchorNode.current;\n                }\n            }\n            else {\n                this.anchorNode.current = this.triggerNode.current;\n            }\n        });\n    }\n}\nclass FloatingContentState {\n    // state\n    root;\n    // nodes\n    contentRef = box(null);\n    wrapperRef = box(null);\n    arrowRef = box(null);\n    // ids\n    arrowId = box(useId());\n    id;\n    wrapperId;\n    style;\n    #transformedStyle = $derived.by(() => {\n        if (typeof this.style === \"string\")\n            return cssToStyleObj(this.style);\n        if (!this.style)\n            return {};\n    });\n    #dir;\n    #side;\n    #sideOffset;\n    #align;\n    #alignOffset;\n    #arrowPadding;\n    #avoidCollisions;\n    #collisionBoundary;\n    #collisionPadding;\n    #sticky;\n    #hideWhenDetached;\n    #strategy;\n    #updatePositionStrategy = undefined;\n    onPlaced;\n    enabled;\n    #arrowSize = new ElementSize(() => this.arrowRef.current ?? undefined);\n    #arrowWidth = $derived(this.#arrowSize?.width ?? 0);\n    #arrowHeight = $derived(this.#arrowSize?.height ?? 0);\n    #desiredPlacement = $derived.by(() => (this.#side?.current +\n        (this.#align.current !== \"center\" ? `-${this.#align.current}` : \"\")));\n    #boundary = $derived.by(() => Array.isArray(this.#collisionBoundary.current)\n        ? this.#collisionBoundary.current\n        : [this.#collisionBoundary.current]);\n    hasExplicitBoundaries = $derived(this.#boundary.length > 0);\n    detectOverflowOptions = $derived.by(() => ({\n        padding: this.#collisionPadding.current,\n        boundary: this.#boundary.filter(isNotNull),\n        altBoundary: this.hasExplicitBoundaries,\n    }));\n    #availableWidth = $state(undefined);\n    #availableHeight = $state(undefined);\n    #anchorWidth = $state(undefined);\n    #anchorHeight = $state(undefined);\n    middleware = $derived.by(() => [\n        offset({\n            mainAxis: this.#sideOffset.current + this.#arrowHeight,\n            alignmentAxis: this.#alignOffset.current,\n        }),\n        this.#avoidCollisions &&\n            shift({\n                mainAxis: true,\n                crossAxis: false,\n                limiter: this.#sticky.current === \"partial\" ? limitShift() : undefined,\n                ...this.detectOverflowOptions,\n            }),\n        this.#avoidCollisions && flip({ ...this.detectOverflowOptions }),\n        size({\n            ...this.detectOverflowOptions,\n            apply: ({ rects, availableWidth, availableHeight }) => {\n                const { width: anchorWidth, height: anchorHeight } = rects.reference;\n                this.#availableWidth = availableWidth;\n                this.#availableHeight = availableHeight;\n                this.#anchorWidth = anchorWidth;\n                this.#anchorHeight = anchorHeight;\n            },\n        }),\n        this.arrowRef.current &&\n            arrow({ element: this.arrowRef.current, padding: this.#arrowPadding.current }),\n        transformOrigin({ arrowWidth: this.#arrowWidth, arrowHeight: this.#arrowHeight }),\n        this.#hideWhenDetached.current &&\n            hide({ strategy: \"referenceHidden\", ...this.detectOverflowOptions }),\n    ].filter(Boolean));\n    floating;\n    placedSide = $derived.by(() => getSideFromPlacement(this.floating.placement));\n    placedAlign = $derived.by(() => getAlignFromPlacement(this.floating.placement));\n    arrowX = $derived.by(() => this.floating.middlewareData.arrow?.x ?? 0);\n    arrowY = $derived.by(() => this.floating.middlewareData.arrow?.y ?? 0);\n    cannotCenterArrow = $derived.by(() => this.floating.middlewareData.arrow?.centerOffset !== 0);\n    contentZIndex = $state();\n    arrowBaseSide = $derived(OPPOSITE_SIDE[this.placedSide]);\n    wrapperProps = $derived.by(() => ({\n        id: this.wrapperId.current,\n        \"data-bits-floating-content-wrapper\": \"\",\n        style: {\n            ...this.floating.floatingStyles,\n            // keep off page when measuring\n            transform: this.floating.isPositioned\n                ? this.floating.floatingStyles.transform\n                : \"translate(0, -200%)\",\n            minWidth: \"max-content\",\n            zIndex: this.contentZIndex,\n            \"--bits-floating-transform-origin\": `${this.floating.middlewareData.transformOrigin?.x} ${this.floating.middlewareData.transformOrigin?.y}`,\n            \"--bits-floating-available-width\": `${this.#availableWidth}px`,\n            \"--bits-floating-available-height\": `${this.#availableHeight}px`,\n            \"--bits-floating-anchor-width\": `${this.#anchorWidth}px`,\n            \"--bits-floating-anchor-height\": `${this.#anchorHeight}px`,\n            // hide the content if using the hide middleware and should be hidden\n            ...(this.floating.middlewareData.hide?.referenceHidden && {\n                visibility: \"hidden\",\n                \"pointer-events\": \"none\",\n            }),\n            ...this.#transformedStyle,\n        },\n        // Floating UI calculates logical alignment based the `dir` attribute\n        dir: this.#dir.current,\n    }));\n    props = $derived.by(() => ({\n        \"data-side\": this.placedSide,\n        \"data-align\": this.placedAlign,\n        style: styleToString({\n            ...this.#transformedStyle,\n            // if the FloatingContent hasn't been placed yet (not all measurements done)\n            // we prevent animations so that users's animation don't kick in too early referring wrong sides\n            // animation: !this.floating.isPositioned ? \"none\" : undefined,\n        }),\n    }));\n    arrowStyle = $derived({\n        position: \"absolute\",\n        left: this.arrowX ? `${this.arrowX}px` : undefined,\n        top: this.arrowY ? `${this.arrowY}px` : undefined,\n        [this.arrowBaseSide]: 0,\n        \"transform-origin\": {\n            top: \"\",\n            right: \"0 0\",\n            bottom: \"center 0\",\n            left: \"100% 0\",\n        }[this.placedSide],\n        transform: {\n            top: \"translateY(100%)\",\n            right: \"translateY(50%) rotate(90deg) translateX(-50%)\",\n            bottom: \"rotate(180deg)\",\n            left: \"translateY(50%) rotate(-90deg) translateX(50%)\",\n        }[this.placedSide],\n        visibility: this.cannotCenterArrow ? \"hidden\" : undefined,\n    });\n    constructor(props, root) {\n        this.id = props.id;\n        this.#side = props.side;\n        this.#sideOffset = props.sideOffset;\n        this.#align = props.align;\n        this.#alignOffset = props.alignOffset;\n        this.#arrowPadding = props.arrowPadding;\n        this.#avoidCollisions = props.avoidCollisions;\n        this.#collisionBoundary = props.collisionBoundary;\n        this.#collisionPadding = props.collisionPadding;\n        this.#sticky = props.sticky;\n        this.#hideWhenDetached = props.hideWhenDetached;\n        this.#updatePositionStrategy = props.updatePositionStrategy;\n        this.onPlaced = props.onPlaced;\n        this.#strategy = props.strategy;\n        this.#dir = props.dir;\n        this.style = props.style;\n        this.root = root;\n        this.enabled = props.enabled;\n        this.wrapperId = props.wrapperId;\n        if (props.customAnchor) {\n            this.root.customAnchorNode.current = props.customAnchor.current;\n        }\n        $effect(() => {\n            props.customAnchor.current;\n            untrack(() => {\n                this.root.customAnchorNode.current = props.customAnchor.current;\n            });\n        });\n        useRefById({\n            id: this.wrapperId,\n            ref: this.wrapperRef,\n            deps: () => this.enabled.current,\n        });\n        useRefById({\n            id: this.id,\n            ref: this.contentRef,\n            deps: () => this.enabled.current,\n        });\n        this.floating = useFloating({\n            strategy: () => this.#strategy.current,\n            placement: () => this.#desiredPlacement,\n            middleware: () => this.middleware,\n            reference: this.root.anchorNode,\n            whileElementsMounted: (...args) => {\n                const cleanup = autoUpdate(...args, {\n                    animationFrame: this.#updatePositionStrategy?.current === \"always\",\n                });\n                return cleanup;\n            },\n            open: () => this.enabled.current,\n        });\n        $effect(() => {\n            if (!this.floating.isPositioned)\n                return;\n            this.onPlaced?.current();\n        });\n        $effect(() => {\n            const contentNode = this.contentRef.current;\n            if (!contentNode)\n                return;\n            untrack(() => {\n                this.contentZIndex = window.getComputedStyle(contentNode).zIndex;\n            });\n        });\n        $effect(() => {\n            this.floating.floating.current = this.wrapperRef.current;\n        });\n    }\n}\nclass FloatingArrowState {\n    #id;\n    #ref;\n    #content;\n    constructor(props, content) {\n        this.#content = content;\n        this.#id = props.id;\n        this.#ref = props.ref;\n        useRefById({\n            id: this.#id,\n            ref: this.#ref,\n            onRefChange: (node) => {\n                this.#content.arrowRef.current = node;\n            },\n            deps: () => this.#content.enabled.current,\n        });\n    }\n    props = $derived.by(() => ({\n        id: this.#id.current,\n        style: this.#content.arrowStyle,\n        \"data-side\": this.#content.placedSide,\n    }));\n}\nclass FloatingAnchorState {\n    ref = box(null);\n    constructor(props, root) {\n        if (props.virtualEl && props.virtualEl.current) {\n            root.triggerNode = box.from(props.virtualEl.current);\n        }\n        else {\n            useRefById({\n                id: props.id,\n                ref: this.ref,\n                onRefChange: (node) => {\n                    root.triggerNode.current = node;\n                },\n            });\n        }\n    }\n}\n//\n// CONTEXT METHODS\n//\nconst [setFloatingRootContext, getFloatingRootContext] = createContext(\"Floating.Root\");\nconst [setFloatingContentContext, getFloatingContentContext] = createContext(\"Floating.Content\");\nexport function useFloatingRootState() {\n    return setFloatingRootContext(new FloatingRootState());\n}\nexport function useFloatingContentState(props) {\n    return setFloatingContentContext(new FloatingContentState(props, getFloatingRootContext()));\n}\nexport function useFloatingArrowState(props) {\n    return new FloatingArrowState(props, getFloatingContentContext());\n}\nexport function useFloatingAnchorState(props) {\n    return new FloatingAnchorState(props, getFloatingRootContext());\n}\n//\n// HELPERS\n//\nfunction transformOrigin(options) {\n    return {\n        name: \"transformOrigin\",\n        options,\n        fn(data) {\n            const { placement, rects, middlewareData } = data;\n            const cannotCenterArrow = middlewareData.arrow?.centerOffset !== 0;\n            const isArrowHidden = cannotCenterArrow;\n            const arrowWidth = isArrowHidden ? 0 : options.arrowWidth;\n            const arrowHeight = isArrowHidden ? 0 : options.arrowHeight;\n            const [placedSide, placedAlign] = getSideAndAlignFromPlacement(placement);\n            const noArrowAlign = { start: \"0%\", center: \"50%\", end: \"100%\" }[placedAlign];\n            const arrowXCenter = (middlewareData.arrow?.x ?? 0) + arrowWidth / 2;\n            const arrowYCenter = (middlewareData.arrow?.y ?? 0) + arrowHeight / 2;\n            let x = \"\";\n            let y = \"\";\n            if (placedSide === \"bottom\") {\n                x = isArrowHidden ? noArrowAlign : `${arrowXCenter}px`;\n                y = `${-arrowHeight}px`;\n            }\n            else if (placedSide === \"top\") {\n                x = isArrowHidden ? noArrowAlign : `${arrowXCenter}px`;\n                y = `${rects.floating.height + arrowHeight}px`;\n            }\n            else if (placedSide === \"right\") {\n                x = `${-arrowHeight}px`;\n                y = isArrowHidden ? noArrowAlign : `${arrowYCenter}px`;\n            }\n            else if (placedSide === \"left\") {\n                x = `${rects.floating.width + arrowHeight}px`;\n                y = isArrowHidden ? noArrowAlign : `${arrowYCenter}px`;\n            }\n            return { data: { x, y } };\n        },\n    };\n}\nfunction getSideAndAlignFromPlacement(placement) {\n    const [side, align = \"center\"] = placement.split(\"-\");\n    return [side, align];\n}\nexport function getSideFromPlacement(placement) {\n    return getSideAndAlignFromPlacement(placement)[0];\n}\nexport function getAlignFromPlacement(placement) {\n    return getSideAndAlignFromPlacement(placement)[1];\n}\n","<script lang=\"ts\">\n\timport type { Snippet } from \"svelte\";\n\timport { useFloatingRootState } from \"../useFloatingLayer.svelte.js\";\n\n\tlet { children }: { children?: Snippet } = $props();\n\n\tuseFloatingRootState();\n</script>\n\n{@render children?.()}\n","import { box } from \"svelte-toolbelt\";\n/**\n * Creates a box which will be reset to the default value after some time.\n *\n * @param defaultValue The value which will be set.\n * @param afterMs      A zero-or-greater delay in milliseconds.\n */\nexport function boxAutoReset(defaultValue, afterMs = 10000) {\n    let timeout = null;\n    let value = $state(defaultValue);\n    function resetAfter() {\n        return setTimeout(() => {\n            value = defaultValue;\n        }, afterMs);\n    }\n    $effect(() => {\n        return () => {\n            if (timeout)\n                clearTimeout(timeout);\n        };\n    });\n    return box.with(() => value, (v) => {\n        value = v;\n        if (timeout)\n            clearTimeout(timeout);\n        timeout = resetAfter();\n    });\n}\n","import { getNextMatch } from \"./arrays.js\";\nimport { boxAutoReset } from \"./box-auto-reset.svelte.js\";\nexport function useDOMTypeahead(opts) {\n    // Reset `search` 1 second after it was last updated\n    const search = boxAutoReset(\"\", 1000);\n    const onMatch = opts?.onMatch ?? ((node) => node.focus());\n    const getCurrentItem = opts?.getCurrentItem ?? (() => document.activeElement);\n    function handleTypeaheadSearch(key, candidates) {\n        if (!candidates.length)\n            return;\n        search.current = search.current + key;\n        const currentItem = getCurrentItem();\n        const currentMatch = candidates.find((item) => item === currentItem)?.textContent?.trim() ?? \"\";\n        const values = candidates.map((item) => item.textContent?.trim() ?? \"\");\n        const nextMatch = getNextMatch(values, search.current, currentMatch);\n        const newItem = candidates.find((item) => item.textContent?.trim() === nextMatch);\n        if (newItem) {\n            onMatch(newItem);\n        }\n        return newItem;\n    }\n    function resetTypeahead() {\n        search.current = \"\";\n    }\n    return {\n        search,\n        handleTypeaheadSearch,\n        resetTypeahead,\n    };\n}\n","<script lang=\"ts\">\n\timport { box } from \"svelte-toolbelt\";\n\timport { useFloatingAnchorState } from \"../useFloatingLayer.svelte.js\";\n\timport type { AnchorProps } from \"./index.js\";\n\timport type { Measurable } from \"../../../../internal/floating-svelte/types.js\";\n\n\tlet { id, children, virtualEl }: AnchorProps = $props();\n\n\tuseFloatingAnchorState({\n\t\tid: box.with(() => id),\n\t\tvirtualEl: box.with(() => virtualEl as unknown as Measurable | null),\n\t});\n</script>\n\n{@render children?.()}\n","<script lang=\"ts\">\n\timport { box, mergeProps } from \"svelte-toolbelt\";\n\timport { useFloatingContentState } from \"../useFloatingLayer.svelte.js\";\n\timport type { ContentImplProps } from \"./index.js\";\n\timport { useId } from \"../../../../internal/use-id.js\";\n\n\tlet {\n\t\tcontent,\n\t\tside = \"bottom\",\n\t\tsideOffset = 0,\n\t\talign = \"center\",\n\t\talignOffset = 0,\n\t\tid,\n\t\tarrowPadding = 0,\n\t\tavoidCollisions = true,\n\t\tcollisionBoundary = [],\n\t\tcollisionPadding = 0,\n\t\thideWhenDetached = false,\n\t\tonPlaced = () => {},\n\t\tsticky = \"partial\",\n\t\tupdatePositionStrategy = \"optimized\",\n\t\tstrategy = \"fixed\",\n\t\tdir = \"ltr\",\n\t\tstyle = {},\n\t\twrapperId = useId(),\n\t\tcustomAnchor = null,\n\t}: ContentImplProps = $props();\n\n\tconst contentState = useFloatingContentState({\n\t\tside: box.with(() => side),\n\t\tsideOffset: box.with(() => sideOffset),\n\t\talign: box.with(() => align),\n\t\talignOffset: box.with(() => alignOffset),\n\t\tid: box.with(() => id),\n\t\tarrowPadding: box.with(() => arrowPadding),\n\t\tavoidCollisions: box.with(() => avoidCollisions),\n\t\tcollisionBoundary: box.with(() => collisionBoundary),\n\t\tcollisionPadding: box.with(() => collisionPadding),\n\t\thideWhenDetached: box.with(() => hideWhenDetached),\n\t\tonPlaced: box.with(() => onPlaced),\n\t\tsticky: box.with(() => sticky),\n\t\tupdatePositionStrategy: box.with(() => updatePositionStrategy),\n\t\tstrategy: box.with(() => strategy),\n\t\tdir: box.with(() => dir),\n\t\tstyle: box.with(() => style),\n\t\tenabled: box.with(() => false),\n\t\twrapperId: box.with(() => wrapperId),\n\t\tcustomAnchor: box.with(() => customAnchor),\n\t});\n\n\tconst mergedProps = $derived(\n\t\tmergeProps(contentState.wrapperProps, {\n\t\t\tstyle: {\n\t\t\t\tpointerEvents: \"auto\",\n\t\t\t},\n\t\t})\n\t);\n</script>\n\n<div {...mergedProps}>\n\t{@render content?.({ props: contentState.props })}\n</div>\n","<script lang=\"ts\">\n\timport { type Snippet, onMount } from \"svelte\";\n\n\tlet {\n\t\tcontent,\n\t\tonPlaced,\n\t}: {\n\t\tcontent?: Snippet<[{ props: Record<string, unknown> }]>;\n\t\tonPlaced?: () => void;\n\t} = $props();\n\n\tonMount(() => {\n\t\tonPlaced?.();\n\t});\n</script>\n\n{@render content?.({ props: {} })}\n","<script lang=\"ts\">\n\timport FloatingLayerContentStatic from \"../floating-layer/components/floating-layer-content-static.svelte\";\n\timport FloatingLayerContent from \"../floating-layer/components/floating-layer-content.svelte\";\n\timport type { FloatingLayerContentImplProps } from \"../floating-layer/types.js\";\n\n\tlet {\n\t\tcontent,\n\t\tisStatic = false,\n\t\tonPlaced,\n\t\t...restProps\n\t}: FloatingLayerContentImplProps & { isStatic: boolean } = $props();\n</script>\n\n{#if isStatic}\n\t<FloatingLayerContentStatic {content} {onPlaced} />\n{:else}\n\t<FloatingLayerContent {content} {onPlaced} {...restProps} />\n{/if}\n","<script lang=\"ts\">\n\timport { mergeProps } from \"svelte-toolbelt\";\n\timport ScrollLock from \"../scroll-lock/scroll-lock.svelte\";\n\timport type { PopperLayerImplProps } from \"./types.js\";\n\timport PopperContent from \"./popper-content.svelte\";\n\timport EscapeLayer from \"../escape-layer/escape-layer.svelte\";\n\timport DismissibleLayer from \"../dismissible-layer/dismissible-layer.svelte\";\n\timport TextSelectionLayer from \"../text-selection-layer/text-selection-layer.svelte\";\n\timport FocusScope from \"../focus-scope/focus-scope.svelte\";\n\n\tlet {\n\t\tpopper,\n\t\tonEscapeKeydown,\n\t\tescapeKeydownBehavior,\n\t\tpreventOverflowTextSelection,\n\t\tid,\n\t\tonPointerDown,\n\t\tonPointerUp,\n\t\tside,\n\t\tsideOffset,\n\t\talign,\n\t\talignOffset,\n\t\tarrowPadding,\n\t\tavoidCollisions,\n\t\tcollisionBoundary,\n\t\tcollisionPadding,\n\t\tsticky,\n\t\thideWhenDetached,\n\t\tupdatePositionStrategy,\n\t\tstrategy,\n\t\tdir,\n\t\tpreventScroll,\n\t\twrapperId,\n\t\tstyle,\n\t\tonPlaced,\n\t\tonInteractOutside,\n\t\tonCloseAutoFocus,\n\t\tonOpenAutoFocus,\n\t\tonFocusOutside,\n\t\tinteractOutsideBehavior = \"close\",\n\t\tloop,\n\t\ttrapFocus = true,\n\t\tisValidEvent = () => false,\n\t\tcustomAnchor = null,\n\t\tisStatic = false,\n\t\tenabled,\n\t\t...restProps\n\t}: Omit<PopperLayerImplProps, \"present\" | \"children\"> & {\n\t\tenabled: boolean;\n\t} = $props();\n</script>\n\n<PopperContent\n\t{isStatic}\n\t{id}\n\t{side}\n\t{sideOffset}\n\t{align}\n\t{alignOffset}\n\t{arrowPadding}\n\t{avoidCollisions}\n\t{collisionBoundary}\n\t{collisionPadding}\n\t{sticky}\n\t{hideWhenDetached}\n\t{updatePositionStrategy}\n\t{strategy}\n\t{dir}\n\t{wrapperId}\n\t{style}\n\t{onPlaced}\n\t{customAnchor}\n>\n\t{#snippet content({ props: floatingProps })}\n\t\t{#if restProps.forceMount && enabled}\n\t\t\t<ScrollLock {preventScroll} />\n\t\t{:else if !restProps.forceMount}\n\t\t\t<ScrollLock {preventScroll} />\n\t\t{/if}\n\t\t<FocusScope\n\t\t\t{id}\n\t\t\t{onOpenAutoFocus}\n\t\t\t{onCloseAutoFocus}\n\t\t\t{loop}\n\t\t\ttrapFocus={enabled && trapFocus}\n\t\t\tforceMount={restProps.forceMount}\n\t\t>\n\t\t\t{#snippet focusScope({ props: focusScopeProps })}\n\t\t\t\t<EscapeLayer {onEscapeKeydown} {escapeKeydownBehavior} {enabled}>\n\t\t\t\t\t<DismissibleLayer\n\t\t\t\t\t\t{id}\n\t\t\t\t\t\t{onInteractOutside}\n\t\t\t\t\t\t{onFocusOutside}\n\t\t\t\t\t\t{interactOutsideBehavior}\n\t\t\t\t\t\t{isValidEvent}\n\t\t\t\t\t\t{enabled}\n\t\t\t\t\t>\n\t\t\t\t\t\t{#snippet children({ props: dismissibleProps })}\n\t\t\t\t\t\t\t<TextSelectionLayer\n\t\t\t\t\t\t\t\t{id}\n\t\t\t\t\t\t\t\t{preventOverflowTextSelection}\n\t\t\t\t\t\t\t\t{onPointerDown}\n\t\t\t\t\t\t\t\t{onPointerUp}\n\t\t\t\t\t\t\t\t{enabled}\n\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t{@render popper?.({\n\t\t\t\t\t\t\t\t\tprops: mergeProps(\n\t\t\t\t\t\t\t\t\t\trestProps,\n\t\t\t\t\t\t\t\t\t\tfloatingProps,\n\t\t\t\t\t\t\t\t\t\tdismissibleProps,\n\t\t\t\t\t\t\t\t\t\tfocusScopeProps,\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tstyle: {\n\t\t\t\t\t\t\t\t\t\t\t\tpointerEvents: \"auto\",\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t\t})}\n\t\t\t\t\t\t\t</TextSelectionLayer>\n\t\t\t\t\t\t{/snippet}\n\t\t\t\t\t</DismissibleLayer>\n\t\t\t\t</EscapeLayer>\n\t\t\t{/snippet}\n\t\t</FocusScope>\n\t{/snippet}\n</PopperContent>\n","<script lang=\"ts\">\n\timport type { PopperLayerImplProps } from \"./types.js\";\n\timport PopperLayerInner from \"./popper-layer-inner.svelte\";\n\timport PresenceLayer from \"../presence-layer/presence-layer.svelte\";\n\n\tlet {\n\t\tpopper,\n\t\tpresent,\n\t\tonEscapeKeydown,\n\t\tescapeKeydownBehavior,\n\t\tpreventOverflowTextSelection,\n\t\tid,\n\t\tonPointerDown,\n\t\tonPointerUp,\n\t\tside,\n\t\tsideOffset,\n\t\talign,\n\t\talignOffset,\n\t\tarrowPadding,\n\t\tavoidCollisions,\n\t\tcollisionBoundary,\n\t\tcollisionPadding,\n\t\tsticky,\n\t\thideWhenDetached,\n\t\tupdatePositionStrategy,\n\t\tstrategy,\n\t\tdir,\n\t\tpreventScroll,\n\t\twrapperId,\n\t\tstyle,\n\t\tonPlaced,\n\t\tonInteractOutside,\n\t\tonCloseAutoFocus,\n\t\tonOpenAutoFocus,\n\t\tonFocusOutside,\n\t\tinteractOutsideBehavior = \"close\",\n\t\tloop,\n\t\ttrapFocus = true,\n\t\tisValidEvent = () => false,\n\t\tcustomAnchor = null,\n\t\tisStatic = false,\n\t\t...restProps\n\t}: PopperLayerImplProps = $props();\n</script>\n\n<PresenceLayer {id} {present} {...restProps}>\n\t{#snippet presence({ present })}\n\t\t<PopperLayerInner\n\t\t\t{popper}\n\t\t\t{onEscapeKeydown}\n\t\t\t{escapeKeydownBehavior}\n\t\t\t{preventOverflowTextSelection}\n\t\t\t{id}\n\t\t\t{onPointerDown}\n\t\t\t{onPointerUp}\n\t\t\t{side}\n\t\t\t{sideOffset}\n\t\t\t{align}\n\t\t\t{alignOffset}\n\t\t\t{arrowPadding}\n\t\t\t{avoidCollisions}\n\t\t\t{collisionBoundary}\n\t\t\t{collisionPadding}\n\t\t\t{sticky}\n\t\t\t{hideWhenDetached}\n\t\t\t{updatePositionStrategy}\n\t\t\t{strategy}\n\t\t\t{dir}\n\t\t\t{preventScroll}\n\t\t\t{wrapperId}\n\t\t\t{style}\n\t\t\t{onPlaced}\n\t\t\t{customAnchor}\n\t\t\t{isStatic}\n\t\t\tenabled={present.current}\n\t\t\t{onInteractOutside}\n\t\t\t{onCloseAutoFocus}\n\t\t\t{onOpenAutoFocus}\n\t\t\t{interactOutsideBehavior}\n\t\t\t{loop}\n\t\t\t{trapFocus}\n\t\t\t{isValidEvent}\n\t\t\t{onFocusOutside}\n\t\t\tforceMount={false}\n\t\t\t{...restProps}\n\t\t/>\n\t{/snippet}\n</PresenceLayer>\n","<script lang=\"ts\">\n\timport type { PopperLayerImplProps } from \"./types.js\";\n\timport PopperLayerInner from \"./popper-layer-inner.svelte\";\n\n\tlet {\n\t\tpopper,\n\t\tonEscapeKeydown,\n\t\tescapeKeydownBehavior,\n\t\tpreventOverflowTextSelection,\n\t\tid,\n\t\tonPointerDown,\n\t\tonPointerUp,\n\t\tside,\n\t\tsideOffset,\n\t\talign,\n\t\talignOffset,\n\t\tarrowPadding,\n\t\tavoidCollisions,\n\t\tcollisionBoundary,\n\t\tcollisionPadding,\n\t\tsticky,\n\t\thideWhenDetached,\n\t\tupdatePositionStrategy,\n\t\tstrategy,\n\t\tdir,\n\t\tpreventScroll,\n\t\twrapperId,\n\t\tstyle,\n\t\tonPlaced,\n\t\tonInteractOutside,\n\t\tonCloseAutoFocus,\n\t\tonOpenAutoFocus,\n\t\tonFocusOutside,\n\t\tinteractOutsideBehavior = \"close\",\n\t\tloop,\n\t\ttrapFocus = true,\n\t\tisValidEvent = () => false,\n\t\tcustomAnchor = null,\n\t\tisStatic = false,\n\t\tenabled,\n\t\t...restProps\n\t}: Omit<PopperLayerImplProps, \"present\"> & {\n\t\tenabled: boolean;\n\t} = $props();\n</script>\n\n<PopperLayerInner\n\t{popper}\n\t{onEscapeKeydown}\n\t{escapeKeydownBehavior}\n\t{preventOverflowTextSelection}\n\t{id}\n\t{onPointerDown}\n\t{onPointerUp}\n\t{side}\n\t{sideOffset}\n\t{align}\n\t{alignOffset}\n\t{arrowPadding}\n\t{avoidCollisions}\n\t{collisionBoundary}\n\t{collisionPadding}\n\t{sticky}\n\t{hideWhenDetached}\n\t{updatePositionStrategy}\n\t{strategy}\n\t{dir}\n\t{preventScroll}\n\t{wrapperId}\n\t{style}\n\t{onPlaced}\n\t{customAnchor}\n\t{isStatic}\n\t{enabled}\n\t{onInteractOutside}\n\t{onCloseAutoFocus}\n\t{onOpenAutoFocus}\n\t{interactOutsideBehavior}\n\t{loop}\n\t{trapFocus}\n\t{isValidEvent}\n\t{onFocusOutside}\n\t{...restProps}\n\tforceMount={true}\n/>\n","<script lang=\"ts\">\n\timport { untrack } from \"svelte\";\n\timport { noop } from \"../../internal/noop.js\";\n\n\tlet {\n\t\tisMounted = $bindable(false),\n\t\tonMountedChange = noop,\n\t}: { isMounted?: boolean; onMountedChange?: (mounted: boolean) => void } = $props();\n\n\t$effect(() => {\n\t\tuntrack(() => {\n\t\t\tisMounted = true;\n\t\t\tonMountedChange(true);\n\t\t});\n\t\treturn () => {\n\t\t\tisMounted = false;\n\t\t\tonMountedChange(false);\n\t\t};\n\t});\n</script>\n","import { kbd } from \"../../internal/kbd.js\";\nexport const ITEM_NAME = \"MenuItem\";\nexport const SELECTION_KEYS = [kbd.ENTER, kbd.SPACE];\nexport const FIRST_KEYS = [kbd.ARROW_DOWN, kbd.PAGE_UP, kbd.HOME];\nexport const LAST_KEYS = [kbd.ARROW_UP, kbd.PAGE_DOWN, kbd.END];\nexport const FIRST_LAST_KEYS = [...FIRST_KEYS, ...LAST_KEYS];\nexport const SUB_OPEN_KEYS = {\n    ltr: [...SELECTION_KEYS, kbd.ARROW_RIGHT],\n    rtl: [...SELECTION_KEYS, kbd.ARROW_LEFT],\n};\nexport const SUB_CLOSE_KEYS = {\n    ltr: [kbd.ARROW_LEFT],\n    rtl: [kbd.ARROW_RIGHT],\n};\nexport function isIndeterminate(checked) {\n    return checked === \"indeterminate\";\n}\nexport function getCheckedState(checked) {\n    return isIndeterminate(checked) ? \"indeterminate\" : checked ? \"checked\" : \"unchecked\";\n}\nexport function isMouseEvent(event) {\n    return event.pointerType === \"mouse\";\n}\n","/*\n * Convex hull algorithm - Library (TypeScript)\n *\n * Copyright (c) 2021 Project Nayuki\n * https://www.nayuki.io/page/convex-hull-algorithm\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Lesser General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with this program (see COPYING.txt and COPYING.LESSER.txt).\n * If not, see <http://www.gnu.org/licenses/>.\n */\n// Returns a new array of points representing the convex hull of\n// the given set of points. The convex hull excludes collinear points.\n// This algorithm runs in O(n log n) time.\nfunction makeHull(points) {\n    const newPoints = points.slice();\n    newPoints.sort(POINT_COMPARATOR);\n    return makeHullPresorted(newPoints);\n}\n// Returns the convex hull, assuming that each points[i] <= points[i + 1]. Runs in O(n) time.\nexport function makeHullPresorted(points) {\n    if (points.length <= 1)\n        return points.slice();\n    // Andrew's monotone chain algorithm. Positive y coordinates correspond to \"up\"\n    // as per the mathematical convention, instead of \"down\" as per the computer\n    // graphics convention. This doesn't affect the correctness of the result.\n    const upperHull = [];\n    for (let i = 0; i < points.length; i++) {\n        const p = points[i];\n        while (upperHull.length >= 2) {\n            const q = upperHull[upperHull.length - 1];\n            const r = upperHull[upperHull.length - 2];\n            if ((q.x - r.x) * (p.y - r.y) >= (q.y - r.y) * (p.x - r.x))\n                upperHull.pop();\n            else\n                break;\n        }\n        upperHull.push(p);\n    }\n    upperHull.pop();\n    const lowerHull = [];\n    for (let i = points.length - 1; i >= 0; i--) {\n        const p = points[i];\n        while (lowerHull.length >= 2) {\n            const q = lowerHull[lowerHull.length - 1];\n            const r = lowerHull[lowerHull.length - 2];\n            if ((q.x - r.x) * (p.y - r.y) >= (q.y - r.y) * (p.x - r.x))\n                lowerHull.pop();\n            else\n                break;\n        }\n        lowerHull.push(p);\n    }\n    lowerHull.pop();\n    if (upperHull.length === 1 &&\n        lowerHull.length === 1 &&\n        upperHull[0].x === lowerHull[0].x &&\n        upperHull[0].y === lowerHull[0].y)\n        return upperHull;\n    else\n        return upperHull.concat(lowerHull);\n}\nexport function POINT_COMPARATOR(a, b) {\n    if (a.x < b.x)\n        return -1;\n    else if (a.x > b.x)\n        return +1;\n    else if (a.y < b.y)\n        return -1;\n    else if (a.y > b.y)\n        return +1;\n    else\n        return 0;\n}\nfunction getPointsFromEl(el) {\n    const rect = el.getBoundingClientRect();\n    return [\n        { x: rect.left, y: rect.top },\n        { x: rect.right, y: rect.top },\n        { x: rect.right, y: rect.bottom },\n        { x: rect.left, y: rect.bottom },\n    ];\n}\nexport function makeHullFromElements(els) {\n    const points = els.flatMap((el) => getPointsFromEl(el));\n    return makeHull(points);\n}\nexport function pointInPolygon(point, polygon) {\n    let inside = false;\n    for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {\n        const xi = polygon[i].x;\n        const yi = polygon[i].y;\n        const xj = polygon[j].x;\n        const yj = polygon[j].y;\n        const intersect = yi > point.y !== yj > point.y &&\n            point.x < ((xj - xi) * (point.y - yi)) / (yj - yi) + xi;\n        if (intersect)\n            inside = !inside;\n    }\n    return inside;\n}\nexport function isPointerInGraceArea(e, area) {\n    if (!area)\n        return false;\n    return pointInPolygon({ x: e.clientX, y: e.clientY }, area);\n}\n","import { afterTick, box, executeCallbacks, mergeProps, onDestroyEffect, useRefById, } from \"svelte-toolbelt\";\nimport { tick, untrack } from \"svelte\";\nimport { IsFocusWithin } from \"runed\";\nimport { FIRST_LAST_KEYS, LAST_KEYS, SELECTION_KEYS, SUB_OPEN_KEYS, getCheckedState, isMouseEvent, } from \"./utils.js\";\nimport { focusFirst } from \"../../internal/focus.js\";\nimport { addEventListener } from \"../../internal/events.js\";\nimport { useDOMTypeahead } from \"../../internal/use-dom-typeahead.svelte.js\";\nimport { isElement, isElementOrSVGElement, isHTMLElement } from \"../../internal/is.js\";\nimport { useRovingFocus } from \"../../internal/use-roving-focus.svelte.js\";\nimport { kbd } from \"../../internal/kbd.js\";\nimport { getAriaChecked, getAriaDisabled, getAriaExpanded, getAriaOrientation, getDataDisabled, getDataOpenClosed, } from \"../../internal/attrs.js\";\nimport { createContext } from \"../../internal/create-context.js\";\nimport { isPointerInGraceArea, makeHullFromElements } from \"../../internal/polygon.js\";\nexport const CONTEXT_MENU_TRIGGER_ATTR = \"data-context-menu-trigger\";\nconst [setMenuRootContext, getMenuRootContext] = createContext(\"Menu.Root\");\nconst [setMenuMenuContext, getMenuMenuContext] = createContext([\"Menu.Root\", \"Menu.Sub\"], \"MenuContext\");\nconst [setMenuContentContext, getMenuContentContext] = createContext(\"Menu.Content\");\nconst [setMenuGroupContext, getMenuGroupContext] = createContext(\"Menu.Group\");\nconst [setMenuRadioGroupContext, getMenuRadioGroupContext] = createContext(\"Menu.RadioGroup\");\nclass MenuRootState {\n    onClose;\n    variant;\n    isUsingKeyboard = box(false);\n    dir;\n    constructor(props) {\n        this.onClose = props.onClose;\n        this.dir = props.dir;\n        this.variant = props.variant;\n        $effect(() => {\n            const callbacksToDispose = [];\n            const handlePointer = (_) => {\n                this.isUsingKeyboard.current = false;\n            };\n            const handleKeydown = (_) => {\n                this.isUsingKeyboard.current = true;\n                const disposePointerDown = addEventListener(document, \"pointerdown\", handlePointer, { capture: true, once: true });\n                const disposePointerMove = addEventListener(document, \"pointermove\", handlePointer, { capture: true, once: true });\n                callbacksToDispose.push(disposePointerDown, disposePointerMove);\n            };\n            const disposeKeydown = addEventListener(document, \"keydown\", handleKeydown, {\n                capture: true,\n            });\n            callbacksToDispose.push(disposeKeydown);\n            return () => {\n                executeCallbacks(callbacksToDispose);\n            };\n        });\n    }\n    getAttr = (name) => {\n        return `data-${this.variant.current}-${name}`;\n    };\n}\nclass MenuMenuState {\n    root;\n    open;\n    contentId = box.with(() => \"\");\n    contentNode = $state(null);\n    triggerNode = $state(null);\n    parentMenu;\n    constructor(props, root, parentMenu) {\n        this.root = root;\n        this.open = props.open;\n        this.parentMenu = parentMenu;\n        if (parentMenu) {\n            $effect(() => {\n                parentMenu.open;\n                untrack(() => {\n                    if (!this.parentMenu?.open)\n                        this.open.current = false;\n                });\n            });\n        }\n    }\n    toggleOpen = () => {\n        this.open.current = !this.open.current;\n    };\n    onOpen = () => {\n        this.open.current = true;\n    };\n    onClose = () => {\n        this.open.current = false;\n    };\n}\nclass MenuContentState {\n    #id;\n    contentRef;\n    parentMenu;\n    search = $state(\"\");\n    #loop;\n    #timer = $state(0);\n    pointerGraceTimer = $state(0);\n    #pointerGraceIntent = $state(null);\n    #pointerDir = $state(\"right\");\n    #lastPointerX = $state(0);\n    #handleTypeaheadSearch;\n    rovingFocusGroup;\n    isMounted;\n    isFocusWithin = new IsFocusWithin(() => this.parentMenu.contentNode ?? undefined);\n    constructor(props, parentMenu) {\n        this.#id = props.id;\n        this.#loop = props.loop;\n        this.parentMenu = parentMenu;\n        this.parentMenu.contentId = props.id;\n        this.contentRef = props.ref;\n        this.isMounted = props.isMounted;\n        useRefById({\n            id: this.#id,\n            ref: this.contentRef,\n            deps: () => this.parentMenu.open.current,\n            onRefChange: (node) => {\n                if (this.parentMenu.contentNode !== node) {\n                    this.parentMenu.contentNode = node;\n                }\n            },\n        });\n        onDestroyEffect(() => {\n            window.clearTimeout(this.#timer);\n        });\n        this.#handleTypeaheadSearch = useDOMTypeahead().handleTypeaheadSearch;\n        this.rovingFocusGroup = useRovingFocus({\n            rootNodeId: this.parentMenu.contentId,\n            candidateAttr: this.parentMenu.root.getAttr(\"item\"),\n            loop: this.#loop,\n            orientation: box.with(() => \"vertical\"),\n        });\n    }\n    getCandidateNodes = () => {\n        const node = this.parentMenu.contentNode;\n        if (!node)\n            return [];\n        const candidates = Array.from(node.querySelectorAll(`[${this.parentMenu.root.getAttr(\"item\")}]:not([data-disabled])`));\n        return candidates;\n    };\n    isPointerMovingToSubmenu = (e) => {\n        const isMovingTowards = this.#pointerDir === this.#pointerGraceIntent?.side;\n        return isMovingTowards && isPointerInGraceArea(e, this.#pointerGraceIntent?.area);\n    };\n    onPointerGraceIntentChange = (intent) => {\n        this.#pointerGraceIntent = intent;\n    };\n    #onkeydown = (e) => {\n        if (e.defaultPrevented)\n            return;\n        const target = e.target;\n        const currentTarget = e.currentTarget;\n        if (!isHTMLElement(target) || !isHTMLElement(currentTarget))\n            return;\n        const isKeydownInside = target.closest(`[${this.parentMenu.root.getAttr(\"content\")}]`)?.id ===\n            this.parentMenu.contentId.current;\n        const isModifierKey = e.ctrlKey || e.altKey || e.metaKey;\n        const isCharacterKey = e.key.length === 1;\n        const kbdFocusedEl = this.rovingFocusGroup.handleKeydown(target, e);\n        if (kbdFocusedEl)\n            return;\n        // prevent space from being considered with typeahead\n        if (e.code === \"Space\")\n            return;\n        const candidateNodes = this.getCandidateNodes();\n        if (isKeydownInside) {\n            // menus do not respect the tab key\n            if (e.key === kbd.TAB)\n                e.preventDefault();\n            if (!isModifierKey && isCharacterKey) {\n                this.#handleTypeaheadSearch(e.key, candidateNodes);\n            }\n        }\n        // focus first/last based on key pressed\n        if (e.target?.id !== this.parentMenu.contentId.current)\n            return;\n        if (!FIRST_LAST_KEYS.includes(e.key))\n            return;\n        e.preventDefault();\n        if (LAST_KEYS.includes(e.key)) {\n            candidateNodes.reverse();\n        }\n        focusFirst(candidateNodes);\n    };\n    #onblur = (e) => {\n        if (!isElement(e.currentTarget))\n            return;\n        if (!isElement(e.target))\n            return;\n        // clear search buffer when leaving the menu\n        if (!e.currentTarget.contains?.(e.target)) {\n            window.clearTimeout(this.#timer);\n            this.search = \"\";\n        }\n    };\n    #onfocus = () => {\n        if (!this.parentMenu.root.isUsingKeyboard.current)\n            return;\n        afterTick(() => this.rovingFocusGroup.focusFirstCandidate());\n    };\n    #onpointermove = (e) => {\n        if (!isMouseEvent(e))\n            return;\n        const target = e.target;\n        if (!isElement(target))\n            return;\n        const pointerXHasChanged = this.#lastPointerX !== e.clientX;\n        const currentTarget = e.currentTarget;\n        if (!isElement(currentTarget))\n            return;\n        // We don't use `event.movementX` for this check because Safari will\n        // always return `0` on a pointer event.\n        if (currentTarget.contains(target) && pointerXHasChanged) {\n            const newDir = e.clientX > this.#lastPointerX ? \"right\" : \"left\";\n            this.#pointerDir = newDir;\n            this.#lastPointerX = e.clientX;\n        }\n    };\n    onItemEnter = (e) => {\n        if (this.isPointerMovingToSubmenu(e))\n            return true;\n        return false;\n    };\n    onItemLeave = (e) => {\n        if (this.isPointerMovingToSubmenu(e))\n            return;\n        const contentNode = this.parentMenu.contentNode;\n        contentNode?.focus();\n        this.rovingFocusGroup.setCurrentTabStopId(\"\");\n    };\n    onTriggerLeave = (e) => {\n        if (this.isPointerMovingToSubmenu(e))\n            return true;\n        return false;\n    };\n    onOpenAutoFocus = (e) => {\n        if (e.defaultPrevented)\n            return;\n        e.preventDefault();\n        const contentNode = this.parentMenu.contentNode;\n        contentNode?.focus();\n    };\n    handleInteractOutside = (e) => {\n        if (!isElementOrSVGElement(e.target))\n            return;\n        const triggerId = this.parentMenu.triggerNode?.id;\n        if (e.target.id === triggerId) {\n            e.preventDefault();\n            return;\n        }\n        if (e.target.closest(`#${triggerId}`)) {\n            e.preventDefault();\n        }\n    };\n    snippetProps = $derived.by(() => ({ open: this.parentMenu.open.current }));\n    props = $derived.by(() => ({\n        id: this.#id.current,\n        role: \"menu\",\n        \"aria-orientation\": getAriaOrientation(\"vertical\"),\n        [this.parentMenu.root.getAttr(\"content\")]: \"\",\n        \"data-state\": getDataOpenClosed(this.parentMenu.open.current),\n        onkeydown: this.#onkeydown,\n        onblur: this.#onblur,\n        onpointermove: this.#onpointermove,\n        onfocus: this.#onfocus,\n        dir: this.parentMenu.root.dir.current,\n        style: {\n            pointerEvents: \"auto\",\n        },\n    }));\n}\nclass MenuItemSharedState {\n    content;\n    ref;\n    id;\n    disabled;\n    #isFocused = $state(false);\n    constructor(props, content) {\n        this.content = content;\n        this.id = props.id;\n        this.disabled = props.disabled;\n        this.ref = props.ref;\n        useRefById({\n            id: this.id,\n            ref: this.ref,\n            deps: () => this.content.isMounted.current,\n        });\n    }\n    #onpointermove = (e) => {\n        if (e.defaultPrevented)\n            return;\n        if (!isMouseEvent(e))\n            return;\n        if (this.disabled.current) {\n            this.content.onItemLeave(e);\n        }\n        else {\n            const defaultPrevented = this.content.onItemEnter(e);\n            if (defaultPrevented)\n                return;\n            const item = e.currentTarget;\n            if (!isHTMLElement(item))\n                return;\n            item.focus();\n        }\n    };\n    #onpointerleave = async (e) => {\n        afterTick(() => {\n            if (e.defaultPrevented)\n                return;\n            if (!isMouseEvent(e))\n                return;\n            this.content.onItemLeave(e);\n        });\n    };\n    #onfocus = async (e) => {\n        afterTick(() => {\n            if (e.defaultPrevented || this.disabled.current)\n                return;\n            this.#isFocused = true;\n        });\n    };\n    #onblur = async (e) => {\n        afterTick(() => {\n            if (e.defaultPrevented)\n                return;\n            this.#isFocused = false;\n        });\n    };\n    props = $derived.by(() => ({\n        id: this.id.current,\n        tabindex: -1,\n        role: \"menuitem\",\n        \"aria-disabled\": getAriaDisabled(this.disabled.current),\n        \"data-disabled\": getDataDisabled(this.disabled.current),\n        \"data-highlighted\": this.#isFocused ? \"\" : undefined,\n        [this.content.parentMenu.root.getAttr(\"item\")]: \"\",\n        //\n        onpointermove: this.#onpointermove,\n        onpointerleave: this.#onpointerleave,\n        onfocus: this.#onfocus,\n        onblur: this.#onblur,\n    }));\n}\nclass MenuItemState {\n    #item;\n    #onSelect;\n    #isPointerDown = $state(false);\n    root;\n    constructor(props, item) {\n        this.#item = item;\n        this.root = item.content.parentMenu.root;\n        this.#onSelect = props.onSelect;\n    }\n    #onkeydown = (e) => {\n        const isTypingAhead = this.#item.content.search !== \"\";\n        if (this.#item.disabled.current || (isTypingAhead && e.key === kbd.SPACE))\n            return;\n        if (SELECTION_KEYS.includes(e.key)) {\n            if (!isHTMLElement(e.currentTarget))\n                return;\n            e.currentTarget.click();\n            /**\n             * We prevent default browser behavior for selection keys as they should trigger\n             * a selection only:\n             * - prevents space from scrolling the page.\n             * - if keydown causes focus to move, prevents keydown from firing on the new target.\n             */\n            e.preventDefault();\n        }\n    };\n    #handleSelect = async () => {\n        if (this.#item.disabled.current)\n            return;\n        const selectEvent = new CustomEvent(\"menuitemselect\", { bubbles: true, cancelable: true });\n        this.#onSelect.current(selectEvent);\n        await tick();\n        if (selectEvent.defaultPrevented) {\n            this.#item.content.parentMenu.root.isUsingKeyboard.current = false;\n        }\n        else {\n            this.#item.content.parentMenu.root.onClose();\n        }\n    };\n    #onclick = () => {\n        if (this.#item.disabled.current)\n            return;\n        this.#handleSelect();\n    };\n    #onpointerup = async (e) => {\n        if (e.defaultPrevented)\n            return;\n        if (!this.#isPointerDown) {\n            if (!isHTMLElement(e.currentTarget))\n                return;\n            e.currentTarget?.click();\n        }\n    };\n    #onpointerdown = () => {\n        this.#isPointerDown = true;\n    };\n    props = $derived.by(() => mergeProps(this.#item.props, {\n        onclick: this.#onclick,\n        onpointerdown: this.#onpointerdown,\n        onpointerup: this.#onpointerup,\n        onkeydown: this.#onkeydown,\n    }));\n}\nclass MenuSubTriggerState {\n    #item;\n    // The menu this sub-trigger item belongs within\n    #content;\n    // the menu this sub-trigger item opens\n    #submenu;\n    #openTimer = $state(null);\n    constructor(item, content, submenu) {\n        this.#item = item;\n        this.#content = content;\n        this.#submenu = submenu;\n        onDestroyEffect(() => {\n            this.#clearOpenTimer();\n        });\n        useRefById({\n            id: this.#item.id,\n            ref: this.#item.ref,\n            onRefChange: (node) => {\n                this.#submenu.triggerNode = node;\n            },\n        });\n    }\n    #clearOpenTimer = () => {\n        if (this.#openTimer === null)\n            return;\n        window.clearTimeout(this.#openTimer);\n        this.#openTimer = null;\n    };\n    #onpointermove = (e) => {\n        if (!isMouseEvent(e))\n            return;\n        const defaultPrevented = this.#content.onItemEnter(e);\n        if (defaultPrevented)\n            return;\n        if (!this.#item.disabled.current && !this.#submenu.open.current && !this.#openTimer) {\n            this.#content.onPointerGraceIntentChange(null);\n            this.#openTimer = window.setTimeout(() => {\n                this.#submenu.onOpen();\n                this.#clearOpenTimer();\n            }, 100);\n        }\n    };\n    #onpointerleave = (e) => {\n        if (!isMouseEvent(e))\n            return;\n        this.#clearOpenTimer();\n        const contentNode = this.#submenu.contentNode;\n        const subTriggerNode = this.#item.ref.current;\n        if (contentNode && subTriggerNode) {\n            const polygon = makeHullFromElements([subTriggerNode, contentNode]);\n            const side = contentNode?.dataset.side;\n            this.#content.onPointerGraceIntentChange({\n                area: polygon,\n                side,\n            });\n            window.clearTimeout(this.#content.pointerGraceTimer);\n            this.#content.pointerGraceTimer = window.setTimeout(() => this.#content.onPointerGraceIntentChange(null), 300);\n        }\n        else {\n            const defaultPrevented = this.#content.onTriggerLeave(e);\n            if (defaultPrevented)\n                return;\n            // There's 100ms where the user may leave an item before the submenu was opened.\n            this.#content.onPointerGraceIntentChange(null);\n        }\n    };\n    #onkeydown = (e) => {\n        const isTypingAhead = this.#content.search !== \"\";\n        if (this.#item.disabled.current || (isTypingAhead && e.key === kbd.SPACE))\n            return;\n        if (SUB_OPEN_KEYS[this.#submenu.root.dir.current].includes(e.key)) {\n            this.#submenu.onOpen();\n            const contentNode = this.#submenu.contentNode;\n            contentNode?.focus();\n            e.preventDefault();\n        }\n    };\n    #onclick = (e) => {\n        if (this.#item.disabled.current)\n            return;\n        /**\n         * We manually focus because iOS Safari doesn't always focus on click (e.g. buttons)\n         * and we rely heavily on `onFocusOutside` for submenus to close when switching\n         * between separate submenus.\n         */\n        if (!isHTMLElement(e.currentTarget))\n            return;\n        e.currentTarget.focus();\n        if (!this.#submenu.open.current) {\n            this.#submenu.onOpen();\n        }\n    };\n    props = $derived.by(() => mergeProps({\n        \"aria-haspopup\": \"menu\",\n        \"aria-expanded\": getAriaExpanded(this.#submenu.open.current),\n        \"data-state\": getDataOpenClosed(this.#submenu.open.current),\n        \"aria-controls\": this.#submenu.open.current\n            ? this.#submenu.contentId.current\n            : undefined,\n        [this.#submenu.root.getAttr(\"sub-trigger\")]: \"\",\n        onclick: this.#onclick,\n        onpointermove: this.#onpointermove,\n        onpointerleave: this.#onpointerleave,\n        onkeydown: this.#onkeydown,\n    }, this.#item.props));\n}\nclass MenuCheckboxItemState {\n    #item;\n    #checked;\n    constructor(props, item) {\n        this.#item = item;\n        this.#checked = props.checked;\n    }\n    toggleChecked = () => {\n        if (this.#checked.current === true) {\n            this.#checked.current = false;\n        }\n        else if (this.#checked.current === false) {\n            this.#checked.current = true;\n        }\n        else if (this.#checked.current === \"indeterminate\") {\n            this.#checked.current = true;\n        }\n    };\n    props = $derived.by(() => ({\n        ...this.#item.props,\n        role: \"menuitemcheckbox\",\n        \"aria-checked\": getAriaChecked(this.#checked.current),\n        \"data-state\": getCheckedState(this.#checked.current),\n        [this.#item.root.getAttr(\"checkbox-item\")]: \"\",\n    }));\n}\nclass MenuGroupState {\n    #id;\n    #ref;\n    groupHeadingId = $state(undefined);\n    root;\n    constructor(props, root) {\n        this.#id = props.id;\n        this.#ref = props.ref;\n        this.root = root;\n        useRefById({\n            id: this.#id,\n            ref: this.#ref,\n        });\n    }\n    props = $derived.by(() => ({\n        id: this.#id.current,\n        role: \"group\",\n        \"aria-labelledby\": this.groupHeadingId,\n        [this.root.getAttr(\"group\")]: \"\",\n    }));\n}\nclass MenuGroupHeadingState {\n    #id;\n    #ref;\n    #group;\n    constructor(props, group) {\n        this.#id = props.id;\n        this.#ref = props.ref;\n        this.#group = group;\n        useRefById({\n            id: this.#id,\n            ref: this.#ref,\n            onRefChange: (node) => {\n                this.#group.groupHeadingId = node?.id;\n            },\n        });\n    }\n    props = $derived.by(() => ({\n        id: this.#id.current,\n        role: \"group\",\n        [this.#group.root.getAttr(\"group-heading\")]: \"\",\n    }));\n}\nclass MenuSeparatorState {\n    #id;\n    #ref;\n    #root;\n    constructor(props, root) {\n        this.#id = props.id;\n        this.#ref = props.ref;\n        this.#root = root;\n        useRefById({\n            id: this.#id,\n            ref: this.#ref,\n        });\n    }\n    props = $derived.by(() => ({\n        id: this.#id.current,\n        role: \"group\",\n        [this.#root.getAttr(\"separator\")]: \"\",\n    }));\n}\nclass MenuArrowState {\n    #root;\n    constructor(root) {\n        this.#root = root;\n    }\n    props = $derived.by(() => ({\n        [this.#root.getAttr(\"arrow\")]: \"\",\n    }));\n}\nclass MenuRadioGroupState {\n    #id;\n    value;\n    #ref;\n    content;\n    groupHeadingId = $state(null);\n    root;\n    constructor(props, content) {\n        this.value = props.value;\n        this.#id = props.id;\n        this.#ref = props.ref;\n        this.content = content;\n        this.root = content.parentMenu.root;\n        useRefById({\n            id: this.#id,\n            ref: this.#ref,\n        });\n    }\n    setValue = (v) => {\n        this.value.current = v;\n    };\n    props = $derived.by(() => ({\n        id: this.#id.current,\n        [this.root.getAttr(\"radio-group\")]: \"\",\n        role: \"group\",\n        \"aria-labelledby\": this.groupHeadingId,\n    }));\n}\nclass MenuRadioItemState {\n    #id;\n    #ref;\n    #item;\n    #value;\n    #group;\n    isChecked = $derived.by(() => this.#group.value.current === this.#value.current);\n    constructor(props, item, group) {\n        this.#item = item;\n        this.#id = props.id;\n        this.#ref = props.ref;\n        this.#group = group;\n        this.#value = props.value;\n        useRefById({\n            id: this.#id,\n            ref: this.#ref,\n        });\n    }\n    selectValue = () => {\n        this.#group.setValue(this.#value.current);\n    };\n    props = $derived.by(() => ({\n        [this.#group.root.getAttr(\"radio-item\")]: \"\",\n        ...this.#item.props,\n        role: \"menuitemradio\",\n        \"aria-checked\": getAriaChecked(this.isChecked),\n        \"data-state\": getCheckedState(this.isChecked),\n    }));\n}\nclass DropdownMenuTriggerState {\n    #id;\n    #ref;\n    #parentMenu;\n    #disabled;\n    constructor(props, parentMenu) {\n        this.#ref = props.ref;\n        this.#id = props.id;\n        this.#parentMenu = parentMenu;\n        this.#disabled = props.disabled;\n        useRefById({\n            id: this.#id,\n            ref: this.#ref,\n            onRefChange: (ref) => {\n                this.#parentMenu.triggerNode = ref;\n            },\n        });\n    }\n    #onpointerdown = (e) => {\n        if (this.#disabled.current)\n            return;\n        if (e.pointerType === \"touch\")\n            return e.preventDefault();\n        if (e.button === 0 && e.ctrlKey === false) {\n            this.#parentMenu.toggleOpen();\n            // prevent trigger focusing when opening to allow\n            // the content to be given focus without competition\n            if (!this.#parentMenu.open.current)\n                e.preventDefault();\n        }\n    };\n    #onpointerup = (e) => {\n        if (this.#disabled.current)\n            return;\n        if (e.pointerType === \"touch\") {\n            e.preventDefault();\n            this.#parentMenu.toggleOpen();\n        }\n    };\n    #onkeydown = (e) => {\n        if (this.#disabled.current)\n            return;\n        if (e.key === kbd.SPACE || e.key === kbd.ENTER) {\n            this.#parentMenu.toggleOpen();\n            e.preventDefault();\n            return;\n        }\n        if (e.key === kbd.ARROW_DOWN) {\n            this.#parentMenu.onOpen();\n            e.preventDefault();\n        }\n    };\n    #ariaControls = $derived.by(() => {\n        if (this.#parentMenu.open.current && this.#parentMenu.contentId.current)\n            return this.#parentMenu.contentId.current;\n        return undefined;\n    });\n    props = $derived.by(() => ({\n        id: this.#id.current,\n        disabled: this.#disabled.current,\n        \"aria-haspopup\": \"menu\",\n        \"aria-expanded\": getAriaExpanded(this.#parentMenu.open.current),\n        \"aria-controls\": this.#ariaControls,\n        \"data-disabled\": getDataDisabled(this.#disabled.current),\n        \"data-state\": getDataOpenClosed(this.#parentMenu.open.current),\n        [this.#parentMenu.root.getAttr(\"trigger\")]: \"\",\n        //\n        onpointerdown: this.#onpointerdown,\n        onpointerup: this.#onpointerup,\n        onkeydown: this.#onkeydown,\n    }));\n}\nclass ContextMenuTriggerState {\n    #id;\n    #ref;\n    #parentMenu;\n    #disabled;\n    #point = $state({ x: 0, y: 0 });\n    virtualElement = box({\n        getBoundingClientRect: () => DOMRect.fromRect({ width: 0, height: 0, ...this.#point }),\n    });\n    #longPressTimer = $state(null);\n    constructor(props, parentMenu) {\n        this.#parentMenu = parentMenu;\n        this.#disabled = props.disabled;\n        this.#id = props.id;\n        this.#ref = props.ref;\n        useRefById({\n            id: this.#id,\n            ref: this.#ref,\n            onRefChange: (node) => {\n                this.#parentMenu.triggerNode = node;\n            },\n            deps: () => this.#parentMenu.open.current,\n        });\n        $effect(() => {\n            this.#point;\n            this.virtualElement.current = {\n                getBoundingClientRect: () => DOMRect.fromRect({ width: 0, height: 0, ...this.#point }),\n            };\n        });\n        $effect(() => {\n            if (this.#disabled.current) {\n                this.#clearLongPressTimer();\n            }\n        });\n        $effect(() => {\n            return () => {\n                this.#clearLongPressTimer();\n            };\n        });\n    }\n    #clearLongPressTimer = () => {\n        if (this.#longPressTimer === null)\n            return;\n        window.clearTimeout(this.#longPressTimer);\n    };\n    #handleOpen = (e) => {\n        this.#point = { x: e.clientX, y: e.clientY };\n        this.#parentMenu.onOpen();\n    };\n    #oncontextmenu = (e) => {\n        if (this.#disabled.current)\n            return;\n        this.#clearLongPressTimer();\n        this.#handleOpen(e);\n        e.preventDefault();\n        this.#parentMenu.contentNode?.focus();\n    };\n    #onpointerdown = (e) => {\n        if (this.#disabled.current || isMouseEvent(e))\n            return;\n        this.#clearLongPressTimer();\n        this.#longPressTimer = window.setTimeout(() => this.#handleOpen(e), 700);\n    };\n    #onpointermove = (e) => {\n        if (this.#disabled.current || isMouseEvent(e))\n            return;\n        this.#clearLongPressTimer();\n    };\n    #onpointercancel = (e) => {\n        if (this.#disabled.current || isMouseEvent(e))\n            return;\n        this.#clearLongPressTimer();\n    };\n    #onpointerup = (e) => {\n        if (this.#disabled.current || isMouseEvent(e))\n            return;\n        this.#clearLongPressTimer();\n    };\n    props = $derived.by(() => ({\n        id: this.#id.current,\n        disabled: this.#disabled.current,\n        \"data-disabled\": getDataDisabled(this.#disabled.current),\n        \"data-state\": getDataOpenClosed(this.#parentMenu.open.current),\n        [CONTEXT_MENU_TRIGGER_ATTR]: \"\",\n        //\n        onpointerdown: this.#onpointerdown,\n        onpointermove: this.#onpointermove,\n        onpointercancel: this.#onpointercancel,\n        onpointerup: this.#onpointerup,\n        oncontextmenu: this.#oncontextmenu,\n    }));\n}\n//\n// CONTEXT METHODS\n//\nexport function useMenuRoot(props) {\n    return setMenuRootContext(new MenuRootState(props));\n}\nexport function useMenuMenu(root, props) {\n    const menu = new MenuMenuState(props, root);\n    return setMenuMenuContext(menu);\n}\nexport function useMenuSubmenu(props) {\n    const menu = getMenuMenuContext();\n    return setMenuMenuContext(new MenuMenuState(props, menu.root, menu));\n}\nexport function useMenuSubTrigger(props) {\n    const content = getMenuContentContext();\n    const item = new MenuItemSharedState(props, content);\n    const submenu = getMenuMenuContext();\n    return new MenuSubTriggerState(item, content, submenu);\n}\nexport function useMenuDropdownTrigger(props) {\n    const menu = getMenuMenuContext();\n    return new DropdownMenuTriggerState(props, menu);\n}\nexport function useMenuContextTrigger(props) {\n    const menu = getMenuMenuContext();\n    return new ContextMenuTriggerState(props, menu);\n}\nexport function useMenuContent(props) {\n    const menu = getMenuMenuContext();\n    return setMenuContentContext(new MenuContentState(props, menu));\n}\nexport function useMenuItem(props) {\n    const content = getMenuContentContext();\n    const item = new MenuItemSharedState(props, content);\n    return new MenuItemState(props, item);\n}\nexport function useMenuCheckboxItem(props) {\n    const content = getMenuContentContext();\n    const item = new MenuItemState(props, new MenuItemSharedState(props, content));\n    return new MenuCheckboxItemState(props, item);\n}\nexport function useMenuRadioGroup(props) {\n    const content = getMenuContentContext();\n    const radioGroup = new MenuRadioGroupState(props, content);\n    return setMenuGroupContext(setMenuRadioGroupContext(radioGroup));\n}\nexport function useMenuRadioItem(props) {\n    const radioGroup = getMenuRadioGroupContext();\n    const sharedItem = new MenuItemSharedState(props, radioGroup.content);\n    const item = new MenuItemState(props, sharedItem);\n    return new MenuRadioItemState(props, item, radioGroup);\n}\nexport function useMenuGroup(props) {\n    const root = getMenuRootContext();\n    return setMenuGroupContext(new MenuGroupState(props, root));\n}\nexport function useMenuGroupHeading(props) {\n    const group = getMenuGroupContext();\n    return new MenuGroupHeadingState(props, group);\n}\nexport function useMenuSeparator(props) {\n    const root = getMenuRootContext();\n    return new MenuSeparatorState(props, root);\n}\nexport function useMenuArrow() {\n    const root = getMenuRootContext();\n    return new MenuArrowState(root);\n}\n","<script lang=\"ts\">\n\timport { box, mergeProps } from \"svelte-toolbelt\";\n\timport type { MenuItemProps } from \"../types.js\";\n\timport { useMenuItem } from \"../menu.svelte.js\";\n\timport { useId } from \"../../../internal/use-id.js\";\n\timport { noop } from \"../../../internal/noop.js\";\n\n\tlet {\n\t\tchild,\n\t\tchildren,\n\t\tref = $bindable(null),\n\t\tid = useId(),\n\t\tdisabled = false,\n\t\tonSelect = noop,\n\t\t...restProps\n\t}: MenuItemProps = $props();\n\n\tconst itemState = useMenuItem({\n\t\tid: box.with(() => id),\n\t\tdisabled: box.with(() => disabled),\n\t\tonSelect: box.with(() => onSelect),\n\t\tref: box.with(\n\t\t\t() => ref,\n\t\t\t(v) => (ref = v)\n\t\t),\n\t});\n\n\tconst mergedProps = $derived(mergeProps(restProps, itemState.props));\n</script>\n\n{#if child}\n\t{@render child({ props: mergedProps })}\n{:else}\n\t<div {...mergedProps}>\n\t\t{@render children?.()}\n\t</div>\n{/if}\n","<script lang=\"ts\">\n\timport { box } from \"svelte-toolbelt\";\n\timport { useDialogRoot } from \"../dialog.svelte.js\";\n\timport type { DialogRootProps } from \"../types.js\";\n\timport { noop } from \"../../../internal/noop.js\";\n\n\tlet {\n\t\topen = $bindable(false),\n\t\tonOpenChange = noop,\n\t\tcontrolledOpen = false,\n\t\tchildren,\n\t}: DialogRootProps = $props();\n\n\tuseDialogRoot({\n\t\tvariant: box.with(() => \"dialog\"),\n\t\topen: box.with(\n\t\t\t() => open,\n\t\t\t(v) => {\n\t\t\t\tif (controlledOpen) {\n\t\t\t\t\tonOpenChange(v);\n\t\t\t\t} else {\n\t\t\t\t\topen = v;\n\t\t\t\t\tonOpenChange(v);\n\t\t\t\t}\n\t\t\t}\n\t\t),\n\t});\n</script>\n\n{@render children?.()}\n","<script lang=\"ts\">\n\timport { box, mergeProps } from \"svelte-toolbelt\";\n\timport { useDialogClose } from \"../dialog.svelte.js\";\n\timport type { DialogCloseProps } from \"../types.js\";\n\timport { useId } from \"../../../internal/use-id.js\";\n\n\tlet {\n\t\tchildren,\n\t\tchild,\n\t\tid = useId(),\n\t\tref = $bindable(null),\n\t\tdisabled = false,\n\t\t...restProps\n\t}: DialogCloseProps = $props();\n\n\tconst closeState = useDialogClose({\n\t\tvariant: box.with(() => \"close\"),\n\t\tid: box.with(() => id),\n\t\tref: box.with(\n\t\t\t() => ref,\n\t\t\t(v) => (ref = v)\n\t\t),\n\t\tdisabled: box.with(() => Boolean(disabled)),\n\t});\n\n\tconst mergedProps = $derived(mergeProps(restProps, closeState.props));\n</script>\n\n{#if child}\n\t{@render child({ props: mergedProps })}\n{:else}\n\t<button {...mergedProps}>\n\t\t{@render children?.()}\n\t</button>\n{/if}\n","<script lang=\"ts\">\n\timport { box, mergeProps } from \"svelte-toolbelt\";\n\timport { useDialogContent } from \"../dialog.svelte.js\";\n\timport type { DialogContentProps } from \"../types.js\";\n\timport DismissibleLayer from \"../../utilities/dismissible-layer/dismissible-layer.svelte\";\n\timport EscapeLayer from \"../../utilities/escape-layer/escape-layer.svelte\";\n\timport FocusScope from \"../../utilities/focus-scope/focus-scope.svelte\";\n\timport PresenceLayer from \"../../utilities/presence-layer/presence-layer.svelte\";\n\timport TextSelectionLayer from \"../../utilities/text-selection-layer/text-selection-layer.svelte\";\n\timport { useId } from \"../../../internal/use-id.js\";\n\timport { noop } from \"../../../internal/noop.js\";\n\timport ScrollLock from \"../../utilities/scroll-lock/scroll-lock.svelte\";\n\timport { shouldTrapFocus } from \"../../../internal/should-trap-focus.js\";\n\n\tlet {\n\t\tid = useId(),\n\t\tchildren,\n\t\tchild,\n\t\tref = $bindable(null),\n\t\tforceMount = false,\n\t\tonCloseAutoFocus = noop,\n\t\tonEscapeKeydown = noop,\n\t\tonInteractOutside = noop,\n\t\ttrapFocus = true,\n\t\tpreventScroll = true,\n\t\trestoreScrollDelay = null,\n\t\t...restProps\n\t}: DialogContentProps = $props();\n\n\tconst contentState = useDialogContent({\n\t\tid: box.with(() => id),\n\t\tref: box.with(\n\t\t\t() => ref,\n\t\t\t(v) => (ref = v)\n\t\t),\n\t});\n\n\tconst mergedProps = $derived(mergeProps(restProps, contentState.props));\n</script>\n\n<PresenceLayer {...mergedProps} {forceMount} present={contentState.root.open.current || forceMount}>\n\t{#snippet presence({ present })}\n\t\t<FocusScope\n\t\t\tloop\n\t\t\ttrapFocus={shouldTrapFocus({\n\t\t\t\tforceMount,\n\t\t\t\tpresent: present.current,\n\t\t\t\ttrapFocus,\n\t\t\t\topen: contentState.root.open.current,\n\t\t\t})}\n\t\t\t{...mergedProps}\n\t\t\tonCloseAutoFocus={(e) => {\n\t\t\t\tonCloseAutoFocus(e);\n\t\t\t\tif (e.defaultPrevented) return;\n\t\t\t\tcontentState.root.triggerNode?.focus();\n\t\t\t}}\n\t\t>\n\t\t\t{#snippet focusScope({ props: focusScopeProps })}\n\t\t\t\t<EscapeLayer\n\t\t\t\t\t{...mergedProps}\n\t\t\t\t\tenabled={present.current}\n\t\t\t\t\tonEscapeKeydown={(e) => {\n\t\t\t\t\t\tonEscapeKeydown(e);\n\t\t\t\t\t\tif (e.defaultPrevented) return;\n\t\t\t\t\t\tcontentState.root.handleClose();\n\t\t\t\t\t}}\n\t\t\t\t>\n\t\t\t\t\t<DismissibleLayer\n\t\t\t\t\t\t{...mergedProps}\n\t\t\t\t\t\tenabled={present.current}\n\t\t\t\t\t\tonInteractOutside={(e) => {\n\t\t\t\t\t\t\tonInteractOutside(e);\n\t\t\t\t\t\t\tif (e.defaultPrevented) return;\n\t\t\t\t\t\t\tcontentState.root.handleClose();\n\t\t\t\t\t\t}}\n\t\t\t\t\t>\n\t\t\t\t\t\t<TextSelectionLayer {...mergedProps} enabled={present.current}>\n\t\t\t\t\t\t\t{#if child}\n\t\t\t\t\t\t\t\t{#if contentState.root.open.current}\n\t\t\t\t\t\t\t\t\t<ScrollLock {preventScroll} {restoreScrollDelay} />\n\t\t\t\t\t\t\t\t{/if}\n\t\t\t\t\t\t\t\t{@render child({\n\t\t\t\t\t\t\t\t\tprops: mergeProps(mergedProps, focusScopeProps),\n\t\t\t\t\t\t\t\t\t...contentState.snippetProps,\n\t\t\t\t\t\t\t\t})}\n\t\t\t\t\t\t\t{:else}\n\t\t\t\t\t\t\t\t<ScrollLock {preventScroll} />\n\t\t\t\t\t\t\t\t<div {...mergeProps(mergedProps, focusScopeProps)}>\n\t\t\t\t\t\t\t\t\t{@render children?.()}\n\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t{/if}\n\t\t\t\t\t\t</TextSelectionLayer>\n\t\t\t\t\t</DismissibleLayer>\n\t\t\t\t</EscapeLayer>\n\t\t\t{/snippet}\n\t\t</FocusScope>\n\t{/snippet}\n</PresenceLayer>\n","<script lang=\"ts\">\n\timport { box } from \"svelte-toolbelt\";\n\timport type { MenuRootProps } from \"../types.js\";\n\timport { useMenuMenu, useMenuRoot } from \"../menu.svelte.js\";\n\timport { noop } from \"../../../internal/noop.js\";\n\timport FloatingLayer from \"../../utilities/floating-layer/components/floating-layer.svelte\";\n\n\tlet {\n\t\topen = $bindable(false),\n\t\tdir = \"ltr\",\n\t\tonOpenChange = noop,\n\t\tcontrolledOpen = false,\n\t\t_internal_variant: variant = \"dropdown-menu\",\n\t\tchildren,\n\t}: MenuRootProps & {\n\t\t_internal_variant?: \"context-menu\" | \"dropdown-menu\" | \"menubar\";\n\t} = $props();\n\n\tconst root = useMenuRoot({\n\t\tvariant: box.with(() => variant),\n\t\tdir: box.with(() => dir),\n\t\tonClose: () => {\n\t\t\tif (controlledOpen) {\n\t\t\t\tonOpenChange(false);\n\t\t\t} else {\n\t\t\t\topen = false;\n\t\t\t\tonOpenChange?.(false);\n\t\t\t}\n\t\t},\n\t});\n\n\tuseMenuMenu(root, {\n\t\topen: box.with(\n\t\t\t() => open,\n\t\t\t(v) => {\n\t\t\t\tif (controlledOpen) {\n\t\t\t\t\tonOpenChange(v);\n\t\t\t\t} else {\n\t\t\t\t\topen = v;\n\t\t\t\t\tonOpenChange(v);\n\t\t\t\t}\n\t\t\t}\n\t\t),\n\t});\n</script>\n\n<FloatingLayer>\n\t{@render children?.()}\n</FloatingLayer>\n","<script lang=\"ts\">\n\timport { box, mergeProps } from \"svelte-toolbelt\";\n\timport type { DropdownMenuContentProps } from \"../types.js\";\n\timport { useMenuContent } from \"../../menu/menu.svelte.js\";\n\timport { useId } from \"../../../internal/use-id.js\";\n\timport { noop } from \"../../../internal/noop.js\";\n\timport PopperLayer from \"../../utilities/popper-layer/popper-layer.svelte\";\n\timport Mounted from \"../../utilities/mounted.svelte\";\n\timport { getFloatingContentCSSVars } from \"../../../internal/floating-svelte/floating-utils.svelte.js\";\n\timport PopperLayerForceMount from \"../../utilities/popper-layer/popper-layer-force-mount.svelte\";\n\n\tlet {\n\t\tid = useId(),\n\t\tchild,\n\t\tchildren,\n\t\tref = $bindable(null),\n\t\tloop = true,\n\t\tonInteractOutside = noop,\n\t\tonEscapeKeydown = noop,\n\t\tforceMount = false,\n\t\t...restProps\n\t}: DropdownMenuContentProps = $props();\n\n\tlet isMounted = $state(false);\n\n\tconst contentState = useMenuContent({\n\t\tid: box.with(() => id),\n\t\tloop: box.with(() => loop),\n\t\tref: box.with(\n\t\t\t() => ref,\n\t\t\t(v) => (ref = v)\n\t\t),\n\t\tisMounted: box.with(() => isMounted),\n\t});\n\n\tconst mergedProps = $derived(mergeProps(restProps, contentState.props));\n\n\tfunction handleInteractOutside(e: PointerEvent) {\n\t\tcontentState.handleInteractOutside(e);\n\t\tif (e.defaultPrevented) return;\n\t\tonInteractOutside(e);\n\t\tif (e.defaultPrevented) return;\n\t\tcontentState.parentMenu.onClose();\n\t}\n\tfunction handleEscapeKeydown(e: KeyboardEvent) {\n\t\tonEscapeKeydown(e);\n\t\tif (e.defaultPrevented) return;\n\t\tcontentState.parentMenu.onClose();\n\t}\n</script>\n\n{#if forceMount}\n\t<PopperLayerForceMount\n\t\t{...mergedProps}\n\t\tenabled={contentState.parentMenu.open.current}\n\t\tonInteractOutside={handleInteractOutside}\n\t\tonEscapeKeydown={handleEscapeKeydown}\n\t\ttrapFocus\n\t\t{loop}\n\t\tforceMount={true}\n\t\t{id}\n\t>\n\t\t{#snippet popper({ props })}\n\t\t\t{@const finalProps = mergeProps(props, {\n\t\t\t\tstyle: getFloatingContentCSSVars(\"dropdown-menu\"),\n\t\t\t})}\n\t\t\t{#if child}\n\t\t\t\t{@render child({ props: finalProps, ...contentState.snippetProps })}\n\t\t\t{:else}\n\t\t\t\t<div {...finalProps}>\n\t\t\t\t\t{@render children?.()}\n\t\t\t\t</div>\n\t\t\t{/if}\n\t\t\t<Mounted bind:isMounted />\n\t\t{/snippet}\n\t</PopperLayerForceMount>\n{:else if !forceMount}\n\t<PopperLayer\n\t\t{...mergedProps}\n\t\tpresent={contentState.parentMenu.open.current}\n\t\tonInteractOutside={handleInteractOutside}\n\t\tonEscapeKeydown={handleEscapeKeydown}\n\t\ttrapFocus\n\t\t{loop}\n\t\tforceMount={false}\n\t\t{id}\n\t>\n\t\t{#snippet popper({ props })}\n\t\t\t{@const finalProps = mergeProps(props, {\n\t\t\t\tstyle: getFloatingContentCSSVars(\"dropdown-menu\"),\n\t\t\t})}\n\t\t\t{#if child}\n\t\t\t\t{@render child({ props: finalProps, ...contentState.snippetProps })}\n\t\t\t{:else}\n\t\t\t\t<div {...finalProps}>\n\t\t\t\t\t{@render children?.()}\n\t\t\t\t</div>\n\t\t\t{/if}\n\t\t\t<Mounted bind:isMounted />\n\t\t{/snippet}\n\t</PopperLayer>\n{/if}\n","<script lang=\"ts\">\n\timport { box, mergeProps } from \"svelte-toolbelt\";\n\timport type { MenuTriggerProps } from \"../types.js\";\n\timport { useMenuDropdownTrigger } from \"../menu.svelte.js\";\n\timport { useId } from \"../../../internal/use-id.js\";\n\timport FloatingLayerAnchor from \"../../utilities/floating-layer/components/floating-layer-anchor.svelte\";\n\n\tlet {\n\t\tid = useId(),\n\t\tref = $bindable(null),\n\t\tchild,\n\t\tchildren,\n\t\tdisabled = false,\n\t\t...restProps\n\t}: MenuTriggerProps = $props();\n\n\tconst triggerState = useMenuDropdownTrigger({\n\t\tid: box.with(() => id),\n\t\tdisabled: box.with(() => disabled ?? false),\n\t\tref: box.with(\n\t\t\t() => ref,\n\t\t\t(v) => (ref = v)\n\t\t),\n\t});\n\n\tconst mergedProps = $derived(mergeProps(restProps, triggerState.props));\n</script>\n\n<FloatingLayerAnchor {id}>\n\t{#if child}\n\t\t{@render child({ props: mergedProps })}\n\t{:else}\n\t\t<button {...mergedProps}>\n\t\t\t{@render children?.()}\n\t\t</button>\n\t{/if}\n</FloatingLayerAnchor>\n","<script lang=\"ts\" module>\n    const map = {\n        'chevron-down': 'chevron-down',\n        'comment-lines': 'comment-lines',\n        'close': 'close',\n        'copy-to-clipboard': 'copy-to-clipboard',\n    } as const;\n\n    export type Name = keyof typeof map;\n</script>\n\n<script lang=\"ts\">\n    type Size = 16 | 24;\n\n    type Props = {\n        name: Name,\n        class?: string,\n        size?: Size\n    };\n\n    const { name, class: className = '', size = 16 }: Props = $props();\n</script>\n\n<svg role=\"img\" class=\"gl-icon s{size} {className}\">\n    <use href=\"/assets/icons-1563760c6022424ca5187159258484be0c106b044e5e5a1b4f0be7a10cd6c90f.svg#{map[name]}\"></use>\n</svg>\n","<script lang=\"ts\">\n    import { DropdownMenu } from \"bits-ui\";\n    import type { Snippet } from 'svelte';\n    import Icon from '../Icon.svelte';\n\n    type Props = {\n        children: Snippet,\n        class?: string\n    };\n\n    const { children, class: className = '' }: Props = $props();\n</script>\n\n<div class=\"gl-disclosure-dropdown gl-new-dropdown {className}\">\n    <DropdownMenu.Trigger class=\"btn btn-default btn-md gl-button gl-new-dropdown-toggle\">\n        <span class=\"gl-button-text gl-w-full\">\n            <span class=\"gl-new-dropdown-button-text\">\n                {@render children()}\n            </span>\n            <Icon name=\"chevron-down\" class=\"gl-button-icon gl-new-dropdown-chevron\" />\n        </span>\n    </DropdownMenu.Trigger>\n</div>\n","<script lang=\"ts\">\n    import { DropdownMenu } from 'bits-ui';\n    import type { Snippet } from 'svelte';\n\n    type Props = {\n        children: Snippet\n    };\n\n    const { children }: Props = $props();\n</script>\n\n<DropdownMenu.Content class=\"gl-new-dropdown\" align=\"start\" sideOffset={4}>\n    <div class=\"gl-new-dropdown-panel gl-display-block!\">\n        <div class=\"gl-new-dropdown-inner\">\n            <div class=\"gl-new-dropdown-contents\">\n                {@render children()}\n            </div>\n        </div>\n    </div>\n</DropdownMenu.Content>\n","import { DropdownMenu } from 'bits-ui';\nimport Trigger from './Trigger.svelte';\nimport Content from './Content.svelte';\nimport Item from './Item.svelte';\n\nexport const Dropdown = {\n\tRoot: DropdownMenu.Root,\n\tTrigger,\n\tContent,\n\tItem,\n};\n","<script lang=\"ts\">\n    type Props = {\n        class?: string,\n        style?: string,\n    };\n\n    const { class: className = '', style }: Props = $props();\n</script>\n\n<img src=\"/uploads/-/system/project/avatar/10/256x256.png\" alt=\"Daktela logo\" class={className} {style} />\n","<script lang=\"ts\">\n    import { Dropdown } from '@gitlab/ui/dropdown';\n    import DaktelaIcon from '@gitlab/ui/DaktelaIcon.svelte';\n    import Icon from '@gitlab/ui/Icon.svelte';\n    import type { Feature } from './types';\n\n    type Props = {\n        features: Feature[],\n        class?: string,\n    };\n\n    const { features, class: className = '' }: Props = $props();\n</script>\n\n<Dropdown.Root>\n    <Dropdown.Trigger class={className}>\n        <DaktelaIcon class=\"gl-icon s14\" style=\"scale: 1.5\" />\n    </Dropdown.Trigger>\n\n    <Dropdown.Content>\n        {#each features as feature (feature.title)}\n            <Dropdown.Item onclick={feature.onClick}>\n                <Icon name={feature.icon} class=\"gl-mr-2\" />\n                {feature.title}\n            </Dropdown.Item>\n        {/each}\n    </Dropdown.Content>\n</Dropdown.Root>\n","import type { ProjectRef, SHA } from '@gitlab/types';\n\nexport const Current = {\n\tprojects: {\n\t\tref(): ProjectRef {\n\t\t\tconst matches = location.pathname.match(/^\\/?(.*?)(?:\\/-\\/|$)/);\n\n\t\t\tif (!matches) {\n\t\t\t\tthrow Error(`Could not parse project ref: ${location.pathname}`);\n\t\t\t}\n\n\t\t\treturn matches[1];\n\t\t},\n\t},\n\tcommits: {\n\t\tsha(): SHA {\n\t\t\tconst matches = location.pathname.match(/\\/-\\/commit\\/(\\w+)/);\n\n\t\t\tif (!matches) {\n\t\t\t\tthrow Error(`Could not parse commit SHA: ${location.pathname}`);\n\t\t\t}\n\n\t\t\treturn matches[1];\n\t\t},\n\t},\n} as const;\n","<script lang=\"ts\">\n    import { Dialog } from 'bits-ui';\n    import type { Snippet } from 'svelte';\n\n    const sizeMap = {\n        'sm': 'sm',\n        'md': 'md',\n    } as const;\n\n    type Size = keyof typeof sizeMap;\n\n    type Props = {\n        size?: Size,\n        children: Snippet,\n    };\n\n    const { size = 'md', children }: Props = $props();\n</script>\n\n<Dialog.Content>\n    <div class=\"modal fade show gl-modal\" style=\"display: block;\">\n        <div class=\"modal-dialog modal-{size}\">\n            <div class=\"modal-content\">\n                {@render children()}\n            </div>\n        </div>\n    </div>\n</Dialog.Content>\n","import { Dialog } from 'bits-ui';\nimport Overlay from './Overlay.svelte';\nimport Content from './Content.svelte';\nimport Header from './Header.svelte';\nimport Title from './Title.svelte';\nimport Close from './Close.svelte';\nimport CloseIcon from './CloseIcon.svelte';\nimport Body from './Body.svelte';\nimport Footer from './Footer.svelte';\n\nexport const Modal = {\n\tRoot: Dialog.Root,\n\tPortal: Dialog.Portal,\n\tOverlay,\n\tContent,\n\tHeader,\n\tTitle,\n\tClose,\n\tCloseIcon,\n\tBody,\n\tFooter,\n};\n","import type { Comment, CommitWithBranch } from './types';\nimport type { Branch, Commit } from '@gitlab/types';\n\n// noinspection SpellCheckingInspection\nconst BODY_FONTS = [\n\t'Menlo',\n\t'\\'DejaVu Sans Mono\\'',\n\t'\\'Liberation Mono\\'',\n\t'Consolas',\n\t'\\'Ubuntu Mono\\'',\n\t'\\'Courier New\\'',\n\t'\\'andale mono\\'',\n\t'\\'lucida console\\'',\n\t'monospace'\n].join(', ');\n\nconst BODY_STYLES = [\n\t`font-family:${BODY_FONTS}`,\n\t'font-size:0.8125rem',\n\t'margin-top:8px',\n\t'margin-bottom:8px',\n\t'color:#999999',\n\t'padding:8px 0 8px 8px',\n\t'border-width:0 0 0 3px',\n\t'border-style:none none none solid',\n\t'border-color:#444444',\n].join(';');\n\nexport function render(comment: Comment): string {\n\treturn (\n\t\trenderTitle(comment)\n\t\t+ renderCommits(comment)\n\t\t+ renderMergeRequests(comment)\n\t\t+ renderExtra(comment)\n\t\t+ renderBody(comment)\n\t);\n}\n\nfunction renderTitle(comment: Comment): string {\n\treturn `<p><strong>${comment.title}</strong></p>`;\n}\n\nfunction renderCommits(comment: Comment): string {\n\treturn renderListWithTitle('Commits', renderCBs([comment as CommitWithBranch<Branch>].concat(comment.cherryPicks)));\n}\n\nfunction renderCBs(cbs: CommitWithBranch<Branch>[]): string[] {\n\treturn cbs.map(cb => `${renderBranch(cb.branch)} ${renderCommit(cb.commit)}`);\n}\n\nfunction renderBranch(branch: Branch): string {\n\treturn renderAnchor(branch.name, branch.web_url);\n}\n\nfunction renderCommit(commit: Commit): string {\n\treturn renderAnchor(commit.web_url, commit.web_url);\n}\n\nfunction renderMergeRequests(comment: Comment): string {\n\treturn renderListWithTitle('Merge requests', comment.mergeRequests.map(mr => linkify(mr.web_url)));\n}\n\nfunction renderExtra(comment: Comment): string {\n\treturn Object.entries(comment.extra)\n\t\t.reduce((html, [name, values]) => {\n\t\t\treturn html + renderListWithTitle(name, linkifyAll(values), true);\n\t\t}, '');\n}\n\nfunction renderBody(comment: Comment): string {\n\tif (comment.body === '') {\n\t\treturn '';\n\t}\n\n\treturn (\n\t\t`<p>Notes (copied from commit message):</p>`\n\t\t+ `<pre style=\"${BODY_STYLES}\">${comment.body}</pre>`\n\t);\n}\n\nfunction renderListWithTitle(title: string, items: string[], allowCollapse: boolean = false): string {\n\tif (!items.length) {\n\t\treturn '';\n\t}\n\n\tif (items.length === 1 && allowCollapse) {\n\t\treturn `<p>${title}: ${items[0]}</p>`;\n\t}\n\n\treturn (\n\t\t`<p>${title}:</p>`\n\t\t+ renderList(items)\n\t);\n}\n\nfunction renderList(items: string[]): string {\n\treturn `<ul>${items.map(item => `<li>${item}</li>`).join('')}</ul>`;\n}\n\nfunction renderAnchor(title: string, url: string): string {\n\treturn `<a href=\"${url}\" target=\"_blank\" rel=\"noreferrer noopener\">${title}</a>`;\n}\n\nfunction linkifyAll(values: string[]): string[] {\n\treturn values.map(linkify);\n}\n\nfunction linkify(value: string): string {\n\ttry {\n\t\treturn renderAnchor(value, new URL(value).toString());\n\t} catch {\n\t\treturn value;\n\t}\n}\n","<script lang=\"ts\">\n    import type { Comment } from '../../../types';\n    import { render as renderComment } from '../../../render';\n    import Icon from '@gitlab/ui/Icon.svelte';\n\n    type Props = {\n        comment: Comment,\n    };\n\n    const { comment }: Props = $props();\n    const rendered = $derived.by(() => renderComment(comment));\n\n    async function copy(): Promise<void> {\n        try {\n            await navigator.clipboard.writeText(rendered);\n        } catch (error) {\n            console.error(error);\n        }\n    }\n</script>\n\n<div class=\"gl-display-flex gl-justify-content-space-between gl-mb-2\">\n    <div>\n        {#if comment.ticket}\n            <span>\n                Ticket:\n                <a href={comment.ticket} target=\"_blank\" rel=\"noreferrer noopener\">{comment.ticket}</a>\n            </span>\n        {/if}\n    </div>\n    <button onclick={copy} title=\"Copy message\" class=\"btn input-group-text btn-default btn-md gl-button btn-default-secondary btn-icon\">\n        <Icon name=\"copy-to-clipboard\" class=\"gl-button-icon\" />\n    </button>\n</div>\n\n<textarea readonly class=\"gl-form-input gl-form-textarea form-control\">{rendered}</textarea>\n","import type { Branch, Comment, Commit, Ref, RefType, MergeRequest, ProjectRef, SHA } from './types';\n\nconst BASE_URL = '/api/v4';\n\nexport const GitLab = {\n\tcommits: {\n\t\tasync findBySHA(project: ProjectRef, sha: SHA): Promise<Commit> {\n\t\t\treturn get(`projects/${e(project)}/repository/commits/${sha}`);\n\t\t},\n\t\tasync refs(project: ProjectRef, sha: SHA, type: RefType|'all' = 'all'): Promise<Ref[]> {\n\t\t\treturn get(`projects/${e(project)}/repository/commits/${sha}/refs`, {type});\n\t\t},\n\t\tasync comments(project: ProjectRef, sha: SHA): Promise<Comment[]> {\n\t\t\treturn get(`projects/${e(project)}/repository/commits/${sha}/comments`);\n\t\t},\n\t\tasync mergeRequests(project: ProjectRef, sha: SHA): Promise<MergeRequest[]> {\n\t\t\treturn get(`projects/${e(project)}/repository/commits/${sha}/merge_requests`);\n\t\t},\n\t},\n\tbranches: {\n\t\tasync findByName(project: ProjectRef, name: string): Promise<Branch> {\n\t\t\treturn get(`projects/${e(project)}/repository/branches/${e(name)}`);\n\t\t},\n\t},\n} as const;\n\nfunction e(value: string|number|boolean): string {\n\treturn encodeURIComponent(value);\n}\n\nasync function get<TResponse>(endpoint: string, query: Record<string, string> = {}): Promise<TResponse> {\n\tconst url = new URL(`${BASE_URL}/${endpoint}`, location.origin);\n\tObject.entries(query)\n\t\t.forEach(([name, value]) => url.searchParams.append(name, value));\n\n\tconst response = await fetch(url);\n\n\treturn await response.json();\n}\n","import type { Branch, Comment, ProjectRef, Ref, SHA } from '@gitlab/types';\nimport { GitLab } from '@gitlab/gitlab';\nimport type { CommitWithBranch } from './types';\n\nexport const CherryPicks = {\n\tasync findRefs(project: ProjectRef, sha: SHA): Promise<CommitWithBranch<Ref[]>[]> {\n\t\tconst SHAs = await findSHAsForCommit(project, sha);\n\n\t\treturn Promise.all(\n\t\t\tSHAs.map(cherryPickSHA => this.findRef(project, cherryPickSHA))\n\t\t);\n\t},\n\tasync findRef(project: ProjectRef, sha: SHA): Promise<CommitWithBranch<Ref[]>> {\n\t\tconst [commit, branches] = await Promise.all([\n\t\t\tGitLab.commits.findBySHA(project, sha),\n\t\t\tGitLab.commits.refs(project, sha, 'branch'),\n\t\t]);\n\n\t\treturn {commit, branches};\n\t},\n\tasync deRefAll(project: ProjectRef, cherryPicks: CommitWithBranch<Ref>[]): Promise<CommitWithBranch<Branch>[]> {\n\t\treturn await Promise.all(\n\t\t\tcherryPicks.map(cherryPick => this.deRef(project, cherryPick))\n\t\t);\n\t},\n\tasync deRef(project: ProjectRef, cherryPick: CommitWithBranch<Ref>): Promise<CommitWithBranch<Branch>> {\n\t\tconst branch = await GitLab.branches.findByName(project, cherryPick.branch.name);\n\t\treturn {commit: cherryPick.commit, branch};\n\t},\n} as const;\n\nasync function findSHAsForCommit(project: ProjectRef, sha: SHA): Promise<SHA[]> {\n\tconst comments = await GitLab.commits.comments(project, sha);\n\treturn parseSHAsFromComments(comments);\n}\n\nfunction parseSHAsFromComments(comments: Comment[]): SHA[] {\n\treturn comments.reduce((SHAs, comment) => {\n\t\tconst matches = comment.note.match(/mentioned\\s+in\\s+commit\\s+(\\w+)/i);\n\n\t\tif (matches !== null) {\n\t\t\tSHAs.push(matches[1]);\n\t\t}\n\n\t\treturn SHAs;\n\t}, [] as SHA[]);\n}\n","import type { Message } from './types';\nimport type { Commit } from '@gitlab/types';\n\nexport const Parse = {\n\tmessage(commit: Commit): Message {\n\t\tconst message: Message = {title: '', body: '', ticket: undefined, extra: {}};\n\t\tconst lines = commit.message.split('\\n')\n\t\t\t.map(line => line.trim());\n\n\t\tskipEmptyLines(lines);\n\t\tmessage.title = parseTitle(lines);\n\t\tskipEmptyLines(lines);\n\n\t\twhile (lines.length) {\n\t\t\tprocessNextLine(message, lines);\n\t\t}\n\n\t\tmessage.body = message.body.trim();\n\n\t\treturn message;\n\t},\n} as const;\n\nfunction parseTitle(lines: string[]): string {\n\tconst title = lines.shift();\n\n\tif (title === undefined) {\n\t\tthrow Error('Could not parse commit title');\n\t}\n\n\treturn title.replace(/\\s*#\\s*\\d+\\s*$/, '');\n}\n\nfunction processNextLine(message: Message, lines: string[]): boolean {\n\treturn (\n\t\tskipCherryPicks(lines)\n\t\t|| collapseEmptyLines(message, lines)\n\t\t|| parseTicket(message, lines)\n\t\t|| parseExtra(message, lines)\n\t\t|| parseBody(message, lines)\n\t);\n}\n\nfunction skipEmptyLines(lines: string[]): boolean {\n\treturn skipWithPattern(lines, /^\\s*$/);\n}\n\nfunction skipCherryPicks(lines: string[]): boolean {\n\treturn skipWithPattern(lines, /\\(.*cherry.*picked.*\\)/i);\n}\n\nfunction skipWithPattern(lines: string[], pattern: RegExp): boolean {\n\tlet didSkip = false;\n\n\twhile (lines.length && lines[0].match(pattern)) {\n\t\tlines.shift();\n\t\tdidSkip = true;\n\t}\n\n\treturn didSkip;\n}\n\nfunction collapseEmptyLines(message: Message, lines: string[]): boolean {\n\tlet didCollapse = false;\n\n\tif (lines.length && lines[0].match(/^\\s*$/)) {\n\t\tmessage.body += '\\n';\n\t\tdidCollapse = true;\n\n\t\tskipEmptyLines(lines);\n\t}\n\n\treturn didCollapse;\n}\n\nfunction parseTicket(message: Message, lines: string[]): boolean {\n\tif (lines.length) {\n\t\tconst match = lines[0].match(/ticket\\s*:\\s*(http.*)/i);\n\n\t\tif (!match) {\n\t\t\treturn false;\n\t\t}\n\n\t\tmessage.ticket = match[1].trim();\n\t\tlines.shift();\n\t}\n\n\treturn true;\n}\n\nfunction parseExtra(message: Message, lines: string[]) {\n\tif (lines.length) {\n\t\tconst match = lines[0].match(/^([^:]+):\\s*(http.*)/i);\n\n\t\tif (!match) {\n\t\t\treturn false;\n\t\t}\n\n\t\tconst key = match[1].trim();\n\t\tconst value = match[2].trim();\n\n\t\tmessage.extra[key] = message.extra[key] ?? [];\n\t\tmessage.extra[key].push(value);\n\n\t\tlines.shift();\n\t}\n\n\treturn true;\n}\n\nfunction parseBody(message: Message, lines: string[]): boolean {\n\tconst nextLine = lines.shift();\n\n\tif (nextLine !== undefined) {\n\t\tmessage.body += `${nextLine}\\n`\n\t}\n\n\treturn nextLine !== undefined;\n}\n","import type { ProjectRef, Ref, SHA } from '@gitlab/types';\nimport { GitLab } from '@gitlab/gitlab';\nimport { CherryPicks } from './cherry-picks';\nimport type { Base, Comment } from './types';\nimport { Parse } from './parse';\n\nexport const Comments = {\n\tasync assembleBase(project: ProjectRef, sha: SHA): Promise<Base<Ref[]>> {\n\t\tconst commit = await GitLab.commits.findBySHA(project, sha);\n\n\t\tconst [\n\t\t\tbranches,\n\t\t\tcherryPicks,\n\t\t\tmergeRequests,\n\t\t] = await Promise.all([\n\t\t\tGitLab.commits.refs(project, commit.id, 'all'),\n\t\t\tCherryPicks.findRefs(project, commit.id),\n\t\t\tGitLab.commits.mergeRequests(project, commit.id),\n\t\t]);\n\n\t\treturn {commit, branches, cherryPicks, mergeRequests};\n\t},\n\tasync assembleComment(project: ProjectRef, base: Base<Ref>): Promise<Comment> {\n\t\tconst [branch, cherryPicks] = await Promise.all([\n\t\t\tGitLab.branches.findByName(project, base.branch.name),\n\t\t\tCherryPicks.deRefAll(project, base.cherryPicks),\n\t\t]);\n\t\tconst message = Parse.message(base.commit);\n\n\t\treturn {\n\t\t\tcommit: base.commit,\n\t\t\tbranch,\n\t\t\tcherryPicks,\n\t\t\tmergeRequests: base.mergeRequests,\n\t\t\ttitle: message.title,\n\t\t\tbody: message.body,\n\t\t\tticket: message.ticket,\n\t\t\textra: message.extra,\n\t\t};\n\t},\n\ttryAutoResolveBase(base: Base<Ref[]>): Base<Ref>|null {\n\t\tif (\n\t\t\tbase.branches.length > 1\n\t\t\t|| base.cherryPicks.some(cherryPick => cherryPick.branches.length > 1)\n\t\t) {\n\t\t\treturn null;\n\t\t}\n\n\t\treturn this.resolveBaseUsingFirst(base);\n\t},\n\tresolveBaseUsingFirst(base: Base<Ref[]>): Base<Ref> {\n\t\treturn {\n\t\t\tcommit: base.commit,\n\t\t\tbranch: base.branches[0],\n\t\t\tcherryPicks: base.cherryPicks.map(cherryPick => ({\n\t\t\t\tcommit: cherryPick.commit,\n\t\t\t\tbranch: cherryPick.branches[0],\n\t\t\t})),\n\t\t\tmergeRequests: base.mergeRequests,\n\t\t};\n\t},\n} as const;\n","<script lang=\"ts\" module>\n    import type { ProjectRef, SHA } from '@gitlab/types';\n\n    export type Args = {\n        projectRef: ProjectRef,\n        sha: SHA,\n    };\n</script>\n\n<script lang=\"ts\">\n    import { Modal } from '@gitlab/ui/modal';\n    import Loading from './Steps/Loading.svelte';\n    import Result from './Steps/Result.svelte';\n    import { Comments } from '../../comments';\n    import type { Comment } from '../../types';\n\n    type Props = {\n        args?: Args,\n    };\n\n    type Step = (\n        | { type: 'closed' }\n        | { type: 'loading', project: ProjectRef, commit: SHA }\n        | { type: 'result', comment: Comment }\n    );\n\n    let { args = $bindable() }: Props = $props();\n    let step: Step = $state({ type: 'closed' });\n\n    async function start(project: ProjectRef, commit: SHA): Promise<void> {\n        setLoadingState(project, commit);\n\n        const base = await Comments.assembleBase(project, commit);\n        // const autoResolvedBase = Comments.tryAutoResolveBase(base);\n        const autoResolvedBase = Comments.resolveBaseUsingFirst(base);\n\n        if (autoResolvedBase !== null) {\n            const comment = await Comments.assembleComment(project, autoResolvedBase);\n            setResultState(comment);\n        } else {\n            // TODO: Implement modal\n            console.error('Comment could not be auto-resolved');\n        }\n    }\n\n    function setLoadingState(project: ProjectRef, commit: SHA): void {\n        step = { type: 'loading', project, commit };\n    }\n\n    function setResultState(comment: Comment): void {\n        step = { type: 'result', comment };\n    }\n\n    $effect(() => {\n        if (args !== undefined) {\n            start(args.projectRef, args.sha);\n        }\n    });\n\n    function onOpenChange(newIsOpen: boolean): void {\n        if (!newIsOpen) {\n            closeModal();\n        }\n    }\n\n    function closeModal(): void {\n        step = { type: 'closed' };\n        args = undefined;\n    }\n</script>\n\n<Modal.Root open={step.type !== 'closed'} onOpenChange={onOpenChange}>\n    <Modal.Portal>\n        <Modal.Overlay />\n\n        <Modal.Content size=\"sm\">\n            <Modal.Header>\n                <Modal.Title>Generate ticket comment</Modal.Title>\n                <Modal.CloseIcon />\n            </Modal.Header>\n            <Modal.Body>\n                {#if step.type === 'loading'}\n                    <Loading />\n                {:else if step.type === 'result'}\n                    <Result comment={step.comment} />\n                {/if}\n            </Modal.Body>\n            <Modal.Footer>\n                <Modal.Close />\n            </Modal.Footer>\n        </Modal.Content>\n    </Modal.Portal>\n</Modal.Root>\n","<script lang=\"ts\">\n    import GenerateTicketCommentModal from './generate-ticket-comment/GenerateTicketCommentModal.svelte';\n    import type { Controls } from './types';\n\n    type Props = {\n        controls: Controls,\n    };\n\n    let { controls }: Props = $props();\n</script>\n\n<GenerateTicketCommentModal bind:args={controls.generateTicketCommentModal.args} />\n","import type { Args } from './GenerateTicketCommentModal.svelte';\n\nexport type GenerateTicketCommentModalControls = {\n\treadonly args: Args | undefined,\n\topen: (args: Args) => void,\n\tclose: () => void,\n};\n\nexport function makeControls(): GenerateTicketCommentModalControls {\n\tlet state: Args | undefined = $state(undefined);\n\n\tfunction open(args: Args): void {\n\t\tstate = args;\n\t}\n\n\tfunction close(): void {\n\t\tstate = undefined;\n\t}\n\n\treturn {\n\t\tget args() { return state },\n\t\topen,\n\t\tclose,\n\t};\n}\n","import FeatureDropdown from './FeatureDropdown.svelte';\nimport { mount } from 'svelte';\nimport { Current } from '../current';\nimport Modals from './Modals.svelte';\nimport { makeControls as makeGenerateTicketCommentModalControls } from './generate-ticket-comment/controls.svelte';\nimport type { Controls } from './types';\n\nexport function inject(): void {\n\tconst controls = makeControls();\n\n\tinjectOnCommitDetailPage(controls);\n\tinjectToProjectLastCommit(controls);\n\tinjectModals(controls);\n}\n\nfunction makeControls(): Controls {\n\treturn {\n\t\tgenerateTicketCommentModal: makeGenerateTicketCommentModalControls(),\n\t};\n}\n\nfunction injectOnCommitDetailPage(controls: Controls): void {\n\ttry {\n\t\tconst header = document.querySelector('.page-content-header');\n\n\t\tif (!header) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst projectRef = Current.projects.ref();\n\t\tconst sha = Current.commits.sha();\n\n\t\tmount(FeatureDropdown, {\n\t\t\ttarget: header,\n\t\t\tprops: {\n\t\t\t\tclass: 'gl-ml-3',\n\t\t\t\tfeatures: [\n\t\t\t\t\t{\n\t\t\t\t\t\ticon: 'comment-lines',\n\t\t\t\t\t\ttitle: 'Generate ticket comment',\n\t\t\t\t\t\tonClick(): void {\n\t\t\t\t\t\t\tcontrols.generateTicketCommentModal.open({ projectRef, sha });\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t},\n\t\t});\n\t} catch (error) {\n\t\tconsole.error(error);\n\t}\n}\n\nfunction injectToProjectLastCommit(controls: Controls): void {\n\ttry {\n\t\tconst group = document.querySelector([\n\t\t\t'.project-last-commit .js-commit-sha-group',\n\t\t\t'.blob-commit-info .commit-sha-group',\n\t\t].join(', '));\n\n\t\tif (!group) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst shaElement = group.querySelector('[data-clipboard-text]');\n\n\t\tif (!shaElement || !(shaElement instanceof HTMLElement)) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst projectRef = Current.projects.ref();\n\t\tconst sha = shaElement.dataset.clipboardText ?? '';\n\n\t\tmount(FeatureDropdown, {\n\t\t\ttarget: group,\n\t\t\tprops: {\n\t\t\t\tfeatures: [\n\t\t\t\t\t{\n\t\t\t\t\t\ticon: 'comment-lines',\n\t\t\t\t\t\ttitle: 'Generate ticket comment',\n\t\t\t\t\t\tonClick(): void {\n\t\t\t\t\t\t\tcontrols.generateTicketCommentModal.open({ projectRef, sha });\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t},\n\t\t});\n\t} catch (error) {\n\t\tconsole.error(error);\n\t}\n}\n\nfunction injectModals(controls: Controls): void {\n\tconst modalsContainer = document.createElement('div');\n\tmodalsContainer.id = 'daktela-modals';\n\n\tdocument.body.appendChild(modalsContainer);\n\n\tmount(Modals, {\n\t\ttarget: modalsContainer,\n\t\tprops: {\n\t\t\tcontrols,\n\t\t},\n\t});\n}\n","import './styles.css';\nimport { inject } from './features/inject';\n\ninject();\n"],"names":["PUBLIC_VERSION","EACH_ITEM_REACTIVE","EACH_INDEX_REACTIVE","EACH_ITEM_IMMUTABLE","PROPS_IS_IMMUTABLE","PROPS_IS_RUNES","PROPS_IS_UPDATED","PROPS_IS_BINDABLE","PROPS_IS_LAZY_INITIAL","TEMPLATE_FRAGMENT","TEMPLATE_USE_IMPORT_NODE","UNINITIALIZED","DEV","is_array","array_from","define_property","get_descriptor","get_descriptors","object_prototype","array_prototype","get_prototype_of","is_function","thing","noop","run_all","arr","i","DERIVED","EFFECT","RENDER_EFFECT","BLOCK_EFFECT","BRANCH_EFFECT","ROOT_EFFECT","UNOWNED","DISCONNECTED","CLEAN","DIRTY","MAYBE_DIRTY","INERT","DESTROYED","EFFECT_RAN","EFFECT_TRANSPARENT","LEGACY_DERIVED_PROP","HEAD_EFFECT","EFFECT_HAS_DERIVED","STATE_SYMBOL","LOADING_ATTR_SYMBOL","equals","value","safe_not_equal","a","b","safe_equals","effect_in_teardown","rune","effect_in_unowned_derived","effect_orphan","effect_update_depth_exceeded","props_invalid_value","key","state_descriptors_fixed","state_prototype_fixed","state_unsafe_local_read","state_unsafe_mutation","source","v","state","push_derived_source","mutable_source","initial_value","immutable","_a","s","component_context","active_reaction","derived_sources","set_derived_sources","set","is_runes","e.state_unsafe_mutation","internal_set","increment_version","mark_reactions","active_effect","new_deps","set_signal_status","schedule_effect","untracked_writes","set_untracked_writes","signal","status","reactions","runes","length","reaction","flags","derived","fn","derived_safe_equal","destroy_derived_children","children","child","destroy_derived","destroy_effect","execute_derived","prev_active_effect","set_active_effect","update_reaction","update_derived","skip_reaction","remove_reactions","validate_effect","e.effect_orphan","e.effect_in_unowned_derived","is_destroying_effect","e.effect_in_teardown","push_effect","effect","parent_effect","parent_last","create_effect","type","sync","push","is_root","previously_flushing_effect","is_flushing_effect","set_is_flushing_effect","update_effect","e","inert","effect_tracking","user_effect","defer","context","user_pre_effect","render_effect","effect_root","template_effect","block","branch","execute_effect_teardown","teardown","previously_destroying_effect","previous_reaction","set_is_destroying_effect","set_active_reaction","destroy_effect_deriveds","deriveds","destroy_effect_children","remove_dom","next","destroy_block_effect_children","removed","node","end","get_next_sibling","transitions","transition","parent","unlink_effect","prev","pause_effect","callback","pause_children","run_out_transitions","remaining","check","local","sibling","transparent","resume_effect","resume_children","check_dirtiness","is_micro_task_queued","current_queued_micro_tasks","process_micro_tasks","tasks","queue_micro_task","flush_tasks","lifecycle_outside_component","name","FLUSH_MICROTASK","FLUSH_SYNC","scheduler_mode","queued_root_effects","flush_count","sources","skipped_deps","current_version","_b","dependencies","is_unowned","dependency","handle_error","error","previous_deps","previous_skipped_deps","previous_untracked_writes","previous_skip_reaction","prev_derived_sources","previous_component_context","result","deps","remove_reaction","index","new_length","start_index","previous_effect","infinite_loop_guard","e.effect_update_depth_exceeded","flush_queued_root_effects","root_effects","collected_effects","process_effects","flush_queued_effects","effects","process_deferred","previous_queued_root_effects","current_effect","main_loop","is_branch","is_skippable_branch","parent_sibling","flush_sync","previous_scheduler_mode","tick","get","is_derived","e.state_unsafe_local_read","untrack","STATUS_MASK","getContext","get_or_init_context_map","setContext","hasContext","getAllContexts","get_parent_context","context_map","props","pop","component","context_stack_item","component_effects","component_effect","proxy","prototype","is_proxied_array","version","metadata","_","prop","descriptor","e.state_descriptors_fixed","target","ls","n","update_version","receiver","exists","has","other_s","own_keys","e.state_prototype_fixed","d","$window","first_child_getter","next_sibling_getter","init_operations","element_prototype","node_prototype","create_text","get_first_child","is_text","first_child","fragment","first","count","next_sibling","clear_text_content","hydrating","all_registered_events","root_event_handles","create_event","event_name","dom","handler","options","target_handler","event","handle_event_propagation","delegate","events","handler_element","owner_document","path","current_target","path_idx","handled_at","at_idx","handler_idx","throw_error","other_errors","parent_element","delegated","data","create_fragment_from_html","html","elem","assign_nodes","start","template","content","is_fragment","use_import_node","has_start","clone","ns_template","ns","wrapped","root","text","comment","frag","anchor","append","is_capture_event","DELEGATED_EVENTS","is_delegated","ATTRIBUTE_ALIASES","normalize_attribute","PASSIVE_EVENTS","is_passive_event","set_text","str","mount","_mount","document_listeners","Component","intro","registered_events","event_handle","passive","unmount","anchor_node","ctx","mounted_components","if_block","get_condition","consequent_fn","alternate_fn","elseif","consequent_effect","alternate_effect","condition","key_block","get_key","render_fn","current_each_item","pause_effects","items","controlled_anchor","items_map","is_controlled","parent_node","link","item","each","get_collection","fallback_fn","fallback","was_empty","collection","array","reconcile","is_inert","current","seen","matched","stashed","child_anchor","create_item","update_item","j","move","to_destroy","destroy_length","previous_each_item","reactive","mutable","dest","next_node","snippet","get_snippet","args","snippet_effect","get_component","autofocus","body","set_value","element","attributes","set_attribute","attribute","skip_warning","get_setters","set_attributes","css_hash","preserve_attribute_case","is_custom_element","is_option_element","setters","prev_value","prefix","opts","event_handle_key","handle","evt","setters_cache","descriptors","proto","element_proto","set_svg_class","prev_class_name","next_class_name","to_class","set_class","onMount","init_update_callbacks","cleanup","l","is_store_binding","capture_store_binding","previous_is_store_binding","rest_props_handler","rest_props","exclude","spread_props_handler","p","desc","keys","spread_props","with_parent_branch","bindable","lazy","is_store_sub","prop_value","setter","fallback_value","fallback_dirty","fallback_used","get_fallback","e.props_invalid_value","getter","derived_getter","legacy_parent","mutation","from_child","was_from_child","inner_current_value","current_value","parent_value","child_value","new_value","isFunction","isObject","BoxSymbol","isWritableSymbol","isBox","isWritableBox","box","initialValue","$.set","boxWith","boxFrom","boxFlatten","boxes","acc","toReadonlyBox","composeHandlers","handlers","COMMENT_REGEX","NEWLINE_REGEX","WHITESPACE_REGEX","PROPERTY_REGEX","COLON_REGEX","VALUE_REGEX","SEMICOLON_REGEX","TRIM_REGEX","NEWLINE","FORWARD_SLASH","ASTERISK","EMPTY_STRING","TYPE_COMMENT","TYPE_DECLARATION","inlineStyleParser","style","lineno","column","updatePosition","lines","position","Position","whitespace","msg","err","match","re","m","comments","rules","c","pos","declaration","val","ret","trim","declarations","decls","decl","__importDefault","this","mod","cjs","_default","StyleToObject","inline_style_parser_1","require$$0","iterator","styleObject","hasIterator","property","parse","NUMBER_CHAR_RE","STR_SPLITTERS","isUppercase","char","splitByCase","parts","buff","previousUpper","previousSplitter","isSplitter","isUpper","lastChar","pascalCase","upperFirst","camelCase","lowerFirst","cssToStyleObj","css","styleObj","executeCallbacks","callbacks","r","f","o","clsx","createParser","matcher","replacer","regex","camelToKebab","styleToCSS","styleToString","srOnlyStyles","isEventHandler","mergeProps","aIsFunction","bIsFunction","aHandler","bHandler","aIsObject","bIsObject","aIsString","bIsString","parsedStyle","parsedStyleA","parsedStyleB","useRefById","id","ref","onRefChange","getRootNode","rootNode","$.user_effect","onDestroyEffect","afterSleep","ms","cb","afterTick","getDataOpenClosed","getAriaDisabled","getAriaExpanded","getDataDisabled","ARROW_DOWN","ARROW_LEFT","ARROW_RIGHT","ARROW_UP","END","ENTER","ESCAPE","HOME","PAGE_DOWN","PAGE_UP","SPACE","TAB","getElemDirection","getNextKey","dir","orientation","kbd.ARROW_LEFT","kbd.ARROW_RIGHT","kbd.ARROW_DOWN","getPrevKey","kbd.ARROW_UP","getDirectionalKeys","isBrowser","isIOS","getIsIOS","isHTMLElement","isElement","isElementOrSVGElement","isNotNull","isSelectableInput","isElementHidden","stopAt","useRovingFocus","currentTabStopId","getCandidateNodes","focusFirstCandidate","handleKeydown","both","currentIndex","nextKey","prevKey","loop","keyToIndex","kbd.HOME","kbd.END","altNextKey","altPrevKey","itemIndex","itemToFocus","getTabIndex","anyActive","setSvelteContext","trueKey","description","getSvelteContext","getSymbolDescription","providerComponentName","contextName","createContext","useSymbol","symbolDescription","symbol","getCtx","setCtx","useId","useStateMachine","initialState","machine","reducer","watch","$.state","$.proxy","ranOnce","$.effect_root","$.user_pre_effect","$.get","usePresence","present","styles","prevAnimationNameState","dispatch","currPresent","prevPresent","prevAnimationName","currAnimationName","getAnimationName","handleAnimationEnd","isCurrentAnimation","handleAnimationStart","_c","isPresentDerived","$.derived","isPresent","$$props","$.if","$$anchor","$.snippet","node_1","$.noop","createAttrs","variant","_triggerNode","_titleNode","_contentNode","_descriptionNode","_contentId","_titleId","_triggerId","_descriptionId","_cancelNode","_attrs","_sharedProps","DialogRootState","__publicField","__privateAdd","_id","_ref","_root","_variant","_disabled","_attr","_onpointerdown","_onpointerup","_onkeydown","_props","DialogCloseState","__privateGet","kbd.SPACE","kbd.ENTER","__privateSet","_level","DialogTitleState","_snippetProps","DialogContentState","DialogOverlayState","setDialogRootContext","getDialogRootContext","useDialogRoot","useDialogTitle","useDialogContent","useDialogOverlay","useDialogClose","level","restProps","$.rest_props","titleState","mergedProps","to","getTarget","localTarget","instance","PortalConsumer","addEventListener","_event","debounce","wait","timeout","debounced","isOrContainsTarget","getOwnerDocument","el","layers","_interactOutsideProp","_behaviorType","_interceptedEvents","_isResponsibleLayer","_documentObj","_enabled","_isFocusInsideDOMTree","_onFocusOutside","_currNode","_isValidEventProp","_unsubClickListener","_handleFocus","_DismissibleLayerState_instances","addEventListeners_fn","_handleDismiss","_handleInteractOutside","_markInterceptedEvent","_markNonInterceptedEvent","_markResponsibleLayer","_isTargetWithinLayer","_resetState","isAnyEventIntercepted_fn","_onfocuscapture","_onblurcapture","DismissibleLayerState","createWrappedEvent","isEventValid","isValidEvent","__privateMethod","isResponsibleLayer","eventType","unsubEvents","useDismissibleLayer","getTopMostLayer","layersArr","behaviorType","topMostLayer","firstLayerNode","capturedCurrentTarget","capturedTarget","newEvent","isPrevented","interactOutsideBehavior","onInteractOutside","onFocusOutside","dismissibleLayerState","_onEscapeProp","_addEventListener","EscapeLayerState","kbd.ESCAPE","isResponsibleEscapeLayer","clonedEvent","useEscapeLayer","escapeKeydownBehavior","onEscapeKeydown","focusStack","createFocusScopeStack","stack","focusScope","activeFocusScope","removeFromFocusScopeArray","createFocusScopeAPI","paused","removeLinks","focus","select","previouslyFocusedElement","focusFirst","candidates","candidate","findVisible","elements","container","getTabbableCandidates","nodes","walker","isHiddenInput","getTabbableEdges","last","AUTOFOCUS_ON_MOUNT","AUTOFOCUS_ON_DESTROY","EVENT_OPTIONS","useFocusScope","enabled","onOpenAutoFocus","onCloseAutoFocus","forceMount","focusScopeStack","lastFocusedElement","handleFocusIn","handleFocusOut","relatedTarget","handleMutations","mutationObserver","handleMount","handleDestroy","prevFocusedElement","mountEvent","destroyEvent","isTabKey","kbd.TAB","focusedElement","trapFocus","focusScopeState","_onPointerDownProp","_onPointerUpProp","_unsubSelectionLock","_TextSelectionLayerState_instances","_pointerdown","_resetSelectionLock","TextSelectionLayerState","isHighestLayer","preventTextSelectionOverflow","useTextSelectionLayer","getUserSelect","originalBodyUserSelect","originalNodeUserSelect","setUserSelect","highestLayer","preventOverflowTextSelection","onPointerDown","onPointerUp","increment","_sources","_version","_size","_SvelteMap_instances","read_all_fn","_SvelteMap","callbackfn","this_arg","prev_res","res","v_reactions","needs_version_increase","__superGet","SvelteMap","_current","_start","_subscribers","_stop","_Readable_instances","subscribe_fn","unsubscribe_fn","Readable","__privateWrapper","inEffect","activeElement","insideEffect","update","ElementSize","node$","observer","entries","entry","boxSize","boxSizeArr","size","extract","defaultValue","_previous","_curr","Previous","_node","_target","IsFocusWithin","createSharedHook","factory","subscribers","scope","dispose","useBodyLockStackCount","map","locked","initialBodyStyle","stopTouchMoveListener","resetBodyStyle","curr","bodyStyle","verticalScrollbarWidth","config","useBodyScrollLock","restoreScrollDelay","countState","_restoreScrollDelay","preventScroll","shouldTrapFocus","open","overlayState","spread_with_call","node_2","getNextMatch","values","search","currentMatch","normalizedSearch","currentMatchIndex","wrappedValues","wrapArray","nextMatch","startIndex","sides","min","max","round","floor","createCoords","oppositeSideMap","oppositeAlignmentMap","clamp","evaluate","param","getSide","placement","getAlignment","getOppositeAxis","axis","getAxisLength","getSideAxis","getAlignmentAxis","getAlignmentSides","rects","rtl","alignment","alignmentAxis","mainAlignmentSide","getOppositePlacement","getExpandedPlacements","oppositePlacement","getOppositeAlignmentPlacement","getSideList","side","isStart","lr","rl","tb","bt","getOppositeAxisPlacements","flipAlignment","direction","list","expandPaddingObject","padding","getPaddingObject","rectToClientRect","rect","x","y","width","height","computeCoordsFromPlacement","reference","floating","sideAxis","alignLength","isVertical","commonX","commonY","commonAlign","coords","computePosition","strategy","middleware","platform","validMiddleware","statefulPlacement","middlewareData","resetCount","nextX","nextY","reset","detectOverflow","_await$platform$isEle","boundary","rootBoundary","elementContext","altBoundary","paddingObject","clippingClientRect","offsetParent","offsetScale","elementClientRect","arrow","arrowDimensions","isYAxis","minProp","maxProp","clientProp","endDiff","startDiff","arrowOffsetParent","clientSize","centerToReference","largestPossiblePadding","minPadding","maxPadding","min$1","center","offset","shouldAddOffset","alignmentOffset","flip","_middlewareData$arrow","_middlewareData$flip","initialPlacement","checkMainAxis","checkCrossAxis","specifiedFallbackPlacements","fallbackStrategy","fallbackAxisSideDirection","detectOverflowOptions","initialSideAxis","isBasePlacement","fallbackPlacements","hasFallbackAxisSideDirection","placements","overflow","overflows","overflowsData","_middlewareData$flip2","_overflowsData$filter","nextIndex","nextPlacement","resetPlacement","_overflowsData$filter2","currentSideAxis","getSideOffsets","isAnySideFullyClipped","hide","offsets","convertValueToCoords","mainAxisMulti","crossAxisMulti","rawValue","mainAxis","crossAxis","_middlewareData$offse","diffCoords","shift","limiter","mainAxisCoord","crossAxisCoord","minSide","maxSide","limitedCoords","limitShift","rawOffset","computedOffset","len","limitMin","limitMax","_middlewareData$offse2","isOriginSide","_state$middlewareData","_state$middlewareData2","apply","heightSide","widthSide","maximumClippingHeight","maximumClippingWidth","overflowAvailableHeight","overflowAvailableWidth","noShift","availableHeight","availableWidth","xMin","xMax","yMin","yMax","nextDimensions","hasWindow","getNodeName","isNode","getWindow","_node$ownerDocument","getDocumentElement","isShadowRoot","isOverflowElement","overflowX","overflowY","display","getComputedStyle","isTableElement","isTopLayer","selector","isContainingBlock","elementOrCss","webkit","isWebKit","getContainingBlock","currentNode","getParentNode","isLastTraversableNode","getNodeScroll","getNearestOverflowAncestor","parentNode","getOverflowAncestors","traverseIframes","_node$ownerDocument2","scrollableAncestor","isBody","win","frameElement","getFrameElement","getCssDimensions","hasOffset","offsetWidth","offsetHeight","shouldFallback","unwrapElement","getScale","domElement","$","noOffsets","getVisualOffsets","shouldAddVisualOffsets","isFixed","floatingOffsetParent","getBoundingClientRect","includeScale","isFixedStrategy","clientRect","scale","visualOffsets","offsetWin","currentWin","currentIFrame","iframeScale","iframeRect","left","top","getWindowScrollBarX","leftScroll","getHTMLOffset","documentElement","scroll","ignoreScrollbarX","htmlRect","convertOffsetParentRelativeRectToViewportRelativeRect","topLayer","isOffsetParentAnElement","offsetRect","htmlOffset","getClientRects","getDocumentRect","getViewportRect","visualViewport","visualViewportBased","getInnerBoundingClientRect","getClientRectFromClippingAncestor","clippingAncestor","hasFixedPositionAncestor","stopNode","getClippingElementAncestors","cache","cachedResult","currentContainingBlockComputedStyle","elementIsFixed","computedStyle","currentNodeIsContaining","ancestor","getClippingRect","clippingAncestors","firstClippingAncestor","clippingRect","accRect","getDimensions","getRectRelativeToOffsetParent","isStaticPositioned","getTrueOffsetParent","polyfill","rawOffsetParent","getOffsetParent","svgOffsetParent","getElementRects","getOffsetParentFn","getDimensionsFn","floatingDimensions","isRTL","observeMove","onMove","io","timeoutId","_io","refresh","skip","threshold","insetTop","insetRight","insetBottom","insetLeft","isFirstUpdate","handleObserve","ratio","autoUpdate","ancestorScroll","ancestorResize","elementResize","layoutShift","animationFrame","referenceEl","ancestors","cleanupIo","reobserveFrame","resizeObserver","firstEntry","_resizeObserver","frameId","prevRefRect","frameLoop","nextRefRect","_resizeObserver2","offset$1","shift$1","flip$1","size$1","hide$1","arrow$1","limitShift$1","mergedOptions","platformWithCache","computePosition$1","valueOrGetValue","getDPR","roundByDPR","dpr","getFloatingContentCSSVars","useFloating","whileElementsMountedOption","openOption","middlewareOption","transformOption","placementOption","strategyOption","isPositioned","floatingStyles","initialStyles","xVal","yVal","whileElementsMountedCleanup","attach","OPPOSITE_SIDE","FloatingRootState","_transformedStyle","_dir","_side","_sideOffset","_align","_alignOffset","_arrowPadding","_avoidCollisions","_collisionBoundary","_collisionPadding","_sticky","_hideWhenDetached","_strategy","_updatePositionStrategy","_arrowSize","_arrowWidth","_arrowHeight","_desiredPlacement","_boundary","_hasExplicitBoundaries","_detectOverflowOptions","_availableWidth","_availableHeight","_anchorWidth","_anchorHeight","_middleware","_placedSide","_placedAlign","_arrowX","_arrowY","_cannotCenterArrow","_contentZIndex","_arrowBaseSide","_wrapperProps","_arrowStyle","FloatingContentState","anchorWidth","anchorHeight","transformOrigin","getSideFromPlacement","getAlignFromPlacement","contentNode","FloatingAnchorState","setFloatingRootContext","getFloatingRootContext","setFloatingContentContext","getFloatingContentContext","useFloatingRootState","useFloatingContentState","useFloatingAnchorState","isArrowHidden","arrowWidth","arrowHeight","placedSide","placedAlign","getSideAndAlignFromPlacement","noArrowAlign","arrowXCenter","arrowYCenter","align","boxAutoReset","afterMs","resetAfter","useDOMTypeahead","onMatch","getCurrentItem","handleTypeaheadSearch","currentItem","newItem","resetTypeahead","sideOffset","alignOffset","arrowPadding","avoidCollisions","collisionBoundary","$.prop","collisionPadding","hideWhenDetached","onPlaced","sticky","updatePositionStrategy","wrapperId","customAnchor","contentState","isStatic","floatingProps","focusScopeProps","dismissibleProps","isMounted","onMountedChange","SELECTION_KEYS","FIRST_KEYS","kbd.PAGE_UP","LAST_KEYS","kbd.PAGE_DOWN","FIRST_LAST_KEYS","isMouseEvent","pointInPolygon","point","polygon","inside","xi","yi","xj","yj","isPointerInGraceArea","area","setMenuRootContext","getMenuRootContext","setMenuMenuContext","getMenuMenuContext","setMenuContentContext","getMenuContentContext","MenuRootState","callbacksToDispose","handlePointer","disposeKeydown","disposePointerDown","disposePointerMove","MenuMenuState","parentMenu","_search","_loop","_timer","_pointerGraceTimer","_pointerGraceIntent","_pointerDir","_lastPointerX","_handleTypeaheadSearch","_onblur","_onfocus","_onpointermove","MenuContentState","intent","currentTarget","isKeydownInside","isModifierKey","isCharacterKey","candidateNodes","pointerXHasChanged","newDir","triggerId","_isFocused","_onpointerleave","MenuItemSharedState","_item","_onSelect","_isPointerDown","_handleSelect","_onclick","MenuItemState","isTypingAhead","selectEvent","_parentMenu","_ariaControls","DropdownMenuTriggerState","useMenuRoot","useMenuMenu","menu","useMenuDropdownTrigger","useMenuContent","useMenuItem","disabled","onSelect","itemState","onOpenChange","controlledOpen","closeState","present_1","handleInteractOutside","handleEscapeKeydown","finalProps","triggerState","className","$.set_svg_class","svg","Dropdown","DropdownMenu.Root","Trigger","Content","Item","$.each","node_3","feature","$.template_effect","$.set_text","Current","matches","Modal","Dialog.Root","Dialog.Portal","Overlay","Header","Title","Close","CloseIcon","Body","Footer","BODY_FONTS","BODY_STYLES","render","renderTitle","renderCommits","renderMergeRequests","renderExtra","renderBody","renderListWithTitle","renderCBs","cbs","renderBranch","renderCommit","renderAnchor","commit","linkify","mr","linkifyAll","title","allowCollapse","renderList","url","copy","rendered","renderComment","BASE_URL","GitLab","project","sha","endpoint","query","CherryPicks","SHAs","findSHAsForCommit","cherryPickSHA","branches","cherryPicks","cherryPick","parseSHAsFromComments","Parse","message","line","skipEmptyLines","parseTitle","processNextLine","skipCherryPicks","collapseEmptyLines","parseTicket","parseExtra","parseBody","skipWithPattern","pattern","didSkip","didCollapse","nextLine","Comments","mergeRequests","base","step","setLoadingState","autoResolvedBase","setResultState","newIsOpen","closeModal","controls","$$value","makeControls","close","inject","injectOnCommitDetailPage","injectToProjectLastCommit","injectModals","makeGenerateTicketCommentModalControls","header","projectRef","FeatureDropdown","group","shaElement","modalsContainer","Modals"],"mappings":"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","x_google_ignoreList":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122]}